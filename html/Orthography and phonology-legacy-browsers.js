/********************************** 
 * Orthography And Phonology Test *
 **********************************/

// init psychoJS:
const psychoJS = new PsychoJS({
  debug: true
});

// open window:
psychoJS.openWindow({
  fullscr: false,
  color: new util.Color([0, 0, 0]),
  units: 'height',
  waitBlanking: true
});

// store info about the experiment session:
let expName = 'Orthography and phonology';  // from the Builder filename that created this script
let expInfo = {'participant': '', 'session': '', 'group': ''};

// schedule the experiment:
psychoJS.schedule(psychoJS.gui.DlgFromDict({
  dictionary: expInfo,
  title: expName
}));

const flowScheduler = new Scheduler(psychoJS);
const dialogCancelScheduler = new Scheduler(psychoJS);
psychoJS.scheduleCondition(function() { return (psychoJS.gui.dialogComponent.button === 'OK'); }, flowScheduler, dialogCancelScheduler);

// flowScheduler gets run if the participants presses OK
flowScheduler.add(updateInfo); // add timeStamp
flowScheduler.add(experimentInit);
flowScheduler.add(WelcomeScreenRoutineBegin());
flowScheduler.add(WelcomeScreenRoutineEachFrame());
flowScheduler.add(WelcomeScreenRoutineEnd());
flowScheduler.add(GeneralInstructionRoutineBegin());
flowScheduler.add(GeneralInstructionRoutineEachFrame());
flowScheduler.add(GeneralInstructionRoutineEnd());
flowScheduler.add(Phase1instructionsRoutineBegin());
flowScheduler.add(Phase1instructionsRoutineEachFrame());
flowScheduler.add(Phase1instructionsRoutineEnd());
flowScheduler.add(SoundRecognitionT1T1RoutineBegin());
flowScheduler.add(SoundRecognitionT1T1RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T1RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T2RoutineBegin());
flowScheduler.add(SoundRecognitionT1T2RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T2RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T3RoutineBegin());
flowScheduler.add(SoundRecognitionT1T3RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T3RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T4RoutineBegin());
flowScheduler.add(SoundRecognitionT1T4RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T4RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T5RoutineBegin());
flowScheduler.add(SoundRecognitionT1T5RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T5RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T6RoutineBegin());
flowScheduler.add(SoundRecognitionT1T6RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T6RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T7RoutineBegin());
flowScheduler.add(SoundRecognitionT1T7RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T7RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T8RoutineBegin());
flowScheduler.add(SoundRecognitionT1T8RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T8RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T9RoutineBegin());
flowScheduler.add(SoundRecognitionT1T9RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T9RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T10RoutineBegin());
flowScheduler.add(SoundRecognitionT1T10RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T10RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T11RoutineBegin());
flowScheduler.add(SoundRecognitionT1T11RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T11RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT1T12RoutineBegin());
flowScheduler.add(SoundRecognitionT1T12RoutineEachFrame());
flowScheduler.add(SoundRecognitionT1T12RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase1instructions2RoutineBegin());
flowScheduler.add(Phase1instructions2RoutineEachFrame());
flowScheduler.add(Phase1instructions2RoutineEnd());
flowScheduler.add(SoundRecognitionT2T1RoutineBegin());
flowScheduler.add(SoundRecognitionT2T1RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T1RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T2RoutineBegin());
flowScheduler.add(SoundRecognitionT2T2RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T2RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T3RoutineBegin());
flowScheduler.add(SoundRecognitionT2T3RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T3RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T4RoutineBegin());
flowScheduler.add(SoundRecognitionT2T4RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T4RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T5RoutineBegin());
flowScheduler.add(SoundRecognitionT2T5RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T5RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T6RoutineBegin());
flowScheduler.add(SoundRecognitionT2T6RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T6RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T7RoutineBegin());
flowScheduler.add(SoundRecognitionT2T7RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T7RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T8RoutineBegin());
flowScheduler.add(SoundRecognitionT2T8RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T8RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T9RoutineBegin());
flowScheduler.add(SoundRecognitionT2T9RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T9RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T10RoutineBegin());
flowScheduler.add(SoundRecognitionT2T10RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T10RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T11RoutineBegin());
flowScheduler.add(SoundRecognitionT2T11RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T11RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(SoundRecognitionT2T12RoutineBegin());
flowScheduler.add(SoundRecognitionT2T12RoutineEachFrame());
flowScheduler.add(SoundRecognitionT2T12RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(EndSoundRecognitionRoutineBegin());
flowScheduler.add(EndSoundRecognitionRoutineEachFrame());
flowScheduler.add(EndSoundRecognitionRoutineEnd());
flowScheduler.add(Phase2instructionsRoutineBegin());
flowScheduler.add(Phase2instructionsRoutineEachFrame());
flowScheduler.add(Phase2instructionsRoutineEnd());
const trialsLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(trialsLoopBegin, trialsLoopScheduler);
flowScheduler.add(trialsLoopScheduler);
flowScheduler.add(trialsLoopEnd);
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(EndWordLearningRoutineBegin());
flowScheduler.add(EndWordLearningRoutineEachFrame());
flowScheduler.add(EndWordLearningRoutineEnd());
flowScheduler.add(Phase3Instructions1RoutineBegin());
flowScheduler.add(Phase3Instructions1RoutineEachFrame());
flowScheduler.add(Phase3Instructions1RoutineEnd());
flowScheduler.add(CriterionTestT1T1RoutineBegin());
flowScheduler.add(CriterionTestT1T1RoutineEachFrame());
flowScheduler.add(CriterionTestT1T1RoutineEnd());
flowScheduler.add(CriterionTestT1T2RoutineBegin());
flowScheduler.add(CriterionTestT1T2RoutineEachFrame());
flowScheduler.add(CriterionTestT1T2RoutineEnd());
flowScheduler.add(CriterionTestT1T3RoutineBegin());
flowScheduler.add(CriterionTestT1T3RoutineEachFrame());
flowScheduler.add(CriterionTestT1T3RoutineEnd());
flowScheduler.add(CriterionTestT1T4RoutineBegin());
flowScheduler.add(CriterionTestT1T4RoutineEachFrame());
flowScheduler.add(CriterionTestT1T4RoutineEnd());
flowScheduler.add(CriteterionTestT1T5RoutineBegin());
flowScheduler.add(CriteterionTestT1T5RoutineEachFrame());
flowScheduler.add(CriteterionTestT1T5RoutineEnd());
flowScheduler.add(CriterionTestT1T6RoutineBegin());
flowScheduler.add(CriterionTestT1T6RoutineEachFrame());
flowScheduler.add(CriterionTestT1T6RoutineEnd());
flowScheduler.add(CritertionTestT1T7RoutineBegin());
flowScheduler.add(CritertionTestT1T7RoutineEachFrame());
flowScheduler.add(CritertionTestT1T7RoutineEnd());
flowScheduler.add(CriterionTestT1T8RoutineBegin());
flowScheduler.add(CriterionTestT1T8RoutineEachFrame());
flowScheduler.add(CriterionTestT1T8RoutineEnd());
flowScheduler.add(CriterionTestT1T9RoutineBegin());
flowScheduler.add(CriterionTestT1T9RoutineEachFrame());
flowScheduler.add(CriterionTestT1T9RoutineEnd());
flowScheduler.add(CritertionTestT1T10RoutineBegin());
flowScheduler.add(CritertionTestT1T10RoutineEachFrame());
flowScheduler.add(CritertionTestT1T10RoutineEnd());
flowScheduler.add(CriterionTestT1T11RoutineBegin());
flowScheduler.add(CriterionTestT1T11RoutineEachFrame());
flowScheduler.add(CriterionTestT1T11RoutineEnd());
flowScheduler.add(CriterionTestT1T12RoutineBegin());
flowScheduler.add(CriterionTestT1T12RoutineEachFrame());
flowScheduler.add(CriterionTestT1T12RoutineEnd());
flowScheduler.add(Phase3instructions2_2RoutineBegin());
flowScheduler.add(Phase3instructions2_2RoutineEachFrame());
flowScheduler.add(Phase3instructions2_2RoutineEnd());
flowScheduler.add(CriterionTestT2T1RoutineBegin());
flowScheduler.add(CriterionTestT2T1RoutineEachFrame());
flowScheduler.add(CriterionTestT2T1RoutineEnd());
flowScheduler.add(CriterionTestT2T2RoutineBegin());
flowScheduler.add(CriterionTestT2T2RoutineEachFrame());
flowScheduler.add(CriterionTestT2T2RoutineEnd());
flowScheduler.add(CriterionTestT2T3RoutineBegin());
flowScheduler.add(CriterionTestT2T3RoutineEachFrame());
flowScheduler.add(CriterionTestT2T3RoutineEnd());
flowScheduler.add(CriterionTestT3T4RoutineBegin());
flowScheduler.add(CriterionTestT3T4RoutineEachFrame());
flowScheduler.add(CriterionTestT3T4RoutineEnd());
flowScheduler.add(CriterionTestT2T5RoutineBegin());
flowScheduler.add(CriterionTestT2T5RoutineEachFrame());
flowScheduler.add(CriterionTestT2T5RoutineEnd());
flowScheduler.add(CriterionTestT2T6RoutineBegin());
flowScheduler.add(CriterionTestT2T6RoutineEachFrame());
flowScheduler.add(CriterionTestT2T6RoutineEnd());
flowScheduler.add(CriterionTestT2T7RoutineBegin());
flowScheduler.add(CriterionTestT2T7RoutineEachFrame());
flowScheduler.add(CriterionTestT2T7RoutineEnd());
flowScheduler.add(CriterionTestT2T8RoutineBegin());
flowScheduler.add(CriterionTestT2T8RoutineEachFrame());
flowScheduler.add(CriterionTestT2T8RoutineEnd());
flowScheduler.add(CriterionTestT2T9RoutineBegin());
flowScheduler.add(CriterionTestT2T9RoutineEachFrame());
flowScheduler.add(CriterionTestT2T9RoutineEnd());
flowScheduler.add(CriterionTestT2T10RoutineBegin());
flowScheduler.add(CriterionTestT2T10RoutineEachFrame());
flowScheduler.add(CriterionTestT2T10RoutineEnd());
flowScheduler.add(CriterionTestT2T11RoutineBegin());
flowScheduler.add(CriterionTestT2T11RoutineEachFrame());
flowScheduler.add(CriterionTestT2T11RoutineEnd());
flowScheduler.add(CriterionTestT2T12RoutineBegin());
flowScheduler.add(CriterionTestT2T12RoutineEachFrame());
flowScheduler.add(CriterionTestT2T12RoutineEnd());
flowScheduler.add(EndCriterionTestRoutineBegin());
flowScheduler.add(EndCriterionTestRoutineEachFrame());
flowScheduler.add(EndCriterionTestRoutineEnd());
flowScheduler.add(Phase4Instructions1RoutineBegin());
flowScheduler.add(Phase4Instructions1RoutineEachFrame());
flowScheduler.add(Phase4Instructions1RoutineEnd());
flowScheduler.add(FinalTestT1T1RoutineBegin());
flowScheduler.add(FinalTestT1T1RoutineEachFrame());
flowScheduler.add(FinalTestT1T1RoutineEnd());
flowScheduler.add(FinalTestT1T2RoutineBegin());
flowScheduler.add(FinalTestT1T2RoutineEachFrame());
flowScheduler.add(FinalTestT1T2RoutineEnd());
flowScheduler.add(FinalTestT1T3RoutineBegin());
flowScheduler.add(FinalTestT1T3RoutineEachFrame());
flowScheduler.add(FinalTestT1T3RoutineEnd());
flowScheduler.add(FinalTestT1T4RoutineBegin());
flowScheduler.add(FinalTestT1T4RoutineEachFrame());
flowScheduler.add(FinalTestT1T4RoutineEnd());
flowScheduler.add(FinalTestT1T5RoutineBegin());
flowScheduler.add(FinalTestT1T5RoutineEachFrame());
flowScheduler.add(FinalTestT1T5RoutineEnd());
flowScheduler.add(FinalTestT1T6RoutineBegin());
flowScheduler.add(FinalTestT1T6RoutineEachFrame());
flowScheduler.add(FinalTestT1T6RoutineEnd());
flowScheduler.add(FinalTestT1T7RoutineBegin());
flowScheduler.add(FinalTestT1T7RoutineEachFrame());
flowScheduler.add(FinalTestT1T7RoutineEnd());
flowScheduler.add(FinalTestT1T8RoutineBegin());
flowScheduler.add(FinalTestT1T8RoutineEachFrame());
flowScheduler.add(FinalTestT1T8RoutineEnd());
flowScheduler.add(FinalTestT1T9RoutineBegin());
flowScheduler.add(FinalTestT1T9RoutineEachFrame());
flowScheduler.add(FinalTestT1T9RoutineEnd());
flowScheduler.add(FinalTestT1T10RoutineBegin());
flowScheduler.add(FinalTestT1T10RoutineEachFrame());
flowScheduler.add(FinalTestT1T10RoutineEnd());
flowScheduler.add(FinalTestT1T11RoutineBegin());
flowScheduler.add(FinalTestT1T11RoutineEachFrame());
flowScheduler.add(FinalTestT1T11RoutineEnd());
flowScheduler.add(FinalTestT1T12RoutineBegin());
flowScheduler.add(FinalTestT1T12RoutineEachFrame());
flowScheduler.add(FinalTestT1T12RoutineEnd());
flowScheduler.add(Phase4Instructions2RoutineBegin());
flowScheduler.add(Phase4Instructions2RoutineEachFrame());
flowScheduler.add(Phase4Instructions2RoutineEnd());
flowScheduler.add(FinalTestT2T1RoutineBegin());
flowScheduler.add(FinalTestT2T1RoutineEachFrame());
flowScheduler.add(FinalTestT2T1RoutineEnd());
flowScheduler.add(FinalTestT2T2RoutineBegin());
flowScheduler.add(FinalTestT2T2RoutineEachFrame());
flowScheduler.add(FinalTestT2T2RoutineEnd());
flowScheduler.add(FinalTestT2T3RoutineBegin());
flowScheduler.add(FinalTestT2T3RoutineEachFrame());
flowScheduler.add(FinalTestT2T3RoutineEnd());
flowScheduler.add(FinalTestT2T4RoutineBegin());
flowScheduler.add(FinalTestT2T4RoutineEachFrame());
flowScheduler.add(FinalTestT2T4RoutineEnd());
flowScheduler.add(FinalTestT2T5RoutineBegin());
flowScheduler.add(FinalTestT2T5RoutineEachFrame());
flowScheduler.add(FinalTestT2T5RoutineEnd());
flowScheduler.add(FinalTestT2T6RoutineBegin());
flowScheduler.add(FinalTestT2T6RoutineEachFrame());
flowScheduler.add(FinalTestT2T6RoutineEnd());
flowScheduler.add(FinalTestT2T7RoutineBegin());
flowScheduler.add(FinalTestT2T7RoutineEachFrame());
flowScheduler.add(FinalTestT2T7RoutineEnd());
flowScheduler.add(FinalTestT2T8RoutineBegin());
flowScheduler.add(FinalTestT2T8RoutineEachFrame());
flowScheduler.add(FinalTestT2T8RoutineEnd());
flowScheduler.add(FinalTestT2T9RoutineBegin());
flowScheduler.add(FinalTestT2T9RoutineEachFrame());
flowScheduler.add(FinalTestT2T9RoutineEnd());
flowScheduler.add(FinalTestT2T10RoutineBegin());
flowScheduler.add(FinalTestT2T10RoutineEachFrame());
flowScheduler.add(FinalTestT2T10RoutineEnd());
flowScheduler.add(FinalTestT2T11RoutineBegin());
flowScheduler.add(FinalTestT2T11RoutineEachFrame());
flowScheduler.add(FinalTestT2T11RoutineEnd());
flowScheduler.add(FinalTestT2T12RoutineBegin());
flowScheduler.add(FinalTestT2T12RoutineEachFrame());
flowScheduler.add(FinalTestT2T12RoutineEnd());
flowScheduler.add(EndPhase4RoutineBegin());
flowScheduler.add(EndPhase4RoutineEachFrame());
flowScheduler.add(EndPhase4RoutineEnd());
flowScheduler.add(Phase5Instructions1RoutineBegin());
flowScheduler.add(Phase5Instructions1RoutineEachFrame());
flowScheduler.add(Phase5Instructions1RoutineEnd());
flowScheduler.add(Phase5T1T1RoutineBegin());
flowScheduler.add(Phase5T1T1RoutineEachFrame());
flowScheduler.add(Phase5T1T1RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T2RoutineBegin());
flowScheduler.add(Phase5T1T2RoutineEachFrame());
flowScheduler.add(Phase5T1T2RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T3RoutineBegin());
flowScheduler.add(Phase5T1T3RoutineEachFrame());
flowScheduler.add(Phase5T1T3RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T4RoutineBegin());
flowScheduler.add(Phase5T1T4RoutineEachFrame());
flowScheduler.add(Phase5T1T4RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T5RoutineBegin());
flowScheduler.add(Phase5T1T5RoutineEachFrame());
flowScheduler.add(Phase5T1T5RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T6RoutineBegin());
flowScheduler.add(Phase5T1T6RoutineEachFrame());
flowScheduler.add(Phase5T1T6RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T7RoutineBegin());
flowScheduler.add(Phase5T1T7RoutineEachFrame());
flowScheduler.add(Phase5T1T7RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T8RoutineBegin());
flowScheduler.add(Phase5T1T8RoutineEachFrame());
flowScheduler.add(Phase5T1T8RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T9RoutineBegin());
flowScheduler.add(Phase5T1T9RoutineEachFrame());
flowScheduler.add(Phase5T1T9RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T10RoutineBegin());
flowScheduler.add(Phase5T1T10RoutineEachFrame());
flowScheduler.add(Phase5T1T10RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T11RoutineBegin());
flowScheduler.add(Phase5T1T11RoutineEachFrame());
flowScheduler.add(Phase5T1T11RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T1T12RoutineBegin());
flowScheduler.add(Phase5T1T12RoutineEachFrame());
flowScheduler.add(Phase5T1T12RoutineEnd());
flowScheduler.add(Phase1instructions2RoutineBegin());
flowScheduler.add(Phase1instructions2RoutineEachFrame());
flowScheduler.add(Phase1instructions2RoutineEnd());
flowScheduler.add(Phase5T2T1RoutineBegin());
flowScheduler.add(Phase5T2T1RoutineEachFrame());
flowScheduler.add(Phase5T2T1RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T2RoutineBegin());
flowScheduler.add(Phase5T2T2RoutineEachFrame());
flowScheduler.add(Phase5T2T2RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T3RoutineBegin());
flowScheduler.add(Phase5T2T3RoutineEachFrame());
flowScheduler.add(Phase5T2T3RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T4RoutineBegin());
flowScheduler.add(Phase5T2T4RoutineEachFrame());
flowScheduler.add(Phase5T2T4RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T5RoutineBegin());
flowScheduler.add(Phase5T2T5RoutineEachFrame());
flowScheduler.add(Phase5T2T5RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T6RoutineBegin());
flowScheduler.add(Phase5T2T6RoutineEachFrame());
flowScheduler.add(Phase5T2T6RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T7RoutineBegin());
flowScheduler.add(Phase5T2T7RoutineEachFrame());
flowScheduler.add(Phase5T2T7RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T8RoutineBegin());
flowScheduler.add(Phase5T2T8RoutineEachFrame());
flowScheduler.add(Phase5T2T8RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T9RoutineBegin());
flowScheduler.add(Phase5T2T9RoutineEachFrame());
flowScheduler.add(Phase5T2T9RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T10RoutineBegin());
flowScheduler.add(Phase5T2T10RoutineEachFrame());
flowScheduler.add(Phase5T2T10RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T11RoutineBegin());
flowScheduler.add(Phase5T2T11RoutineEachFrame());
flowScheduler.add(Phase5T2T11RoutineEnd());
flowScheduler.add(BlankRoutineBegin());
flowScheduler.add(BlankRoutineEachFrame());
flowScheduler.add(BlankRoutineEnd());
flowScheduler.add(Phase5T2T12RoutineBegin());
flowScheduler.add(Phase5T2T12RoutineEachFrame());
flowScheduler.add(Phase5T2T12RoutineEnd());
flowScheduler.add(EndExperimentRoutineBegin());
flowScheduler.add(EndExperimentRoutineEachFrame());
flowScheduler.add(EndExperimentRoutineEnd());
flowScheduler.add(quitPsychoJS, '', true);

// quit if user presses Cancel in dialog box:
dialogCancelScheduler.add(quitPsychoJS, '', false);

psychoJS.start({
  expName: expName,
  expInfo: expInfo,
  });


var frameDur;
function updateInfo() {
  expInfo['date'] = util.MonotonicClock.getDateStr();  // add a simple timestamp
  expInfo['expName'] = expName;
  expInfo['psychopyVersion'] = '2020.1.2';
  expInfo['OS'] = window.navigator.platform;

  // store frame rate of monitor if we can measure it successfully
  expInfo['frameRate'] = psychoJS.window.getActualFrameRate();
  if (typeof expInfo['frameRate'] !== 'undefined')
    frameDur = 1.0 / Math.round(expInfo['frameRate']);
  else
    frameDur = 1.0 / 60.0; // couldn't get a reliable measure so guess

  // add info from the URL:
  util.addInfoFromUrl(expInfo);
  
  return Scheduler.Event.NEXT;
}


var WelcomeScreenClock;
var textWelcome;
var key_welcome;
var GeneralInstructionClock;
var text_gen_inst;
var key_Gen_inst;
var Phase1instructionsClock;
var Phase1_inst;
var key_Phase1_inst;
var SoundRecognitionT1T1Clock;
var sound_thth;
var sound_th;
var key_SRT1T1;
var text_SRT1T1;
var phases_SRT1T1;
var BlankClock;
var text_blank;
var SoundRecognitionT1T2Clock;
var sound_thth2;
var sound_thth3;
var key_SRT1T2;
var text_SRT1T2;
var phases_SRT1T2;
var SoundRecognitionT1T3Clock;
var sound_thth4;
var sound_sh;
var key_SRT1T3;
var text_SRT1T3;
var phases_SRT1T3;
var SoundRecognitionT1T4Clock;
var sound_thth5;
var sound_thth6;
var key_SRT1T4;
var text_SRT1T4;
var phases_SRT1T4;
var SoundRecognitionT1T5Clock;
var sound_th2;
var sound_thth7;
var key_SRT1T5;
var text_SRT1T5;
var phases_SRT1T5;
var SoundRecognitionT1T6Clock;
var sound_th4;
var sound_th3;
var key_SRT1T6;
var text_SRT1T6;
var phases_SRT1T6;
var SoundRecognitionT1T7Clock;
var sound_th5;
var sound_sh8;
var key_SRT1T7;
var text_SRT1T7;
var phases_SRT1T7;
var SoundRecognitionT1T8Clock;
var sound_th7;
var sound_th8;
var key_SRT1T8;
var text_SRT1T8;
var phases_SRT1T8;
var SoundRecognitionT1T9Clock;
var sound_sh2;
var sound_thth8;
var key_SRT1T9;
var text_SRT1T9;
var phases_SRT1T9;
var SoundRecognitionT1T10Clock;
var sound_sh3;
var sound_th9;
var key_SRT1T10;
var text_SRT1T10;
var phases_SRT1T10;
var SoundRecognitionT1T11Clock;
var sound_sh4;
var sound_sh5;
var key_SRT1T11;
var text_SRT1T11;
var phases_SRT1T11;
var SoundRecognitionT1T12Clock;
var sound_sh6;
var sound_sh7;
var key_SRT1T12;
var text_SRT1T12;
var phases_SRT1T12;
var Phase1instructions2Clock;
var text_phase1_inst2;
var key_phase1_inst2;
var SoundRecognitionT2T1Clock;
var sound_thrwa_thrwa;
var key_SRT2T1;
var text_SRT2T1;
var phases_SRT2T1;
var SoundRecognitionT2T2Clock;
var sound_ththm_thm;
var key_SRT2T2;
var text_SRT2T2;
var phases_SRT2T2;
var SoundRecognitionT2T3Clock;
var sound_ththab_shab;
var key_SRT2T3;
var text_SRT2T3;
var phases_SRT2T3;
var SoundRecognitionT2T4Clock;
var sound_ththna_ththna;
var key_SRT2T4;
var text_SRT2T4;
var phases_SRT2T4;
var SoundRecognitionT2T5Clock;
var sound_thra_ththra;
var key_SRT2T5;
var text_SRT2T5;
var phases_SRT2T5;
var SoundRecognitionT2T6Clock;
var sound_thb7_shb7;
var key_SRT2T6;
var text_SRT2T6;
var phases_SRT2T6;
var SoundRecognitionT2T7Clock;
var sound_thwq_thwq;
var key_SRT2T7;
var text_SRT2T7;
var phases_SRT2T7;
var SoundRecognitionT2T8Clock;
var sound_thail_thail;
var key_SRT2T8;
var text_SRT2T8;
var phases_SRT2T8;
var SoundRecognitionT2T9Clock;
var sound_shrf_thrf;
var key_SRT2T9;
var text_SRT2T9;
var phases_SRT2T9;
var SoundRecognitionT2T10Clock;
var sound_sh7m_sh7m;
var key_SRT2T10;
var text_SRT2T10;
var phases_SRT2T10;
var SoundRecognitionT2T11Clock;
var sound_shra_ththra;
var key_SRT2T11;
var text_SRT2T11;
var phases_SRT2T11;
var SoundRecognitionT2T12Clock;
var sound_shfa_shfa;
var key_SRT2T12;
var text_SRT2T12;
var phases_SRT2T12;
var EndSoundRecognitionClock;
var text_EndSR;
var key_EndSR;
var phases_endSR;
var Phase2instructionsClock;
var text;
var key_WLinst;
var WordLearningT1Clock;
var sound_ththami;
var image_ththami;
var sound_thami;
var image_thami;
var WordLearningT2Clock;
var sound_ththuri;
var image_ththuri;
var sound_thuri;
var image_thuri;
var WordLearningT3Clock;
var sound_ththano;
var image_ththano;
var sound_thano;
var image_thano;
var EndWordLearningClock;
var text_EndWL;
var key_EndWL;
var phases_endWL;
var Phase3Instructions1Clock;
var text_CTInstructionsT1;
var key_CTinstructionsT1;
var CriterionTestT1T1Clock;
var sound_thuri2;
var image_thuri2;
var Text_CT_T1T1;
var key_CT_T1T1;
var phases_CT_T1T1;
var CriterionTestT1T2Clock;
var sound_thano2;
var image_ththami2;
var text_CT_T1T2;
var key_CT_T1T2;
var phases_CT_T1T2;
var CriterionTestT1T3Clock;
var sound_ththuri3;
var image_ththuri3;
var text_CT_T1T3;
var key_CT_T1T3;
var phases_CT_T1T3;
var CriterionTestT1T4Clock;
var sound_thami3;
var image_thami3;
var text_CT_T1T4;
var key_CT_T1T4;
var phases_CT_T1T4;
var CriteterionTestT1T5Clock;
var sound_ththano2;
var image_thuri3;
var text_CT_T1T5;
var key_CT_T1T5;
var phases_CT_T1T5;
var CriterionTestT1T6Clock;
var sound_ththami3;
var image_ththami3;
var text_CT_T1T6;
var key_CT_T1T6;
var phases_CT_T1T6;
var CritertionTestT1T7Clock;
var sound_thuri3;
var image_ththano2;
var text_CT_T1T7;
var key_CT_T1T7;
var phases_CT_T1T7;
var CriterionTestT1T8Clock;
var sound_ththuri2;
var image_thami2;
var text_CT_T1T8;
var key_CT_T1T8;
var phases_CT_T1T8;
var CriterionTestT1T9Clock;
var sound_thano3;
var image_thano3;
var text_CT_T1T9;
var key_CT_T1T9;
var phases_CT_T1T9;
var CritertionTestT1T10Clock;
var sound_ththami2;
var image_thano2;
var text_CT_T1T10;
var key_CT_T1T10;
var phases_CT_T1T10;
var CriterionTestT1T11Clock;
var sound_ththano3;
var image_ththano3;
var text_CT_T1T11;
var key_CT_T1T11;
var phases_CT_T1T11;
var CriterionTestT1T12Clock;
var sound_thami2;
var image_ththuri2;
var text_CT_T1T12;
var key_CT_T1T12;
var phases_CT_T1T12;
var Phase3instructions2_2Clock;
var text_CTinstructions2;
var key_CTinstructions2;
var CriterionTestT2T1Clock;
var image_ththuri4;
var image_thano4;
var text_CT_T2T1_1;
var text_CT_T2T1_0;
var sound_ththuri4;
var text_CT_T2T1;
var key_CT_T2T1;
var phases_CT_T2T1;
var CriterionTestT2T2Clock;
var image_thuri4;
var image_ththami4;
var text_CT_T2T2_1;
var text_CT_T2T2_0;
var sound_ththami4;
var text_CT_T2T2;
var key_CT_T2T2;
var CT_T2T2;
var CriterionTestT2T3Clock;
var image_ththano4;
var image_thami4;
var text_CT_T2T3_1;
var text_CT_T2T3_0;
var sound_ththano4;
var text_CT_T2T3;
var key_CT_T2T3;
var phases_CT_T2T3;
var CriterionTestT3T4Clock;
var image_ththami5;
var image_thano5;
var text_CT_T2T4_1;
var text_CT_T2T4_0;
var sound_ththami5;
var text_CT_T2T4;
var key_CT_T2T4;
var phases_CT_T2T4;
var CriterionTestT2T5Clock;
var image_thami5;
var image_ththuri5;
var text_CT_T2T5_1;
var text_CT_T2T5_0;
var sound_ththuri5;
var text_CT_T2T5;
var key_CT_T2T5;
var phases_CT_T2T5;
var CriterionTestT2T6Clock;
var image_ththano5;
var image_thuri5;
var text_CT_T2T6_1;
var text_CT_T2T6_0;
var sound_ththano5;
var text_CT_T2T6;
var key_CT_T2T6;
var phases_CT_T2T6;
var CriterionTestT2T7Clock;
var image_ththami6;
var image_thuri6;
var text_CT_T2T7_1;
var text_CT_T2T7_0;
var sound_thuri5;
var text_CT_T2T7;
var key_CT_T2T7;
var phases_CT_T2T7;
var CriterionTestT2T8Clock;
var image_ththano6;
var image_thami6;
var text_CT_T2T8_1;
var text_CT_T2T8_0;
var sound_thami4;
var text_CT_T2T8;
var key_CT_T2T8;
var phases_CT_T2T8;
var CriterionTestT2T9Clock;
var image_ththuri6;
var image_thano6;
var text_CT_T2T9_1;
var text_CT_T2T9_0;
var sound_thano4;
var text_CT_T2T9;
var key_CT_T2T9;
var phases_CT_T2T9;
var CriterionTestT2T10Clock;
var image_thuri7;
var image_ththano7;
var text_CT_T2T10_1;
var text_CT_T2T10_0;
var sound_thuri4;
var text_CT_T2T10;
var key_CT_T2T10;
var phases_CT_T2T10;
var CriterionTestT2T11Clock;
var image_ththami7;
var image_thano7;
var text_CT_T2T11_1;
var text_CT_T2T11_0;
var sound_thano5;
var text_CT_T2T11;
var key_CT_T2T11;
var phases_CT_T2T11;
var CriterionTestT2T12Clock;
var image_thami7;
var image_ththuri7;
var text_CT_T2T12_1;
var text_CT_T2T12_0;
var sound_thami5;
var text_CT_T2T12;
var key_CT_T2T12;
var phases_CT_T2T12;
var EndCriterionTestClock;
var text_EndCT;
var key_EndCT;
var phases_endCT;
var Phase4Instructions1Clock;
var text_FTinstructions1;
var key_FTinstructions1;
var FinalTestT1T1Clock;
var sound_ththuri6;
var image_thuri8;
var text_FT_T1T1;
var key_FT_T1T1;
var phases_FT_T1T1;
var FinalTestT1T2Clock;
var sound_thami6;
var image_ththami8;
var text_FT_T1T2;
var key_FT_T1T2;
var phases_FT_T1T2;
var FinalTestT1T3Clock;
var sound_thuri6;
var image_thuri9;
var text_FT_T1T3;
var key_FT_T1T3;
var phases_FT_T1T3;
var FinalTestT1T4Clock;
var sound_ththami6;
var image_thami8;
var text_FT_T1T4;
var key_FT_T1T4;
var phases_FT_T1T4;
var FinalTestT1T5Clock;
var sound_thano6;
var image_thano8;
var text_FT_T1T5;
var key_FT_T1T5;
var phases_FT_T1T5;
var FinalTestT1T6Clock;
var sound_ththami7;
var image_ththami9;
var text_FT_T1T6;
var key_FT_T1T6;
var phases_FT_T1T6;
var FinalTestT1T7Clock;
var sound_thami7;
var image_thami9;
var text_FT_T1T7;
var key_FT_T1T7;
var phases_FT_T1T7;
var FinalTestT1T8Clock;
var sound_ththano6;
var image_thano9;
var text_FT_T1T8;
var key_FT_T1T8;
var phases_FT_T1T8;
var FinalTestT1T9Clock;
var sound_ththuri7;
var image_ththuri8;
var text_FT_T1T9;
var key_FT_T1T9;
var phases_FT_T1T9;
var FinalTestT1T10Clock;
var sound_thano7;
var image_ththano8;
var text_FT_T1T10;
var key_FT_T1T10;
var phases_FT_T1T10;
var FinalTestT1T11Clock;
var sound_thuri7;
var image_ththuri9;
var text_FT_T1T11;
var key_FT_T1T11;
var phases_FT_T1T11;
var FinalTestT1T12Clock;
var sound_ththano7;
var image_ththano9;
var text_FT_T1T12;
var key_FT_T1T12;
var phases_FT_T1T12;
var Phase4Instructions2Clock;
var text_FTinstructiosn2;
var key_FTinstructions2;
var FinalTestT2T1Clock;
var image_ththami10;
var image_thami10;
var text_FT_T2T1_1;
var text_FT_T2T1_0;
var sound_ththami8;
var text_FT_T2T1;
var key_FT_T2T1;
var phases_FT_T2T1;
var FinalTestT2T2Clock;
var image_thano10;
var image_ththano10;
var text_FT_T2T2_1;
var text_FT_T2T2_0;
var sound_thano8;
var text_FT_T2T2;
var key_FT_T2T2;
var phases_FT_T2T2;
var FinalTestT2T3Clock;
var image_ththuri10;
var image_thuri10;
var text_FT_T2T3_1;
var text_FT_T2T3_0;
var sound_thuri8;
var text_FT_T2T3;
var key_FT_T2T3;
var phases_FT_T2T3;
var FinalTestT2T4Clock;
var image_thami11;
var image_ththami11;
var text_FT_T2T4_1;
var text_FT_T2T4_0;
var sound_thami8;
var text_FT_T2T4;
var key_FT_T2T4;
var phases_FT_T2T4;
var FinalTestT2T5Clock;
var image_ththano11;
var image_thano11;
var text_FT_T2T5_1;
var text_FT_T2T5_0;
var sound_thano9;
var text_FT_T2T5;
var key_FT_T2T5;
var phases_FT_T2T5;
var FinalTestT2T6Clock;
var image_thuri11;
var image_ththuri11;
var text_FT_T2T6_1;
var text_FT_T2T6_0;
var sound_ththuri8;
var text_FT_T2T6;
var key_FT_T2T6;
var phases_FT_T2T6;
var FinalTestT2T7Clock;
var image_ththano12;
var image_thano12;
var text_FT_T2T7_1;
var text_FT_T2T7_0;
var sound_ththano9;
var text_FT_T2T7;
var key_FT_T2T7;
var phases_FT_T2T7;
var FinalTestT2T8Clock;
var image_ththami12;
var image_thami12;
var text_FT_T2T8_1;
var text_FT_T2T8_0;
var sound_thami9;
var text_FT_T2T8;
var key_FT_T2T8;
var phases_FT_T2T8;
var FinalTestT2T9Clock;
var image_thuri12;
var image_ththuri12;
var text_FT_T2T9_1;
var text_FT_T2T9_0;
var sound_thuri9;
var text_FT_T2T9;
var key_FT_T2T9;
var phases_FT_T2T9;
var FinalTestT2T10Clock;
var image_thami13;
var image_ththami13;
var text_FT_T2T10_1;
var text_FT_T2T10_0;
var sound_ththami9;
var text_FT_T2T10;
var key_FT_T2T10;
var phases_FT_T2T10;
var FinalTestT2T11Clock;
var image_thano13;
var image_ththano13;
var text_FT_T2T11_1;
var text_FT_T2T11_0;
var sound_ththano10;
var text_FT_T2T11;
var key_FT_T2T11;
var phases_FT_T2T11;
var FinalTestT2T12Clock;
var image_ththuri13;
var image_thuri13;
var text_FT_T2T12_1;
var text_FT_T2T12_0;
var sound_ththuri9;
var text_FT_T2T12;
var key_FT_T2T12;
var phases_FT_T2T12;
var EndPhase4Clock;
var text_EndFT;
var key_FTEng;
var phases_endFT;
var Phase5Instructions1Clock;
var text_SRpos_tinstructions1;
var key_SRpos_instructions;
var Phase5T1T1Clock;
var sound_thth9;
var sound_th6;
var key_Ph5T1T1;
var text_Ph5T1T1;
var phases_Ph5T1T1;
var Phase5T1T2Clock;
var sound_thth10;
var sound_thth11;
var key_Ph5T1T2;
var text_Ph5T1T2;
var phases_Ph5T1T2;
var Phase5T1T3Clock;
var sound_thth12;
var sound_sh9;
var key_Ph5T1T3;
var text_Ph5T1T3;
var phases_Ph5T1T3;
var Phase5T1T4Clock;
var sound_thth13;
var sound_thth14;
var key_Ph5T1T4;
var text_Ph5T1T4;
var phases_Ph5T1T4;
var Phase5T1T5Clock;
var sound_th10;
var sound_thth15;
var key_Ph5T1T5;
var text_Ph5T1T5;
var phases_Ph5T1T5;
var Phase5T1T6Clock;
var sound_th11;
var sound_th12;
var key_Ph5T1T6;
var text_Ph5T1T6;
var phases_Ph5T1T6;
var Phase5T1T7Clock;
var sound_th13;
var sound_sh10;
var key_Ph5T1T7;
var text_Ph5T1T7;
var phases_Ph5T1T7;
var Phase5T1T8Clock;
var sound_th14;
var sound_th15;
var key_Ph5T1T8;
var text_Ph5T1T8;
var phases_Ph5T1T8;
var Phase5T1T9Clock;
var sound_sh11;
var sound_thth16;
var key_Ph5T1T9;
var text_Ph5T1T9;
var phases_Ph5T1T9;
var Phase5T1T10Clock;
var sound_sh12;
var sound_th16;
var key_Ph5T1T10;
var text_Ph5T1T10;
var phases_Ph5T1T10;
var Phase5T1T11Clock;
var sound_sh13;
var sound_sh14;
var key_Ph5T1T11;
var text_Ph5T1T11;
var phases_Ph5T1T11;
var Phase5T1T12Clock;
var sound_sh15;
var sound_sh16;
var key_Ph5T1T12;
var text_Ph5T1T12;
var phases_Ph5T1T12;
var Phase5T2T1Clock;
var sound_thrwa_thrwa2;
var key_Ph5T2T1;
var text_2;
var phases_Ph5T2T1;
var Phase5T2T2Clock;
var sound_ththm_thm2;
var key_Ph5T2T2;
var text_Ph5T2T2;
var phases_Ph5T2T2;
var Phase5T2T3Clock;
var sound_ththab_shab2;
var key_Ph5T2T3;
var text_Ph5T2T3;
var phases_Ph5T2T3;
var Phase5T2T4Clock;
var sound_ththna_ththna2;
var key_Ph5T2T4;
var text_Ph5T2T4;
var phases_Ph5T2T4;
var Phase5T2T5Clock;
var sound_thra_ththra2;
var key_Ph5T2T5;
var text_Ph5T2T5;
var phases_Ph5T2T5;
var Phase5T2T6Clock;
var sound_thb7_shb72;
var key_Ph5T2T6;
var text_Ph5T2T6;
var phases_Ph5T2T6;
var Phase5T2T7Clock;
var sound_thwq_thwq2;
var key_Ph5T2T7;
var text_Ph5T2T7;
var phases_Ph5T2T7;
var Phase5T2T8Clock;
var sound_thail_thail2;
var key_Ph5T2T8;
var text_Ph5T2T8;
var phases_Ph5T2T8;
var Phase5T2T9Clock;
var sound_shrf_thrf2;
var key_Ph5T2T9;
var text_Ph5T2T9;
var phases_Ph5T2T9;
var Phase5T2T10Clock;
var sound_sh7m_sh7m2;
var key_Ph5T2T10;
var text_Ph5T2T10;
var phases_Ph5T2T10;
var Phase5T2T11Clock;
var sound_shra_ththra2;
var key_Ph5T2T11;
var text_Ph5T2T11;
var phases_Ph5T2T11;
var Phase5T2T12Clock;
var sound_shfa_shfa2;
var key_Ph5T2T12;
var text_Ph5T2T12;
var phases_Ph5T2T12;
var EndExperimentClock;
var text_EndExperiment;
var key_EndExperiment;
var phases_end;
var globalClock;
var routineTimer;
function experimentInit() {
  // Initialize components for Routine "WelcomeScreen"
  WelcomeScreenClock = new util.Clock();
  textWelcome = new visual.TextStim({
    win: psychoJS.window,
    name: 'textWelcome',
    text: 'Welcome to our experiment\n\nPlease go through the instructions within each phase\n\nPress "Space" to continue',
    font: 'Times New Romans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_welcome = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "GeneralInstruction"
  GeneralInstructionClock = new util.Clock();
  text_gen_inst = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_gen_inst',
    text: 'In this experiment you will have three sessions\n\nThis session includes five phases\n\nPress "Space" to continue',
    font: 'Times New Romans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_Gen_inst = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Phase1instructions"
  Phase1instructionsClock = new util.Clock();
  Phase1_inst = new visual.TextStim({
    win: psychoJS.window,
    name: 'Phase1_inst',
    text: 'Phase 1: Sound Recognition phase (pre)\nYou will have 2 tasks\n\nIn task 1: You will hear 2 sounds. Your task is to decide whether these sounds are same or different\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task',
    font: 'Times New Romans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_Phase1_inst = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "SoundRecognitionT1T1"
  SoundRecognitionT1T1Clock = new util.Clock();
  sound_thth = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth.setVolume(1);
  sound_th = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th.setVolume(1);
  key_SRT1T1 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T1',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T1',
    text: 'Phase 1:   0%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T2"
  SoundRecognitionT1T2Clock = new util.Clock();
  sound_thth2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth2.setVolume(1);
  sound_thth3 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth3.setVolume(1);
  key_SRT1T2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T2',
    text: 'Do they sound the same? \n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T2',
    text: 'Phase 1:   4%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T3"
  SoundRecognitionT1T3Clock = new util.Clock();
  sound_thth4 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth4.setVolume(1);
  sound_sh = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh.setVolume(1);
  key_SRT1T3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T3',
    text: 'Do they sound the same? \n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T3',
    text: 'Phase 1:   8%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T4"
  SoundRecognitionT1T4Clock = new util.Clock();
  sound_thth5 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth5.setVolume(1);
  sound_thth6 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth6.setVolume(1);
  key_SRT1T4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T4',
    text: 'Do they sound the same? \n\n1= Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T4',
    text: 'Phase 1:  12%   Phase 2:   0%   Phase 3:   0%   Phase 4:  0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T5"
  SoundRecognitionT1T5Clock = new util.Clock();
  sound_th2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th2.setVolume(1);
  sound_thth7 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth7.setVolume(1);
  key_SRT1T5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T5',
    text: 'Do they sound the same? \n\n1= Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T5',
    text: 'Phase 1:  16%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T6"
  SoundRecognitionT1T6Clock = new util.Clock();
  sound_th4 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th4.setVolume(1);
  sound_th3 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th3.setVolume(1);
  key_SRT1T6 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T6',
    text: 'Do they sound the same? \n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T6',
    text: 'Phase 1:  20%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T7"
  SoundRecognitionT1T7Clock = new util.Clock();
  sound_th5 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th5.setVolume(1);
  sound_sh8 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh8.setVolume(1);
  key_SRT1T7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T7',
    text: 'Do they sound the same? \n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T7',
    text: 'Phase 1:  25%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T8"
  SoundRecognitionT1T8Clock = new util.Clock();
  sound_th7 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th7.setVolume(1);
  sound_th8 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th8.setVolume(1);
  key_SRT1T8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T8',
    text: 'Do they sound the same? \n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T8',
    text: 'Phase 1:  29%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T9"
  SoundRecognitionT1T9Clock = new util.Clock();
  sound_sh2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh2.setVolume(1);
  sound_thth8 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth8.setVolume(1);
  key_SRT1T9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T9',
    text: 'Do they sound the same? \n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T9',
    text: 'Phase 1:  33%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T10"
  SoundRecognitionT1T10Clock = new util.Clock();
  sound_sh3 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh3.setVolume(1);
  sound_th9 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th9.setVolume(1);
  key_SRT1T10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T10',
    text: 'Do they sound the same? \n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T10',
    text: 'Phase 1:  37%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T11"
  SoundRecognitionT1T11Clock = new util.Clock();
  sound_sh4 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh4.setVolume(1);
  sound_sh5 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh5.setVolume(1);
  key_SRT1T11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T11',
    text: 'Do they sound the same? \n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T11',
    text: 'Phase 1:  41%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT1T12"
  SoundRecognitionT1T12Clock = new util.Clock();
  sound_sh6 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh6.setVolume(1);
  sound_sh7 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh7.setVolume(1);
  key_SRT1T12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT1T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT1T12',
    text: 'Do they sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_SRT1T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT1T12',
    text: 'Phase 1:  45%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase1instructions2"
  Phase1instructions2Clock = new util.Clock();
  text_phase1_inst2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_phase1_inst2',
    text: '\nIn task 2: You will hear 2 Arabic words that may sound the same or may differ only in the initial sound (minimal pairs). Your task is to decide whether the two words are the same or differ only in the initial sounds. \n\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task',
    font: 'Times New Romans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_phase1_inst2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "SoundRecognitionT2T1"
  SoundRecognitionT2T1Clock = new util.Clock();
  sound_thrwa_thrwa = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thrwa-thrwa.wav',
    secs: (- 1),
    });
  sound_thrwa_thrwa.setVolume(1);
  key_SRT2T1 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T1',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T1',
    text: 'Phase 1:  50%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T2"
  SoundRecognitionT2T2Clock = new util.Clock();
  sound_ththm_thm = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththm-thm.wav',
    secs: (- 1),
    });
  sound_ththm_thm.setVolume(1);
  key_SRT2T2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T2',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T2',
    text: 'Phase 1:  54%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T3"
  SoundRecognitionT2T3Clock = new util.Clock();
  sound_ththab_shab = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththab-shab.wav',
    secs: (- 1),
    });
  sound_ththab_shab.setVolume(1);
  key_SRT2T3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T3',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T3',
    text: 'Phase 1:  58%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T4"
  SoundRecognitionT2T4Clock = new util.Clock();
  sound_ththna_ththna = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththna-ththna.wav',
    secs: (- 1),
    });
  sound_ththna_ththna.setVolume(1);
  key_SRT2T4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T4',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T4',
    text: 'Phase 1:  62%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T5"
  SoundRecognitionT2T5Clock = new util.Clock();
  sound_thra_ththra = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thra-ththra.wav',
    secs: (- 1),
    });
  sound_thra_ththra.setVolume(1);
  key_SRT2T5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T5',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T5',
    text: 'Phase 1:  66%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T6"
  SoundRecognitionT2T6Clock = new util.Clock();
  sound_thb7_shb7 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thb7-shb7.wav',
    secs: (- 1),
    });
  sound_thb7_shb7.setVolume(1);
  key_SRT2T6 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T6',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T6',
    text: 'Phase 1:  70%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T7"
  SoundRecognitionT2T7Clock = new util.Clock();
  sound_thwq_thwq = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thwq-thwq.wav',
    secs: (- 1),
    });
  sound_thwq_thwq.setVolume(1);
  key_SRT2T7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T7',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T7',
    text: 'Phase 1:  75%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T8"
  SoundRecognitionT2T8Clock = new util.Clock();
  sound_thail_thail = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thail-thail.wav',
    secs: (- 1),
    });
  sound_thail_thail.setVolume(1);
  key_SRT2T8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T8',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T8',
    text: 'Phase 1:  79%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T9"
  SoundRecognitionT2T9Clock = new util.Clock();
  sound_shrf_thrf = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/shrf-thrf.wav',
    secs: (- 1),
    });
  sound_shrf_thrf.setVolume(1);
  key_SRT2T9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T9',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T9',
    text: 'Phase 1:  83%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T10"
  SoundRecognitionT2T10Clock = new util.Clock();
  sound_sh7m_sh7m = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh7m-sh7m.wav',
    secs: (- 1),
    });
  sound_sh7m_sh7m.setVolume(1);
  key_SRT2T10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T10',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T10',
    text: 'Phase 1:  87%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T11"
  SoundRecognitionT2T11Clock = new util.Clock();
  sound_shra_ththra = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/shra-ththra.wav',
    secs: (- 1),
    });
  sound_shra_ththra.setVolume(1);
  key_SRT2T11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T11',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T11',
    text: 'Phase 1:  91%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "SoundRecognitionT2T12"
  SoundRecognitionT2T12Clock = new util.Clock();
  sound_shfa_shfa = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/shfa-shfa.wav',
    secs: (- 1),
    });
  sound_shfa_shfa.setVolume(1);
  key_SRT2T12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_SRT2T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRT2T12',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_SRT2T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_SRT2T12',
    text: 'Phase 1:  95%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "EndSoundRecognition"
  EndSoundRecognitionClock = new util.Clock();
  text_EndSR = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_EndSR',
    text: "This is the end of the first phase. \n\nPlease press 'Space' to move to the second phase whenever you are ready",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_EndSR = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_endSR = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_endSR',
    text: 'Phase 1: 100%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -2.0 
  });
  
  // Initialize components for Routine "Phase2instructions"
  Phase2instructionsClock = new util.Clock();
  text = new visual.TextStim({
    win: psychoJS.window,
    name: 'text',
    text: 'Phase 2: Word learning phase\n\nYou will learn new Arabic non-words. You will hear how they are pronounced and see the corresponding pictures with their Arabic written forms. \n\nArabic language is written from the right to the left\n\nThese non-words will be repeated many times. \n\nYou are not required to do anything in this phase, just learn\n\nPress "Space" to continue.\n',
    font: 'Times New Roman',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_WLinst = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "WordLearningT1"
  WordLearningT1Clock = new util.Clock();
  sound_ththami = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththami.wav',
    secs: (- 1),
    });
  sound_ththami.setVolume(1);
  image_ththami = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami', units : undefined, 
    image : 'Images/ththami.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), 0], size : [0.5, 0.5],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  sound_thami = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thami.wav',
    secs: (- 1),
    });
  sound_thami.setVolume(1);
  image_thami = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami', units : undefined, 
    image : 'Images/thami.jpg', mask : undefined,
    ori : 0, pos : [0.5, 0], size : [0.5, 0.5],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -3.0 
  });
  // Initialize components for Routine "WordLearningT2"
  WordLearningT2Clock = new util.Clock();
  sound_ththuri = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththuri.wav',
    secs: (- 1),
    });
  sound_ththuri.setVolume(1);
  image_ththuri = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri', units : undefined, 
    image : 'Images/ththuri.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), 0], size : [0.5, 0.5],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  sound_thuri = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thuri.wav',
    secs: (- 1),
    });
  sound_thuri.setVolume(1);
  image_thuri = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri', units : undefined, 
    image : 'Images/thuri.jpg', mask : undefined,
    ori : 0, pos : [0.5, 0], size : [0.5, 0.5],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -3.0 
  });
  // Initialize components for Routine "WordLearningT3"
  WordLearningT3Clock = new util.Clock();
  sound_ththano = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththano.wav',
    secs: (- 1),
    });
  sound_ththano.setVolume(1);
  image_ththano = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano', units : undefined, 
    image : 'Images/ththano.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), 0], size : [0.5, 0.5],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  sound_thano = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thano.wav',
    secs: (- 1),
    });
  sound_thano.setVolume(1);
  image_thano = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano', units : undefined, 
    image : 'Images/thano.jpg', mask : undefined,
    ori : 0, pos : [0.5, 0], size : [0.5, 0.5],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -3.0 
  });
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "EndWordLearning"
  EndWordLearningClock = new util.Clock();
  text_EndWL = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_EndWL',
    text: "This is the end of the second phase. \n\nPlease press 'Space' to move to the third phase whenever you are ready",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_EndWL = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_endWL = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_endWL',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -2.0 
  });
  
  // Initialize components for Routine "Phase3Instructions1"
  Phase3Instructions1Clock = new util.Clock();
  text_CTInstructionsT1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CTInstructionsT1',
    text: 'Phase 3: Criterion test phase\n\nYou will have two tasks. \n\nIn Task 1: You will hear a word and see a picture, your task is to decide whether this picture represents the word you just heard. \n\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_CTinstructionsT1 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "CriterionTestT1T1"
  CriterionTestT1T1Clock = new util.Clock();
  sound_thuri2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thuri.wav',
    secs: (- 1),
    });
  sound_thuri2.setVolume(1);
  image_thuri2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri2', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  Text_CT_T1T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'Text_CT_T1T1',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T1 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T1',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CriterionTestT1T2"
  CriterionTestT1T2Clock = new util.Clock();
  sound_thano2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thano.wav',
    secs: (- 1),
    });
  sound_thano2.setVolume(1);
  image_ththami2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami2', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T2',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T2',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:   4%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CriterionTestT1T3"
  CriterionTestT1T3Clock = new util.Clock();
  sound_ththuri3 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththuri.wav',
    secs: (- 1),
    });
  sound_ththuri3.setVolume(1);
  image_ththuri3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri3', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T3',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T3',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:   8%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CriterionTestT1T4"
  CriterionTestT1T4Clock = new util.Clock();
  sound_thami3 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thami.wav',
    secs: (- 1),
    });
  sound_thami3.setVolume(1);
  image_thami3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami3', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T4',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T4',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  12%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CriteterionTestT1T5"
  CriteterionTestT1T5Clock = new util.Clock();
  sound_ththano2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththano.wav',
    secs: (- 1),
    });
  sound_ththano2.setVolume(1);
  image_thuri3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri3', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T5',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T5',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  16%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CriterionTestT1T6"
  CriterionTestT1T6Clock = new util.Clock();
  sound_ththami3 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththami.wav',
    secs: (- 1),
    });
  sound_ththami3.setVolume(1);
  image_ththami3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami3', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T6',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T6 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T6',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  20%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CritertionTestT1T7"
  CritertionTestT1T7Clock = new util.Clock();
  sound_thuri3 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thuri.wav',
    secs: (- 1),
    });
  sound_thuri3.setVolume(1);
  image_ththano2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano2', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T7',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T7',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  25%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CriterionTestT1T8"
  CriterionTestT1T8Clock = new util.Clock();
  sound_ththuri2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththuri.wav',
    secs: (- 1),
    });
  sound_ththuri2.setVolume(1);
  image_thami2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami2', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T8',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T8',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  29%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CriterionTestT1T9"
  CriterionTestT1T9Clock = new util.Clock();
  sound_thano3 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thano.wav',
    secs: (- 1),
    });
  sound_thano3.setVolume(1);
  image_thano3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano3', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T9',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T9',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  33%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CritertionTestT1T10"
  CritertionTestT1T10Clock = new util.Clock();
  sound_ththami2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththami.wav',
    secs: (- 1),
    });
  sound_ththami2.setVolume(1);
  image_thano2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano2', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T10',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T10',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  37%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CriterionTestT1T11"
  CriterionTestT1T11Clock = new util.Clock();
  sound_ththano3 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththano.wav',
    secs: (- 1),
    });
  sound_ththano3.setVolume(1);
  image_ththano3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano3', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T11',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T11',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  41%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "CriterionTestT1T12"
  CriterionTestT1T12Clock = new util.Clock();
  sound_thami2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thami.wav',
    secs: (- 1),
    });
  sound_thami2.setVolume(1);
  image_ththuri2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri2', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T1T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T1T12',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_CT_T1T12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T1T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T1T12',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  45%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Phase3instructions2_2"
  Phase3instructions2_2Clock = new util.Clock();
  text_CTinstructions2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CTinstructions2',
    text: "In task 2: you will have two pictures and you will hear a word.\n\nYour task is to choose the correct picture that represents the word. \n\nChoose either '1' or '0' \n\nReady? Press 'Space' to start the task. ",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_CTinstructions2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "CriterionTestT2T1"
  CriterionTestT2T1Clock = new util.Clock();
  image_ththuri4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri4', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thano4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano4', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T1_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T1_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T1_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T1_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththuri4 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththuri.wav',
    secs: (- 1),
    });
  sound_ththuri4.setVolume(1);
  text_CT_T2T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T1',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T1 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T1',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  50%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT2T2"
  CriterionTestT2T2Clock = new util.Clock();
  image_thuri4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri4', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_ththami4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami4', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T2_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T2_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T2_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T2_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththami4 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththami.wav',
    secs: (- 1),
    });
  sound_ththami4.setVolume(1);
  text_CT_T2T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T2',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  CT_T2T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'CT_T2T2',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  54%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT2T3"
  CriterionTestT2T3Clock = new util.Clock();
  image_ththano4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano4', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thami4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami4', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T3_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T3_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T3_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T3_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththano4 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththano.wav',
    secs: (- 1),
    });
  sound_ththano4.setVolume(1);
  text_CT_T2T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T3',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T3',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  58%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT3T4"
  CriterionTestT3T4Clock = new util.Clock();
  image_ththami5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami5', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thano5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano5', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T4_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T4_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T4_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T4_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththami5 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththami.wav',
    secs: (- 1),
    });
  sound_ththami5.setVolume(1);
  text_CT_T2T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T4',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T4',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  62%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT2T5"
  CriterionTestT2T5Clock = new util.Clock();
  image_thami5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami5', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_ththuri5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri5', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T5_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T5_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T5_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T5_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththuri5 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththuri.wav',
    secs: (- 1),
    });
  sound_ththuri5.setVolume(1);
  text_CT_T2T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T5',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T5',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  66%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT2T6"
  CriterionTestT2T6Clock = new util.Clock();
  image_ththano5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano5', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thuri5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri5', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T6_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T6_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T6_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T6_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththano5 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththano.wav',
    secs: (- 1),
    });
  sound_ththano5.setVolume(1);
  text_CT_T2T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T6',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T6 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T6',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  70%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT2T7"
  CriterionTestT2T7Clock = new util.Clock();
  image_ththami6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami6', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thuri6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri6', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T7_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T7_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T7_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T7_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thuri5 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thuri.wav',
    secs: (- 1),
    });
  sound_thuri5.setVolume(1);
  text_CT_T2T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T7',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T7',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  75%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT2T8"
  CriterionTestT2T8Clock = new util.Clock();
  image_ththano6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano6', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thami6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami6', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T8_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T8_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T8_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T8_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thami4 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thami.wav',
    secs: (- 1),
    });
  sound_thami4.setVolume(1);
  text_CT_T2T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T8',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T8',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  79%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT2T9"
  CriterionTestT2T9Clock = new util.Clock();
  image_ththuri6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri6', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thano6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano6', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T9_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T9_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T9_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T9_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thano4 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thano.wav',
    secs: (- 1),
    });
  sound_thano4.setVolume(1);
  text_CT_T2T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T9',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T9',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  83%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT2T10"
  CriterionTestT2T10Clock = new util.Clock();
  image_thuri7 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri7', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_ththano7 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano7', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T10_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T10_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T10_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T10_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thuri4 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thuri.wav',
    secs: (- 1),
    });
  sound_thuri4.setVolume(1);
  text_CT_T2T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T10',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T10',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  87%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT2T11"
  CriterionTestT2T11Clock = new util.Clock();
  image_ththami7 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami7', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thano7 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano7', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T11_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T11_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T11_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T11_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thano5 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thano.wav',
    secs: (- 1),
    });
  sound_thano5.setVolume(1);
  text_CT_T2T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T11',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T11',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  91%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "CriterionTestT2T12"
  CriterionTestT2T12Clock = new util.Clock();
  image_thami7 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami7', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_ththuri7 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri7', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_CT_T2T12_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T12_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_CT_T2T12_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T12_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thami5 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thami.wav',
    secs: (- 1),
    });
  sound_thami5.setVolume(1);
  text_CT_T2T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_CT_T2T12',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_CT_T2T12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_CT_T2T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_CT_T2T12',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3:  95%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "EndCriterionTest"
  EndCriterionTestClock = new util.Clock();
  text_EndCT = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_EndCT',
    text: "This is the end of the third phase. \n\nPlease press 'Space' to move to the fourth phase whenever you are ready",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_EndCT = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_endCT = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_endCT',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -2.0 
  });
  
  // Initialize components for Routine "Phase4Instructions1"
  Phase4Instructions1Clock = new util.Clock();
  text_FTinstructions1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FTinstructions1',
    text: 'Phase 4: Final test phase\n\nYou will have two tasks very similar to those in Phase 3. \n\nIn Task 1: You will hear a word and see a picture, your task is to decide whether this picture represents the word you just heard. \n\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_FTinstructions1 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "FinalTestT1T1"
  FinalTestT1T1Clock = new util.Clock();
  sound_ththuri6 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththuri.wav',
    secs: (- 1),
    });
  sound_ththuri6.setVolume(1);
  image_thuri8 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri8', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T1',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T1 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T1',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:   0%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T2"
  FinalTestT1T2Clock = new util.Clock();
  sound_thami6 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thami.wav',
    secs: (- 1),
    });
  sound_thami6.setVolume(1);
  image_ththami8 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami8', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T2',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T2',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:   4%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T3"
  FinalTestT1T3Clock = new util.Clock();
  sound_thuri6 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thuri.wav',
    secs: (- 1),
    });
  sound_thuri6.setVolume(1);
  image_thuri9 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri9', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T3',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T3',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:   8%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T4"
  FinalTestT1T4Clock = new util.Clock();
  sound_ththami6 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththami.wav',
    secs: (- 1),
    });
  sound_ththami6.setVolume(1);
  image_thami8 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami8', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T4',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T4',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  12%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T5"
  FinalTestT1T5Clock = new util.Clock();
  sound_thano6 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thano.wav',
    secs: (- 1),
    });
  sound_thano6.setVolume(1);
  image_thano8 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano8', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T5',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T5',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  16%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T6"
  FinalTestT1T6Clock = new util.Clock();
  sound_ththami7 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththami.wav',
    secs: (- 1),
    });
  sound_ththami7.setVolume(1);
  image_ththami9 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami9', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T6',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T6 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T6',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  20%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T7"
  FinalTestT1T7Clock = new util.Clock();
  sound_thami7 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thami.wav',
    secs: (- 1),
    });
  sound_thami7.setVolume(1);
  image_thami9 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami9', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T7',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T7',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  25%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T8"
  FinalTestT1T8Clock = new util.Clock();
  sound_ththano6 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththano.wav',
    secs: (- 1),
    });
  sound_ththano6.setVolume(1);
  image_thano9 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano9', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T8',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T8',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  29%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T9"
  FinalTestT1T9Clock = new util.Clock();
  sound_ththuri7 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththuri.wav',
    secs: (- 1),
    });
  sound_ththuri7.setVolume(1);
  image_ththuri8 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri8', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T9',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T9',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  33%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T10"
  FinalTestT1T10Clock = new util.Clock();
  sound_thano7 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thano.wav',
    secs: (- 1),
    });
  sound_thano7.setVolume(1);
  image_ththano8 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano8', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T10',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T10',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  37%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T11"
  FinalTestT1T11Clock = new util.Clock();
  sound_thuri7 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thuri.wav',
    secs: (- 1),
    });
  sound_thuri7.setVolume(1);
  image_ththuri9 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri9', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T11',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T11',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  41%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "FinalTestT1T12"
  FinalTestT1T12Clock = new util.Clock();
  sound_ththano7 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththano.wav',
    secs: (- 1),
    });
  sound_ththano7.setVolume(1);
  image_ththano9 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano9', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T1T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T1T12',
    text: 'Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.07,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_FT_T1T12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T1T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T1T12',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  45%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Phase4Instructions2"
  Phase4Instructions2Clock = new util.Clock();
  text_FTinstructiosn2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FTinstructiosn2',
    text: "In task 2: you will have two pictures and you will hear a word.\n\nYour task is to choose the correct picture that represents the word. \n\nChoose either '1' or '0' \n\nReady? Press 'Space' to start the task. ",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_FTinstructions2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "FinalTestT2T1"
  FinalTestT2T1Clock = new util.Clock();
  image_ththami10 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami10', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thami10 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami10', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T1_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T1_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T1_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T1_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththami8 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththami.wav',
    secs: (- 1),
    });
  sound_ththami8.setVolume(1);
  text_FT_T2T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T1',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T1 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T1',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  50%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T2"
  FinalTestT2T2Clock = new util.Clock();
  image_thano10 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano10', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_ththano10 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano10', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T2_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T2_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T2_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T2_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thano8 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thano.wav',
    secs: (- 1),
    });
  sound_thano8.setVolume(1);
  text_FT_T2T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T2',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T2',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  54%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T3"
  FinalTestT2T3Clock = new util.Clock();
  image_ththuri10 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri10', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thuri10 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri10', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T3_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T3_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T3_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T3_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thuri8 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thuri.wav',
    secs: (- 1),
    });
  sound_thuri8.setVolume(1);
  text_FT_T2T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T3',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T3',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  58%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T4"
  FinalTestT2T4Clock = new util.Clock();
  image_thami11 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami11', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_ththami11 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami11', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T4_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T4_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T4_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T4_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thami8 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thami.wav',
    secs: (- 1),
    });
  sound_thami8.setVolume(1);
  text_FT_T2T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T4',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T4',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  62%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T5"
  FinalTestT2T5Clock = new util.Clock();
  image_ththano11 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano11', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thano11 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano11', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T5_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T5_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T5_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T5_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thano9 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thano.wav',
    secs: (- 1),
    });
  sound_thano9.setVolume(0);
  text_FT_T2T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T5',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T5',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  66%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T6"
  FinalTestT2T6Clock = new util.Clock();
  image_thuri11 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri11', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_ththuri11 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri11', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T6_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T6_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T6_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T6_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththuri8 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththuri.wav',
    secs: (- 1),
    });
  sound_ththuri8.setVolume(0);
  text_FT_T2T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T6',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T6 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T6',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  70%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T7"
  FinalTestT2T7Clock = new util.Clock();
  image_ththano12 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano12', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thano12 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano12', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T7_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T7_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T7_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T7_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththano9 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththano.wav',
    secs: (- 1),
    });
  sound_ththano9.setVolume(1);
  text_FT_T2T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T7',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T7',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  75%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T8"
  FinalTestT2T8Clock = new util.Clock();
  image_ththami12 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami12', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thami12 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami12', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T8_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T8_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T8_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T8_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thami9 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thami.wav',
    secs: (- 1),
    });
  sound_thami9.setVolume(1);
  text_FT_T2T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T8',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T8',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  79%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T9"
  FinalTestT2T9Clock = new util.Clock();
  image_thuri12 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri12', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_ththuri12 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri12', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T9_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T9_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T9_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T9_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_thuri9 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thuri.wav',
    secs: (- 1),
    });
  sound_thuri9.setVolume(1);
  text_FT_T2T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T9',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T9',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  83%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T10"
  FinalTestT2T10Clock = new util.Clock();
  image_thami13 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thami13', units : undefined, 
    image : 'Images/thami2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_ththami13 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththami13', units : undefined, 
    image : 'Images/ththami2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T10_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T10_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T10_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T10_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththami9 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththami.wav',
    secs: (- 1),
    });
  sound_ththami9.setVolume(1);
  text_FT_T2T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T10',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T10',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  87%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T11"
  FinalTestT2T11Clock = new util.Clock();
  image_thano13 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thano13', units : undefined, 
    image : 'Images/thano2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_ththano13 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththano13', units : undefined, 
    image : 'Images/ththano2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T11_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T11_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T11_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T11_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththano10 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththano.wav',
    secs: (- 1),
    });
  sound_ththano10.setVolume(1);
  text_FT_T2T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T11',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T11',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  91%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "FinalTestT2T12"
  FinalTestT2T12Clock = new util.Clock();
  image_ththuri13 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_ththuri13', units : undefined, 
    image : 'Images/ththuri2.jpg', mask : undefined,
    ori : 0, pos : [(- 0.5), (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : 0.0 
  });
  image_thuri13 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_thuri13', units : undefined, 
    image : 'Images/thuri2.jpg', mask : undefined,
    ori : 0, pos : [0.5, (- 0.15)], size : [0.45, 0.45],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  text_FT_T2T12_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T12_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.5), 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  text_FT_T2T12_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T12_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [0.5, 0.2], height: 0.15,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  sound_ththuri9 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththuri.wav',
    secs: (- 1),
    });
  sound_ththuri9.setVolume(1);
  text_FT_T2T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_FT_T2T12',
    text: 'Choose 1 or 0',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  key_FT_T2T12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_FT_T2T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_FT_T2T12',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  95%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -7.0 
  });
  
  // Initialize components for Routine "EndPhase4"
  EndPhase4Clock = new util.Clock();
  text_EndFT = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_EndFT',
    text: "This is the end of the fourth phase. \n\nPlease press 'Space' to move to the final phase whenever you are ready",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_FTEng = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_endFT = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_endFT',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -2.0 
  });
  
  // Initialize components for Routine "Phase5Instructions1"
  Phase5Instructions1Clock = new util.Clock();
  text_SRpos_tinstructions1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_SRpos_tinstructions1',
    text: 'Phase 5: Sound Recognition phase (post)\nThis phase is identical to the first phase\n\nYou will have 2 tasks\n\nIn task 1: You will hear 2 sounds. Your task is to decide whether these sounds are same or different\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_SRpos_instructions = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Phase5T1T1"
  Phase5T1T1Clock = new util.Clock();
  sound_thth9 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth9.setVolume(1);
  sound_th6 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th6.setVolume(1);
  key_Ph5T1T1 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T1',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T1',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:   0%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T2"
  Phase5T1T2Clock = new util.Clock();
  sound_thth10 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth10.setVolume(1);
  sound_thth11 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth11.setVolume(1);
  key_Ph5T1T2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T2',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T2',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:   4%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T3"
  Phase5T1T3Clock = new util.Clock();
  sound_thth12 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth12.setVolume(1);
  sound_sh9 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh9.setVolume(1);
  key_Ph5T1T3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T3',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T3',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:   8%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T4"
  Phase5T1T4Clock = new util.Clock();
  sound_thth13 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth13.setVolume(1);
  sound_thth14 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth14.setVolume(1);
  key_Ph5T1T4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T4',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T4',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  12%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T5"
  Phase5T1T5Clock = new util.Clock();
  sound_th10 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th10.setVolume(1);
  sound_thth15 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth15.setVolume(1);
  key_Ph5T1T5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T5',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T5',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  16%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T6"
  Phase5T1T6Clock = new util.Clock();
  sound_th11 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th11.setVolume(1);
  sound_th12 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th12.setVolume(1);
  key_Ph5T1T6 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T6',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T6',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  20%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T7"
  Phase5T1T7Clock = new util.Clock();
  sound_th13 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th13.setVolume(1);
  sound_sh10 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh10.setVolume(1);
  key_Ph5T1T7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T7',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T7',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  25%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T8"
  Phase5T1T8Clock = new util.Clock();
  sound_th14 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th14.setVolume(1);
  sound_th15 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th15.setVolume(1);
  key_Ph5T1T8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T8',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T8',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  29%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T9"
  Phase5T1T9Clock = new util.Clock();
  sound_sh11 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh11.setVolume(1);
  sound_thth16 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thth.wav',
    secs: (- 1),
    });
  sound_thth16.setVolume(1);
  key_Ph5T1T9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T9',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T9',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  33%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T10"
  Phase5T1T10Clock = new util.Clock();
  sound_sh12 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh12.setVolume(1);
  sound_th16 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/th.wav',
    secs: (- 1),
    });
  sound_th16.setVolume(1);
  key_Ph5T1T10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T10',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T10',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  37%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T11"
  Phase5T1T11Clock = new util.Clock();
  sound_sh13 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh13.setVolume(1);
  sound_sh14 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh14.setVolume(1);
  key_Ph5T1T11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T11',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T11',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  41%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T1T12"
  Phase5T1T12Clock = new util.Clock();
  sound_sh15 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh15.setVolume(1);
  sound_sh16 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh.wav',
    secs: (- 1),
    });
  sound_sh16.setVolume(1);
  key_Ph5T1T12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T1T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T1T12',
    text: 'Do they sound the same?\n\n1=Yes  0=No\n\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  phases_Ph5T1T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T1T12',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  45%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Phase1instructions2"
  Phase1instructions2Clock = new util.Clock();
  text_phase1_inst2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_phase1_inst2',
    text: '\nIn task 2: You will hear 2 Arabic words that may sound the same or may differ only in the initial sound (minimal pairs). Your task is to decide whether the two words are the same or differ only in the initial sounds. \n\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task',
    font: 'Times New Romans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_phase1_inst2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Phase5T2T1"
  Phase5T2T1Clock = new util.Clock();
  sound_thrwa_thrwa2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thrwa-thrwa.wav',
    secs: (- 1),
    });
  sound_thrwa_thrwa2.setVolume(1);
  key_Ph5T2T1 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_2',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T1',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  50%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T2"
  Phase5T2T2Clock = new util.Clock();
  sound_ththm_thm2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththm-thm.wav',
    secs: (- 1),
    });
  sound_ththm_thm2.setVolume(1);
  key_Ph5T2T2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T2',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T2',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  54%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T3"
  Phase5T2T3Clock = new util.Clock();
  sound_ththab_shab2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththab-shab.wav',
    secs: (- 1),
    });
  sound_ththab_shab2.setVolume(1);
  key_Ph5T2T3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T3',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T3',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  58%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T4"
  Phase5T2T4Clock = new util.Clock();
  sound_ththna_ththna2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/ththna-ththna.wav',
    secs: (- 1),
    });
  sound_ththna_ththna2.setVolume(1);
  key_Ph5T2T4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T4',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T4',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  62%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T5"
  Phase5T2T5Clock = new util.Clock();
  sound_thra_ththra2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thra-ththra.wav',
    secs: (- 1),
    });
  sound_thra_ththra2.setVolume(1);
  key_Ph5T2T5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T5',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T5',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  66%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T6"
  Phase5T2T6Clock = new util.Clock();
  sound_thb7_shb72 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thb7-shb7.wav',
    secs: (- 1),
    });
  sound_thb7_shb72.setVolume(1);
  key_Ph5T2T6 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T6',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T6',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  70%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T7"
  Phase5T2T7Clock = new util.Clock();
  sound_thwq_thwq2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thwq-thwq.wav',
    secs: (- 1),
    });
  sound_thwq_thwq2.setVolume(1);
  key_Ph5T2T7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T7',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T7',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  75%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T8"
  Phase5T2T8Clock = new util.Clock();
  sound_thail_thail2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/thail-thail.wav',
    secs: (- 1),
    });
  sound_thail_thail2.setVolume(1);
  key_Ph5T2T8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T8',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T8',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  79%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T9"
  Phase5T2T9Clock = new util.Clock();
  sound_shrf_thrf2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/shrf-thrf.wav',
    secs: (- 1),
    });
  sound_shrf_thrf2.setVolume(1);
  key_Ph5T2T9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T9',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T9',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  83%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T10"
  Phase5T2T10Clock = new util.Clock();
  sound_sh7m_sh7m2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/sh7m-sh7m.wav',
    secs: (- 1),
    });
  sound_sh7m_sh7m2.setVolume(1);
  key_Ph5T2T10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T10',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T10',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  87%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T11"
  Phase5T2T11Clock = new util.Clock();
  sound_shra_ththra2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/shra-ththra.wav',
    secs: (- 1),
    });
  sound_shra_ththra2.setVolume(1);
  key_Ph5T2T11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T11',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T11',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  91%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Blank"
  BlankClock = new util.Clock();
  text_blank = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_blank',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "Phase5T2T12"
  Phase5T2T12Clock = new util.Clock();
  sound_shfa_shfa2 = new sound.Sound({
    win: psychoJS.window,
    value: 'Sounds/shfa-shfa.wav',
    secs: (- 1),
    });
  sound_shfa_shfa2.setVolume(1);
  key_Ph5T2T12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_Ph5T2T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_Ph5T2T12',
    text: 'Do the two words initially sound the same?\n\n1=Yes   0=No',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  phases_Ph5T2T12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_Ph5T2T12',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  95%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "EndExperiment"
  EndExperimentClock = new util.Clock();
  text_EndExperiment = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_EndExperiment',
    text: 'This is the end of this session. \n\nThank you for your precious time\n\nPlease contact the researcher\n\nPress "Space" to exit',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_EndExperiment = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  phases_end = new visual.TextStim({
    win: psychoJS.window,
    name: 'phases_end',
    text: 'Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5: 100%',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.4)], height: 0.02,  wrapWidth: undefined, ori: 0,
    color: new util.Color('red'),  opacity: 1,
    depth: -2.0 
  });
  
  // Create some handy timers
  globalClock = new util.Clock();  // to track the time since experiment started
  routineTimer = new util.CountdownTimer();  // to track time remaining of each (non-slip) routine
  
  return Scheduler.Event.NEXT;
}


var t;
var frameN;
var _key_welcome_allKeys;
var WelcomeScreenComponents;
function WelcomeScreenRoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'WelcomeScreen'-------
    t = 0;
    WelcomeScreenClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_welcome.keys = undefined;
    key_welcome.rt = undefined;
    _key_welcome_allKeys = [];
    // keep track of which components have finished
    WelcomeScreenComponents = [];
    WelcomeScreenComponents.push(textWelcome);
    WelcomeScreenComponents.push(key_welcome);
    
    WelcomeScreenComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


var continueRoutine;
function WelcomeScreenRoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'WelcomeScreen'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = WelcomeScreenClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *textWelcome* updates
    if (t >= 0.0 && textWelcome.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      textWelcome.tStart = t;  // (not accounting for frame time here)
      textWelcome.frameNStart = frameN;  // exact frame index
      
      textWelcome.setAutoDraw(true);
    }

    
    // *key_welcome* updates
    if (t >= 0.0 && key_welcome.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_welcome.tStart = t;  // (not accounting for frame time here)
      key_welcome.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_welcome.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_welcome.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_welcome.clearEvents(); });
    }

    if (key_welcome.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_welcome.getKeys({keyList: ['space'], waitRelease: false});
      _key_welcome_allKeys = _key_welcome_allKeys.concat(theseKeys);
      if (_key_welcome_allKeys.length > 0) {
        key_welcome.keys = _key_welcome_allKeys[_key_welcome_allKeys.length - 1].name;  // just the last key pressed
        key_welcome.rt = _key_welcome_allKeys[_key_welcome_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    WelcomeScreenComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function WelcomeScreenRoutineEnd(trials) {
  return function () {
    //------Ending Routine 'WelcomeScreen'-------
    WelcomeScreenComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_welcome.keys', key_welcome.keys);
    if (typeof key_welcome.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_welcome.rt', key_welcome.rt);
        routineTimer.reset();
        }
    
    key_welcome.stop();
    // the Routine "WelcomeScreen" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_Gen_inst_allKeys;
var GeneralInstructionComponents;
function GeneralInstructionRoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'GeneralInstruction'-------
    t = 0;
    GeneralInstructionClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_Gen_inst.keys = undefined;
    key_Gen_inst.rt = undefined;
    _key_Gen_inst_allKeys = [];
    // keep track of which components have finished
    GeneralInstructionComponents = [];
    GeneralInstructionComponents.push(text_gen_inst);
    GeneralInstructionComponents.push(key_Gen_inst);
    
    GeneralInstructionComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function GeneralInstructionRoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'GeneralInstruction'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = GeneralInstructionClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_gen_inst* updates
    if (t >= 0.0 && text_gen_inst.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_gen_inst.tStart = t;  // (not accounting for frame time here)
      text_gen_inst.frameNStart = frameN;  // exact frame index
      
      text_gen_inst.setAutoDraw(true);
    }

    
    // *key_Gen_inst* updates
    if (t >= 0.0 && key_Gen_inst.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Gen_inst.tStart = t;  // (not accounting for frame time here)
      key_Gen_inst.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Gen_inst.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Gen_inst.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Gen_inst.clearEvents(); });
    }

    if (key_Gen_inst.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Gen_inst.getKeys({keyList: ['space'], waitRelease: false});
      _key_Gen_inst_allKeys = _key_Gen_inst_allKeys.concat(theseKeys);
      if (_key_Gen_inst_allKeys.length > 0) {
        key_Gen_inst.keys = _key_Gen_inst_allKeys[_key_Gen_inst_allKeys.length - 1].name;  // just the last key pressed
        key_Gen_inst.rt = _key_Gen_inst_allKeys[_key_Gen_inst_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    GeneralInstructionComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function GeneralInstructionRoutineEnd(trials) {
  return function () {
    //------Ending Routine 'GeneralInstruction'-------
    GeneralInstructionComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_Gen_inst.keys', key_Gen_inst.keys);
    if (typeof key_Gen_inst.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Gen_inst.rt', key_Gen_inst.rt);
        routineTimer.reset();
        }
    
    key_Gen_inst.stop();
    // the Routine "GeneralInstruction" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_Phase1_inst_allKeys;
var Phase1instructionsComponents;
function Phase1instructionsRoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase1instructions'-------
    t = 0;
    Phase1instructionsClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_Phase1_inst.keys = undefined;
    key_Phase1_inst.rt = undefined;
    _key_Phase1_inst_allKeys = [];
    // keep track of which components have finished
    Phase1instructionsComponents = [];
    Phase1instructionsComponents.push(Phase1_inst);
    Phase1instructionsComponents.push(key_Phase1_inst);
    
    Phase1instructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase1instructionsRoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase1instructions'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase1instructionsClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *Phase1_inst* updates
    if (t >= 0.0 && Phase1_inst.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      Phase1_inst.tStart = t;  // (not accounting for frame time here)
      Phase1_inst.frameNStart = frameN;  // exact frame index
      
      Phase1_inst.setAutoDraw(true);
    }

    
    // *key_Phase1_inst* updates
    if (t >= 0.0 && key_Phase1_inst.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Phase1_inst.tStart = t;  // (not accounting for frame time here)
      key_Phase1_inst.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Phase1_inst.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Phase1_inst.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Phase1_inst.clearEvents(); });
    }

    if (key_Phase1_inst.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Phase1_inst.getKeys({keyList: ['space'], waitRelease: false});
      _key_Phase1_inst_allKeys = _key_Phase1_inst_allKeys.concat(theseKeys);
      if (_key_Phase1_inst_allKeys.length > 0) {
        key_Phase1_inst.keys = _key_Phase1_inst_allKeys[_key_Phase1_inst_allKeys.length - 1].name;  // just the last key pressed
        key_Phase1_inst.rt = _key_Phase1_inst_allKeys[_key_Phase1_inst_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase1instructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase1instructionsRoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase1instructions'-------
    Phase1instructionsComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_Phase1_inst.keys', key_Phase1_inst.keys);
    if (typeof key_Phase1_inst.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Phase1_inst.rt', key_Phase1_inst.rt);
        routineTimer.reset();
        }
    
    key_Phase1_inst.stop();
    // the Routine "Phase1instructions" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T1_allKeys;
var SoundRecognitionT1T1Components;
function SoundRecognitionT1T1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T1'-------
    t = 0;
    SoundRecognitionT1T1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_thth.secs=5;
    sound_thth.setVolume(1);
    sound_th.secs=5;
    sound_th.setVolume(1);
    key_SRT1T1.keys = undefined;
    key_SRT1T1.rt = undefined;
    _key_SRT1T1_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T1Components = [];
    SoundRecognitionT1T1Components.push(sound_thth);
    SoundRecognitionT1T1Components.push(sound_th);
    SoundRecognitionT1T1Components.push(key_SRT1T1);
    SoundRecognitionT1T1Components.push(text_SRT1T1);
    SoundRecognitionT1T1Components.push(phases_SRT1T1);
    
    SoundRecognitionT1T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


var frameRemains;
function SoundRecognitionT1T1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thth
    if (t >= 0.2 && sound_thth.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth.tStart = t;  // (not accounting for frame time here)
      sound_thth.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth.play(); });  // screen flip
      sound_thth.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth.stop();  // stop the sound (if longer than duration)
        sound_thth.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_th
    if (t >= 4.5 && sound_th.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th.tStart = t;  // (not accounting for frame time here)
      sound_th.frameNStart = frameN;  // exact frame index
      
      sound_th.play();  // start the sound (it finishes automatically)
      sound_th.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th.stop();  // stop the sound (if longer than duration)
        sound_th.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T1* updates
    if (t >= 8 && key_SRT1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T1.tStart = t;  // (not accounting for frame time here)
      key_SRT1T1.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T1.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T1.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T1.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T1.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T1.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T1.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T1_allKeys = _key_SRT1T1_allKeys.concat(theseKeys);
      if (_key_SRT1T1_allKeys.length > 0) {
        key_SRT1T1.keys = _key_SRT1T1_allKeys[_key_SRT1T1_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T1.rt = _key_SRT1T1_allKeys[_key_SRT1T1_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T1.keys == '0') {
            key_SRT1T1.corr = 1;
        } else {
            key_SRT1T1.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T1* updates
    if (t >= 0.0 && text_SRT1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T1.tStart = t;  // (not accounting for frame time here)
      text_SRT1T1.frameNStart = frameN;  // exact frame index
      
      text_SRT1T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T1.setAutoDraw(false);
    }
    
    // *phases_SRT1T1* updates
    if (t >= 0.0 && phases_SRT1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T1.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T1.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T1.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T1'-------
    SoundRecognitionT1T1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thth.stop();  // ensure sound has stopped at end of routine
    sound_th.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T1.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT1T1.corr = 1;  // correct non-response
      } else {
         key_SRT1T1.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T1.keys', key_SRT1T1.keys);
    psychoJS.experiment.addData('key_SRT1T1.corr', key_SRT1T1.corr);
    if (typeof key_SRT1T1.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T1.rt', key_SRT1T1.rt);
        routineTimer.reset();
        }
    
    key_SRT1T1.stop();
    return Scheduler.Event.NEXT;
  };
}


var BlankComponents;
function BlankRoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Blank'-------
    t = 0;
    BlankClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    BlankComponents = [];
    BlankComponents.push(text_blank);
    
    BlankComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function BlankRoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Blank'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = BlankClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_blank* updates
    if (t >= 0.0 && text_blank.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_blank.tStart = t;  // (not accounting for frame time here)
      text_blank.frameNStart = frameN;  // exact frame index
      
      text_blank.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_blank.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_blank.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    BlankComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function BlankRoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Blank'-------
    BlankComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T2_allKeys;
var SoundRecognitionT1T2Components;
function SoundRecognitionT1T2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T2'-------
    t = 0;
    SoundRecognitionT1T2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_thth2.secs=5;
    sound_thth2.setVolume(1);
    sound_thth3.secs=5;
    sound_thth3.setVolume(1);
    key_SRT1T2.keys = undefined;
    key_SRT1T2.rt = undefined;
    _key_SRT1T2_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T2Components = [];
    SoundRecognitionT1T2Components.push(sound_thth2);
    SoundRecognitionT1T2Components.push(sound_thth3);
    SoundRecognitionT1T2Components.push(key_SRT1T2);
    SoundRecognitionT1T2Components.push(text_SRT1T2);
    SoundRecognitionT1T2Components.push(phases_SRT1T2);
    
    SoundRecognitionT1T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thth2
    if (t >= 0.2 && sound_thth2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth2.tStart = t;  // (not accounting for frame time here)
      sound_thth2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth2.play(); });  // screen flip
      sound_thth2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth2.stop();  // stop the sound (if longer than duration)
        sound_thth2.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_thth3
    if (t >= 4.5 && sound_thth3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth3.tStart = t;  // (not accounting for frame time here)
      sound_thth3.frameNStart = frameN;  // exact frame index
      
      sound_thth3.play();  // start the sound (it finishes automatically)
      sound_thth3.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth3.stop();  // stop the sound (if longer than duration)
        sound_thth3.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T2* updates
    if (t >= 8 && key_SRT1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T2.tStart = t;  // (not accounting for frame time here)
      key_SRT1T2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T2.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T2.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T2.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T2_allKeys = _key_SRT1T2_allKeys.concat(theseKeys);
      if (_key_SRT1T2_allKeys.length > 0) {
        key_SRT1T2.keys = _key_SRT1T2_allKeys[_key_SRT1T2_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T2.rt = _key_SRT1T2_allKeys[_key_SRT1T2_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T2.keys == '1') {
            key_SRT1T2.corr = 1;
        } else {
            key_SRT1T2.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T2* updates
    if (t >= 0.0 && text_SRT1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T2.tStart = t;  // (not accounting for frame time here)
      text_SRT1T2.frameNStart = frameN;  // exact frame index
      
      text_SRT1T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T2.setAutoDraw(false);
    }
    
    // *phases_SRT1T2* updates
    if (t >= 0.0 && phases_SRT1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T2.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T2.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T2'-------
    SoundRecognitionT1T2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thth2.stop();  // ensure sound has stopped at end of routine
    sound_thth3.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T2.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT1T2.corr = 1;  // correct non-response
      } else {
         key_SRT1T2.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T2.keys', key_SRT1T2.keys);
    psychoJS.experiment.addData('key_SRT1T2.corr', key_SRT1T2.corr);
    if (typeof key_SRT1T2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T2.rt', key_SRT1T2.rt);
        routineTimer.reset();
        }
    
    key_SRT1T2.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T3_allKeys;
var SoundRecognitionT1T3Components;
function SoundRecognitionT1T3RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T3'-------
    t = 0;
    SoundRecognitionT1T3Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_thth4.secs=5;
    sound_thth4.setVolume(1);
    sound_sh.secs=5;
    sound_sh.setVolume(1);
    key_SRT1T3.keys = undefined;
    key_SRT1T3.rt = undefined;
    _key_SRT1T3_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T3Components = [];
    SoundRecognitionT1T3Components.push(sound_thth4);
    SoundRecognitionT1T3Components.push(sound_sh);
    SoundRecognitionT1T3Components.push(key_SRT1T3);
    SoundRecognitionT1T3Components.push(text_SRT1T3);
    SoundRecognitionT1T3Components.push(phases_SRT1T3);
    
    SoundRecognitionT1T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T3RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thth4
    if (t >= 0.2 && sound_thth4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth4.tStart = t;  // (not accounting for frame time here)
      sound_thth4.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth4.play(); });  // screen flip
      sound_thth4.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth4.stop();  // stop the sound (if longer than duration)
        sound_thth4.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_sh
    if (t >= 4.5 && sound_sh.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh.tStart = t;  // (not accounting for frame time here)
      sound_sh.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh.play(); });  // screen flip
      sound_sh.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh.stop();  // stop the sound (if longer than duration)
        sound_sh.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T3* updates
    if (t >= 8 && key_SRT1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T3.tStart = t;  // (not accounting for frame time here)
      key_SRT1T3.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T3.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T3.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T3.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T3.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T3.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T3.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T3_allKeys = _key_SRT1T3_allKeys.concat(theseKeys);
      if (_key_SRT1T3_allKeys.length > 0) {
        key_SRT1T3.keys = _key_SRT1T3_allKeys[_key_SRT1T3_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T3.rt = _key_SRT1T3_allKeys[_key_SRT1T3_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T3.keys == '0') {
            key_SRT1T3.corr = 1;
        } else {
            key_SRT1T3.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T3* updates
    if (t >= 0.0 && text_SRT1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T3.tStart = t;  // (not accounting for frame time here)
      text_SRT1T3.frameNStart = frameN;  // exact frame index
      
      text_SRT1T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T3.setAutoDraw(false);
    }
    
    // *phases_SRT1T3* updates
    if (t >= 0.0 && phases_SRT1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T3.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T3.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T3RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T3'-------
    SoundRecognitionT1T3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thth4.stop();  // ensure sound has stopped at end of routine
    sound_sh.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T3.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT1T3.corr = 1;  // correct non-response
      } else {
         key_SRT1T3.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T3.keys', key_SRT1T3.keys);
    psychoJS.experiment.addData('key_SRT1T3.corr', key_SRT1T3.corr);
    if (typeof key_SRT1T3.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T3.rt', key_SRT1T3.rt);
        routineTimer.reset();
        }
    
    key_SRT1T3.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T4_allKeys;
var SoundRecognitionT1T4Components;
function SoundRecognitionT1T4RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T4'-------
    t = 0;
    SoundRecognitionT1T4Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_thth5.secs=5;
    sound_thth5.setVolume(1);
    sound_thth6.secs=5;
    sound_thth6.setVolume(1);
    key_SRT1T4.keys = undefined;
    key_SRT1T4.rt = undefined;
    _key_SRT1T4_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T4Components = [];
    SoundRecognitionT1T4Components.push(sound_thth5);
    SoundRecognitionT1T4Components.push(sound_thth6);
    SoundRecognitionT1T4Components.push(key_SRT1T4);
    SoundRecognitionT1T4Components.push(text_SRT1T4);
    SoundRecognitionT1T4Components.push(phases_SRT1T4);
    
    SoundRecognitionT1T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T4RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thth5
    if (t >= 0.2 && sound_thth5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth5.tStart = t;  // (not accounting for frame time here)
      sound_thth5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth5.play(); });  // screen flip
      sound_thth5.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth5.stop();  // stop the sound (if longer than duration)
        sound_thth5.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_thth6
    if (t >= 4.5 && sound_thth6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth6.tStart = t;  // (not accounting for frame time here)
      sound_thth6.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth6.play(); });  // screen flip
      sound_thth6.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth6.stop();  // stop the sound (if longer than duration)
        sound_thth6.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T4* updates
    if (t >= 8 && key_SRT1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T4.tStart = t;  // (not accounting for frame time here)
      key_SRT1T4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T4.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T4.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T4.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T4_allKeys = _key_SRT1T4_allKeys.concat(theseKeys);
      if (_key_SRT1T4_allKeys.length > 0) {
        key_SRT1T4.keys = _key_SRT1T4_allKeys[_key_SRT1T4_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T4.rt = _key_SRT1T4_allKeys[_key_SRT1T4_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T4.keys == '1') {
            key_SRT1T4.corr = 1;
        } else {
            key_SRT1T4.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T4* updates
    if (t >= 0.0 && text_SRT1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T4.tStart = t;  // (not accounting for frame time here)
      text_SRT1T4.frameNStart = frameN;  // exact frame index
      
      text_SRT1T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T4.setAutoDraw(false);
    }
    
    // *phases_SRT1T4* updates
    if (t >= 0.0 && phases_SRT1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T4.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T4.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T4.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T4RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T4'-------
    SoundRecognitionT1T4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thth5.stop();  // ensure sound has stopped at end of routine
    sound_thth6.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T4.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT1T4.corr = 1;  // correct non-response
      } else {
         key_SRT1T4.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T4.keys', key_SRT1T4.keys);
    psychoJS.experiment.addData('key_SRT1T4.corr', key_SRT1T4.corr);
    if (typeof key_SRT1T4.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T4.rt', key_SRT1T4.rt);
        routineTimer.reset();
        }
    
    key_SRT1T4.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T5_allKeys;
var SoundRecognitionT1T5Components;
function SoundRecognitionT1T5RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T5'-------
    t = 0;
    SoundRecognitionT1T5Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_th2.secs=5;
    sound_th2.setVolume(1);
    sound_thth7.secs=5;
    sound_thth7.setVolume(1);
    key_SRT1T5.keys = undefined;
    key_SRT1T5.rt = undefined;
    _key_SRT1T5_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T5Components = [];
    SoundRecognitionT1T5Components.push(sound_th2);
    SoundRecognitionT1T5Components.push(sound_thth7);
    SoundRecognitionT1T5Components.push(key_SRT1T5);
    SoundRecognitionT1T5Components.push(text_SRT1T5);
    SoundRecognitionT1T5Components.push(phases_SRT1T5);
    
    SoundRecognitionT1T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T5RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T5'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_th2
    if (t >= 0.2 && sound_th2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th2.tStart = t;  // (not accounting for frame time here)
      sound_th2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th2.play(); });  // screen flip
      sound_th2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th2.stop();  // stop the sound (if longer than duration)
        sound_th2.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_thth7
    if (t >= 4.5 && sound_thth7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth7.tStart = t;  // (not accounting for frame time here)
      sound_thth7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth7.play(); });  // screen flip
      sound_thth7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth7.stop();  // stop the sound (if longer than duration)
        sound_thth7.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T5* updates
    if (t >= 8 && key_SRT1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T5.tStart = t;  // (not accounting for frame time here)
      key_SRT1T5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T5.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T5.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T5.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T5_allKeys = _key_SRT1T5_allKeys.concat(theseKeys);
      if (_key_SRT1T5_allKeys.length > 0) {
        key_SRT1T5.keys = _key_SRT1T5_allKeys[_key_SRT1T5_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T5.rt = _key_SRT1T5_allKeys[_key_SRT1T5_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T5.keys == '0') {
            key_SRT1T5.corr = 1;
        } else {
            key_SRT1T5.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T5* updates
    if (t >= 0.0 && text_SRT1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T5.tStart = t;  // (not accounting for frame time here)
      text_SRT1T5.frameNStart = frameN;  // exact frame index
      
      text_SRT1T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T5.setAutoDraw(false);
    }
    
    // *phases_SRT1T5* updates
    if (t >= 0.0 && phases_SRT1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T5.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T5.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T5RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T5'-------
    SoundRecognitionT1T5Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_th2.stop();  // ensure sound has stopped at end of routine
    sound_thth7.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T5.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT1T5.corr = 1;  // correct non-response
      } else {
         key_SRT1T5.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T5.keys', key_SRT1T5.keys);
    psychoJS.experiment.addData('key_SRT1T5.corr', key_SRT1T5.corr);
    if (typeof key_SRT1T5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T5.rt', key_SRT1T5.rt);
        routineTimer.reset();
        }
    
    key_SRT1T5.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T6_allKeys;
var SoundRecognitionT1T6Components;
function SoundRecognitionT1T6RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T6'-------
    t = 0;
    SoundRecognitionT1T6Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_th4.secs=5;
    sound_th4.setVolume(1);
    sound_th3.secs=5;
    sound_th3.setVolume(1);
    key_SRT1T6.keys = undefined;
    key_SRT1T6.rt = undefined;
    _key_SRT1T6_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T6Components = [];
    SoundRecognitionT1T6Components.push(sound_th4);
    SoundRecognitionT1T6Components.push(sound_th3);
    SoundRecognitionT1T6Components.push(key_SRT1T6);
    SoundRecognitionT1T6Components.push(text_SRT1T6);
    SoundRecognitionT1T6Components.push(phases_SRT1T6);
    
    SoundRecognitionT1T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T6RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T6'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_th4
    if (t >= 0.2 && sound_th4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th4.tStart = t;  // (not accounting for frame time here)
      sound_th4.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th4.play(); });  // screen flip
      sound_th4.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th4.stop();  // stop the sound (if longer than duration)
        sound_th4.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_th3
    if (t >= 4.5 && sound_th3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th3.tStart = t;  // (not accounting for frame time here)
      sound_th3.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th3.play(); });  // screen flip
      sound_th3.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th3.stop();  // stop the sound (if longer than duration)
        sound_th3.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T6* updates
    if (t >= 8 && key_SRT1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T6.tStart = t;  // (not accounting for frame time here)
      key_SRT1T6.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T6.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T6.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T6.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T6.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T6.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T6.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T6_allKeys = _key_SRT1T6_allKeys.concat(theseKeys);
      if (_key_SRT1T6_allKeys.length > 0) {
        key_SRT1T6.keys = _key_SRT1T6_allKeys[_key_SRT1T6_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T6.rt = _key_SRT1T6_allKeys[_key_SRT1T6_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T6.keys == '1') {
            key_SRT1T6.corr = 1;
        } else {
            key_SRT1T6.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T6* updates
    if (t >= 0.0 && text_SRT1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T6.tStart = t;  // (not accounting for frame time here)
      text_SRT1T6.frameNStart = frameN;  // exact frame index
      
      text_SRT1T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T6.setAutoDraw(false);
    }
    
    // *phases_SRT1T6* updates
    if (t >= 0.0 && phases_SRT1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T6.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T6.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T6.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T6RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T6'-------
    SoundRecognitionT1T6Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_th4.stop();  // ensure sound has stopped at end of routine
    sound_th3.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T6.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT1T6.corr = 1;  // correct non-response
      } else {
         key_SRT1T6.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T6.keys', key_SRT1T6.keys);
    psychoJS.experiment.addData('key_SRT1T6.corr', key_SRT1T6.corr);
    if (typeof key_SRT1T6.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T6.rt', key_SRT1T6.rt);
        routineTimer.reset();
        }
    
    key_SRT1T6.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T7_allKeys;
var SoundRecognitionT1T7Components;
function SoundRecognitionT1T7RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T7'-------
    t = 0;
    SoundRecognitionT1T7Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_th5.secs=5;
    sound_th5.setVolume(1);
    sound_sh8.secs=5;
    sound_sh8.setVolume(1);
    key_SRT1T7.keys = undefined;
    key_SRT1T7.rt = undefined;
    _key_SRT1T7_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T7Components = [];
    SoundRecognitionT1T7Components.push(sound_th5);
    SoundRecognitionT1T7Components.push(sound_sh8);
    SoundRecognitionT1T7Components.push(key_SRT1T7);
    SoundRecognitionT1T7Components.push(text_SRT1T7);
    SoundRecognitionT1T7Components.push(phases_SRT1T7);
    
    SoundRecognitionT1T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T7RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T7'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_th5
    if (t >= 0.2 && sound_th5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th5.tStart = t;  // (not accounting for frame time here)
      sound_th5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th5.play(); });  // screen flip
      sound_th5.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th5.stop();  // stop the sound (if longer than duration)
        sound_th5.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_sh8
    if (t >= 4.5 && sound_sh8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh8.tStart = t;  // (not accounting for frame time here)
      sound_sh8.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh8.play(); });  // screen flip
      sound_sh8.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh8.stop();  // stop the sound (if longer than duration)
        sound_sh8.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T7* updates
    if (t >= 8 && key_SRT1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T7.tStart = t;  // (not accounting for frame time here)
      key_SRT1T7.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T7.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T7.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T7.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T7.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T7.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T7.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T7_allKeys = _key_SRT1T7_allKeys.concat(theseKeys);
      if (_key_SRT1T7_allKeys.length > 0) {
        key_SRT1T7.keys = _key_SRT1T7_allKeys[_key_SRT1T7_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T7.rt = _key_SRT1T7_allKeys[_key_SRT1T7_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T7.keys == '1') {
            key_SRT1T7.corr = 1;
        } else {
            key_SRT1T7.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T7* updates
    if (t >= 0.0 && text_SRT1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T7.tStart = t;  // (not accounting for frame time here)
      text_SRT1T7.frameNStart = frameN;  // exact frame index
      
      text_SRT1T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T7.setAutoDraw(false);
    }
    
    // *phases_SRT1T7* updates
    if (t >= 0.0 && phases_SRT1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T7.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T7.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T7.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T7RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T7'-------
    SoundRecognitionT1T7Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_th5.stop();  // ensure sound has stopped at end of routine
    sound_sh8.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T7.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT1T7.corr = 1;  // correct non-response
      } else {
         key_SRT1T7.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T7.keys', key_SRT1T7.keys);
    psychoJS.experiment.addData('key_SRT1T7.corr', key_SRT1T7.corr);
    if (typeof key_SRT1T7.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T7.rt', key_SRT1T7.rt);
        routineTimer.reset();
        }
    
    key_SRT1T7.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T8_allKeys;
var SoundRecognitionT1T8Components;
function SoundRecognitionT1T8RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T8'-------
    t = 0;
    SoundRecognitionT1T8Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_th7.secs=5;
    sound_th7.setVolume(1);
    sound_th8.secs=5;
    sound_th8.setVolume(1);
    key_SRT1T8.keys = undefined;
    key_SRT1T8.rt = undefined;
    _key_SRT1T8_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T8Components = [];
    SoundRecognitionT1T8Components.push(sound_th7);
    SoundRecognitionT1T8Components.push(sound_th8);
    SoundRecognitionT1T8Components.push(key_SRT1T8);
    SoundRecognitionT1T8Components.push(text_SRT1T8);
    SoundRecognitionT1T8Components.push(phases_SRT1T8);
    
    SoundRecognitionT1T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T8RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T8'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T8Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_th7
    if (t >= 0.2 && sound_th7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th7.tStart = t;  // (not accounting for frame time here)
      sound_th7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th7.play(); });  // screen flip
      sound_th7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th7.stop();  // stop the sound (if longer than duration)
        sound_th7.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_th8
    if (t >= 4.5 && sound_th8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th8.tStart = t;  // (not accounting for frame time here)
      sound_th8.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th8.play(); });  // screen flip
      sound_th8.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th8.stop();  // stop the sound (if longer than duration)
        sound_th8.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T8* updates
    if (t >= 8 && key_SRT1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T8.tStart = t;  // (not accounting for frame time here)
      key_SRT1T8.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T8.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T8.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T8.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T8.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T8.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T8.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T8_allKeys = _key_SRT1T8_allKeys.concat(theseKeys);
      if (_key_SRT1T8_allKeys.length > 0) {
        key_SRT1T8.keys = _key_SRT1T8_allKeys[_key_SRT1T8_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T8.rt = _key_SRT1T8_allKeys[_key_SRT1T8_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T8.keys == '1') {
            key_SRT1T8.corr = 1;
        } else {
            key_SRT1T8.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T8* updates
    if (t >= 0.0 && text_SRT1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T8.tStart = t;  // (not accounting for frame time here)
      text_SRT1T8.frameNStart = frameN;  // exact frame index
      
      text_SRT1T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T8.setAutoDraw(false);
    }
    
    // *phases_SRT1T8* updates
    if (t >= 0.0 && phases_SRT1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T8.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T8.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T8.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T8RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T8'-------
    SoundRecognitionT1T8Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_th7.stop();  // ensure sound has stopped at end of routine
    sound_th8.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T8.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT1T8.corr = 1;  // correct non-response
      } else {
         key_SRT1T8.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T8.keys', key_SRT1T8.keys);
    psychoJS.experiment.addData('key_SRT1T8.corr', key_SRT1T8.corr);
    if (typeof key_SRT1T8.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T8.rt', key_SRT1T8.rt);
        routineTimer.reset();
        }
    
    key_SRT1T8.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T9_allKeys;
var SoundRecognitionT1T9Components;
function SoundRecognitionT1T9RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T9'-------
    t = 0;
    SoundRecognitionT1T9Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_sh2.secs=5;
    sound_sh2.setVolume(1);
    sound_thth8.secs=5;
    sound_thth8.setVolume(1);
    key_SRT1T9.keys = undefined;
    key_SRT1T9.rt = undefined;
    _key_SRT1T9_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T9Components = [];
    SoundRecognitionT1T9Components.push(sound_sh2);
    SoundRecognitionT1T9Components.push(sound_thth8);
    SoundRecognitionT1T9Components.push(key_SRT1T9);
    SoundRecognitionT1T9Components.push(text_SRT1T9);
    SoundRecognitionT1T9Components.push(phases_SRT1T9);
    
    SoundRecognitionT1T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T9RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T9'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T9Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_sh2
    if (t >= 0.2 && sound_sh2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh2.tStart = t;  // (not accounting for frame time here)
      sound_sh2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh2.play(); });  // screen flip
      sound_sh2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh2.stop();  // stop the sound (if longer than duration)
        sound_sh2.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_thth8
    if (t >= 4.5 && sound_thth8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth8.tStart = t;  // (not accounting for frame time here)
      sound_thth8.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth8.play(); });  // screen flip
      sound_thth8.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth8.stop();  // stop the sound (if longer than duration)
        sound_thth8.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T9* updates
    if (t >= 8 && key_SRT1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T9.tStart = t;  // (not accounting for frame time here)
      key_SRT1T9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T9.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T9.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T9.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T9_allKeys = _key_SRT1T9_allKeys.concat(theseKeys);
      if (_key_SRT1T9_allKeys.length > 0) {
        key_SRT1T9.keys = _key_SRT1T9_allKeys[_key_SRT1T9_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T9.rt = _key_SRT1T9_allKeys[_key_SRT1T9_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T9.keys == '0') {
            key_SRT1T9.corr = 1;
        } else {
            key_SRT1T9.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T9* updates
    if (t >= 0.0 && text_SRT1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T9.tStart = t;  // (not accounting for frame time here)
      text_SRT1T9.frameNStart = frameN;  // exact frame index
      
      text_SRT1T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T9.setAutoDraw(false);
    }
    
    // *phases_SRT1T9* updates
    if (t >= 0 && phases_SRT1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T9.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T9.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T9.setAutoDraw(true);
    }

    frameRemains = 0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T9.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T9RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T9'-------
    SoundRecognitionT1T9Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_sh2.stop();  // ensure sound has stopped at end of routine
    sound_thth8.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T9.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT1T9.corr = 1;  // correct non-response
      } else {
         key_SRT1T9.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T9.keys', key_SRT1T9.keys);
    psychoJS.experiment.addData('key_SRT1T9.corr', key_SRT1T9.corr);
    if (typeof key_SRT1T9.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T9.rt', key_SRT1T9.rt);
        routineTimer.reset();
        }
    
    key_SRT1T9.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T10_allKeys;
var SoundRecognitionT1T10Components;
function SoundRecognitionT1T10RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T10'-------
    t = 0;
    SoundRecognitionT1T10Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_sh3.secs=5;
    sound_sh3.setVolume(1);
    sound_th9.secs=5;
    sound_th9.setVolume(1);
    key_SRT1T10.keys = undefined;
    key_SRT1T10.rt = undefined;
    _key_SRT1T10_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T10Components = [];
    SoundRecognitionT1T10Components.push(sound_sh3);
    SoundRecognitionT1T10Components.push(sound_th9);
    SoundRecognitionT1T10Components.push(key_SRT1T10);
    SoundRecognitionT1T10Components.push(text_SRT1T10);
    SoundRecognitionT1T10Components.push(phases_SRT1T10);
    
    SoundRecognitionT1T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T10RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T10'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T10Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_sh3
    if (t >= 0.2 && sound_sh3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh3.tStart = t;  // (not accounting for frame time here)
      sound_sh3.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh3.play(); });  // screen flip
      sound_sh3.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh3.stop();  // stop the sound (if longer than duration)
        sound_sh3.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_th9
    if (t >= 4.5 && sound_th9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th9.tStart = t;  // (not accounting for frame time here)
      sound_th9.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th9.play(); });  // screen flip
      sound_th9.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th9.stop();  // stop the sound (if longer than duration)
        sound_th9.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T10* updates
    if (t >= 8 && key_SRT1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T10.tStart = t;  // (not accounting for frame time here)
      key_SRT1T10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T10.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T10.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T10.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T10_allKeys = _key_SRT1T10_allKeys.concat(theseKeys);
      if (_key_SRT1T10_allKeys.length > 0) {
        key_SRT1T10.keys = _key_SRT1T10_allKeys[_key_SRT1T10_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T10.rt = _key_SRT1T10_allKeys[_key_SRT1T10_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T10.keys == '0') {
            key_SRT1T10.corr = 1;
        } else {
            key_SRT1T10.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T10* updates
    if (t >= 0.0 && text_SRT1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T10.tStart = t;  // (not accounting for frame time here)
      text_SRT1T10.frameNStart = frameN;  // exact frame index
      
      text_SRT1T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T10.setAutoDraw(false);
    }
    
    // *phases_SRT1T10* updates
    if (t >= 0.0 && phases_SRT1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T10.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T10.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T10.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T10RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T10'-------
    SoundRecognitionT1T10Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_sh3.stop();  // ensure sound has stopped at end of routine
    sound_th9.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T10.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT1T10.corr = 1;  // correct non-response
      } else {
         key_SRT1T10.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T10.keys', key_SRT1T10.keys);
    psychoJS.experiment.addData('key_SRT1T10.corr', key_SRT1T10.corr);
    if (typeof key_SRT1T10.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T10.rt', key_SRT1T10.rt);
        routineTimer.reset();
        }
    
    key_SRT1T10.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T11_allKeys;
var SoundRecognitionT1T11Components;
function SoundRecognitionT1T11RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T11'-------
    t = 0;
    SoundRecognitionT1T11Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_sh4.secs=5;
    sound_sh4.setVolume(1);
    sound_sh5.secs=5;
    sound_sh5.setVolume(1);
    key_SRT1T11.keys = undefined;
    key_SRT1T11.rt = undefined;
    _key_SRT1T11_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T11Components = [];
    SoundRecognitionT1T11Components.push(sound_sh4);
    SoundRecognitionT1T11Components.push(sound_sh5);
    SoundRecognitionT1T11Components.push(key_SRT1T11);
    SoundRecognitionT1T11Components.push(text_SRT1T11);
    SoundRecognitionT1T11Components.push(phases_SRT1T11);
    
    SoundRecognitionT1T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T11RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T11'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T11Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_sh4
    if (t >= 0.2 && sound_sh4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh4.tStart = t;  // (not accounting for frame time here)
      sound_sh4.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh4.play(); });  // screen flip
      sound_sh4.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh4.stop();  // stop the sound (if longer than duration)
        sound_sh4.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_sh5
    if (t >= 4.5 && sound_sh5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh5.tStart = t;  // (not accounting for frame time here)
      sound_sh5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh5.play(); });  // screen flip
      sound_sh5.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh5.stop();  // stop the sound (if longer than duration)
        sound_sh5.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T11* updates
    if (t >= 8 && key_SRT1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T11.tStart = t;  // (not accounting for frame time here)
      key_SRT1T11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T11.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T11.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T11.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T11_allKeys = _key_SRT1T11_allKeys.concat(theseKeys);
      if (_key_SRT1T11_allKeys.length > 0) {
        key_SRT1T11.keys = _key_SRT1T11_allKeys[_key_SRT1T11_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T11.rt = _key_SRT1T11_allKeys[_key_SRT1T11_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T11.keys == '1') {
            key_SRT1T11.corr = 1;
        } else {
            key_SRT1T11.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T11* updates
    if (t >= 0.0 && text_SRT1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T11.tStart = t;  // (not accounting for frame time here)
      text_SRT1T11.frameNStart = frameN;  // exact frame index
      
      text_SRT1T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T11.setAutoDraw(false);
    }
    
    // *phases_SRT1T11* updates
    if (t >= 0.0 && phases_SRT1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T11.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T11.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T11.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T11RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T11'-------
    SoundRecognitionT1T11Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_sh4.stop();  // ensure sound has stopped at end of routine
    sound_sh5.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T11.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT1T11.corr = 1;  // correct non-response
      } else {
         key_SRT1T11.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T11.keys', key_SRT1T11.keys);
    psychoJS.experiment.addData('key_SRT1T11.corr', key_SRT1T11.corr);
    if (typeof key_SRT1T11.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T11.rt', key_SRT1T11.rt);
        routineTimer.reset();
        }
    
    key_SRT1T11.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT1T12_allKeys;
var SoundRecognitionT1T12Components;
function SoundRecognitionT1T12RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT1T12'-------
    t = 0;
    SoundRecognitionT1T12Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_sh6.secs=5;
    sound_sh6.setVolume(1);
    sound_sh7.secs=5;
    sound_sh7.setVolume(1);
    key_SRT1T12.keys = undefined;
    key_SRT1T12.rt = undefined;
    _key_SRT1T12_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT1T12Components = [];
    SoundRecognitionT1T12Components.push(sound_sh6);
    SoundRecognitionT1T12Components.push(sound_sh7);
    SoundRecognitionT1T12Components.push(key_SRT1T12);
    SoundRecognitionT1T12Components.push(text_SRT1T12);
    SoundRecognitionT1T12Components.push(phases_SRT1T12);
    
    SoundRecognitionT1T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT1T12RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT1T12'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT1T12Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_sh6
    if (t >= 0.2 && sound_sh6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh6.tStart = t;  // (not accounting for frame time here)
      sound_sh6.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh6.play(); });  // screen flip
      sound_sh6.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh6.stop();  // stop the sound (if longer than duration)
        sound_sh6.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_sh7
    if (t >= 4.5 && sound_sh7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh7.tStart = t;  // (not accounting for frame time here)
      sound_sh7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh7.play(); });  // screen flip
      sound_sh7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh7.stop();  // stop the sound (if longer than duration)
        sound_sh7.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT1T12* updates
    if (t >= 8 && key_SRT1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT1T12.tStart = t;  // (not accounting for frame time here)
      key_SRT1T12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT1T12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT1T12.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT1T12.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT1T12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT1T12.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT1T12_allKeys = _key_SRT1T12_allKeys.concat(theseKeys);
      if (_key_SRT1T12_allKeys.length > 0) {
        key_SRT1T12.keys = _key_SRT1T12_allKeys[_key_SRT1T12_allKeys.length - 1].name;  // just the last key pressed
        key_SRT1T12.rt = _key_SRT1T12_allKeys[_key_SRT1T12_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT1T12.keys == '1') {
            key_SRT1T12.corr = 1;
        } else {
            key_SRT1T12.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT1T12* updates
    if (t >= 0.0 && text_SRT1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT1T12.tStart = t;  // (not accounting for frame time here)
      text_SRT1T12.frameNStart = frameN;  // exact frame index
      
      text_SRT1T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT1T12.setAutoDraw(false);
    }
    
    // *phases_SRT1T12* updates
    if (t >= 0.0 && phases_SRT1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT1T12.tStart = t;  // (not accounting for frame time here)
      phases_SRT1T12.frameNStart = frameN;  // exact frame index
      
      phases_SRT1T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT1T12.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT1T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT1T12RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT1T12'-------
    SoundRecognitionT1T12Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_sh6.stop();  // ensure sound has stopped at end of routine
    sound_sh7.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT1T12.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT1T12.corr = 1;  // correct non-response
      } else {
         key_SRT1T12.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT1T12.keys', key_SRT1T12.keys);
    psychoJS.experiment.addData('key_SRT1T12.corr', key_SRT1T12.corr);
    if (typeof key_SRT1T12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT1T12.rt', key_SRT1T12.rt);
        routineTimer.reset();
        }
    
    key_SRT1T12.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_phase1_inst2_allKeys;
var Phase1instructions2Components;
function Phase1instructions2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase1instructions2'-------
    t = 0;
    Phase1instructions2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_phase1_inst2.keys = undefined;
    key_phase1_inst2.rt = undefined;
    _key_phase1_inst2_allKeys = [];
    // keep track of which components have finished
    Phase1instructions2Components = [];
    Phase1instructions2Components.push(text_phase1_inst2);
    Phase1instructions2Components.push(key_phase1_inst2);
    
    Phase1instructions2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase1instructions2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase1instructions2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase1instructions2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_phase1_inst2* updates
    if (t >= 0.0 && text_phase1_inst2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_phase1_inst2.tStart = t;  // (not accounting for frame time here)
      text_phase1_inst2.frameNStart = frameN;  // exact frame index
      
      text_phase1_inst2.setAutoDraw(true);
    }

    
    // *key_phase1_inst2* updates
    if (t >= 0.0 && key_phase1_inst2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_phase1_inst2.tStart = t;  // (not accounting for frame time here)
      key_phase1_inst2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_phase1_inst2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_phase1_inst2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_phase1_inst2.clearEvents(); });
    }

    if (key_phase1_inst2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_phase1_inst2.getKeys({keyList: ['space'], waitRelease: false});
      _key_phase1_inst2_allKeys = _key_phase1_inst2_allKeys.concat(theseKeys);
      if (_key_phase1_inst2_allKeys.length > 0) {
        key_phase1_inst2.keys = _key_phase1_inst2_allKeys[_key_phase1_inst2_allKeys.length - 1].name;  // just the last key pressed
        key_phase1_inst2.rt = _key_phase1_inst2_allKeys[_key_phase1_inst2_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase1instructions2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase1instructions2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase1instructions2'-------
    Phase1instructions2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_phase1_inst2.keys', key_phase1_inst2.keys);
    if (typeof key_phase1_inst2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_phase1_inst2.rt', key_phase1_inst2.rt);
        routineTimer.reset();
        }
    
    key_phase1_inst2.stop();
    // the Routine "Phase1instructions2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T1_allKeys;
var SoundRecognitionT2T1Components;
function SoundRecognitionT2T1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T1'-------
    t = 0;
    SoundRecognitionT2T1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_thrwa_thrwa.secs=5;
    sound_thrwa_thrwa.setVolume(1);
    key_SRT2T1.keys = undefined;
    key_SRT2T1.rt = undefined;
    _key_SRT2T1_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T1Components = [];
    SoundRecognitionT2T1Components.push(sound_thrwa_thrwa);
    SoundRecognitionT2T1Components.push(key_SRT2T1);
    SoundRecognitionT2T1Components.push(text_SRT2T1);
    SoundRecognitionT2T1Components.push(phases_SRT2T1);
    
    SoundRecognitionT2T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thrwa_thrwa
    if (t >= 0.2 && sound_thrwa_thrwa.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thrwa_thrwa.tStart = t;  // (not accounting for frame time here)
      sound_thrwa_thrwa.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thrwa_thrwa.play(); });  // screen flip
      sound_thrwa_thrwa.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thrwa_thrwa.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thrwa_thrwa.stop();  // stop the sound (if longer than duration)
        sound_thrwa_thrwa.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T1* updates
    if (t >= 4.2 && key_SRT2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T1.tStart = t;  // (not accounting for frame time here)
      key_SRT2T1.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T1.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T1.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T1.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T1.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T1.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T1.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T1_allKeys = _key_SRT2T1_allKeys.concat(theseKeys);
      if (_key_SRT2T1_allKeys.length > 0) {
        key_SRT2T1.keys = _key_SRT2T1_allKeys[_key_SRT2T1_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T1.rt = _key_SRT2T1_allKeys[_key_SRT2T1_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T1.keys == '1') {
            key_SRT2T1.corr = 1;
        } else {
            key_SRT2T1.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T1* updates
    if (t >= 0.0 && text_SRT2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T1.tStart = t;  // (not accounting for frame time here)
      text_SRT2T1.frameNStart = frameN;  // exact frame index
      
      text_SRT2T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T1.setAutoDraw(false);
    }
    
    // *phases_SRT2T1* updates
    if (t >= 0.0 && phases_SRT2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T1.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T1.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T1.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T1'-------
    SoundRecognitionT2T1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thrwa_thrwa.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T1.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT2T1.corr = 1;  // correct non-response
      } else {
         key_SRT2T1.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T1.keys', key_SRT2T1.keys);
    psychoJS.experiment.addData('key_SRT2T1.corr', key_SRT2T1.corr);
    if (typeof key_SRT2T1.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T1.rt', key_SRT2T1.rt);
        routineTimer.reset();
        }
    
    key_SRT2T1.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T2_allKeys;
var SoundRecognitionT2T2Components;
function SoundRecognitionT2T2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T2'-------
    t = 0;
    SoundRecognitionT2T2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_ththm_thm.secs=5;
    sound_ththm_thm.setVolume(1);
    key_SRT2T2.keys = undefined;
    key_SRT2T2.rt = undefined;
    _key_SRT2T2_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T2Components = [];
    SoundRecognitionT2T2Components.push(sound_ththm_thm);
    SoundRecognitionT2T2Components.push(key_SRT2T2);
    SoundRecognitionT2T2Components.push(text_SRT2T2);
    SoundRecognitionT2T2Components.push(phases_SRT2T2);
    
    SoundRecognitionT2T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththm_thm
    if (t >= 0.2 && sound_ththm_thm.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththm_thm.tStart = t;  // (not accounting for frame time here)
      sound_ththm_thm.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththm_thm.play(); });  // screen flip
      sound_ththm_thm.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththm_thm.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_ththm_thm.stop();  // stop the sound (if longer than duration)
        sound_ththm_thm.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T2* updates
    if (t >= 4.2 && key_SRT2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T2.tStart = t;  // (not accounting for frame time here)
      key_SRT2T2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T2.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T2.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T2.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T2_allKeys = _key_SRT2T2_allKeys.concat(theseKeys);
      if (_key_SRT2T2_allKeys.length > 0) {
        key_SRT2T2.keys = _key_SRT2T2_allKeys[_key_SRT2T2_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T2.rt = _key_SRT2T2_allKeys[_key_SRT2T2_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T2.keys == '0') {
            key_SRT2T2.corr = 1;
        } else {
            key_SRT2T2.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T2* updates
    if (t >= 0.0 && text_SRT2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T2.tStart = t;  // (not accounting for frame time here)
      text_SRT2T2.frameNStart = frameN;  // exact frame index
      
      text_SRT2T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T2.setAutoDraw(false);
    }
    
    // *phases_SRT2T2* updates
    if (t >= 0.0 && phases_SRT2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T2.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T2.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T2'-------
    SoundRecognitionT2T2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththm_thm.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T2.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT2T2.corr = 1;  // correct non-response
      } else {
         key_SRT2T2.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T2.keys', key_SRT2T2.keys);
    psychoJS.experiment.addData('key_SRT2T2.corr', key_SRT2T2.corr);
    if (typeof key_SRT2T2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T2.rt', key_SRT2T2.rt);
        routineTimer.reset();
        }
    
    key_SRT2T2.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T3_allKeys;
var SoundRecognitionT2T3Components;
function SoundRecognitionT2T3RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T3'-------
    t = 0;
    SoundRecognitionT2T3Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_ththab_shab.secs=5;
    sound_ththab_shab.setVolume(1);
    key_SRT2T3.keys = undefined;
    key_SRT2T3.rt = undefined;
    _key_SRT2T3_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T3Components = [];
    SoundRecognitionT2T3Components.push(sound_ththab_shab);
    SoundRecognitionT2T3Components.push(key_SRT2T3);
    SoundRecognitionT2T3Components.push(text_SRT2T3);
    SoundRecognitionT2T3Components.push(phases_SRT2T3);
    
    SoundRecognitionT2T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T3RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththab_shab
    if (t >= 0.2 && sound_ththab_shab.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththab_shab.tStart = t;  // (not accounting for frame time here)
      sound_ththab_shab.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththab_shab.play(); });  // screen flip
      sound_ththab_shab.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththab_shab.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_ththab_shab.stop();  // stop the sound (if longer than duration)
        sound_ththab_shab.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T3* updates
    if (t >= 4.2 && key_SRT2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T3.tStart = t;  // (not accounting for frame time here)
      key_SRT2T3.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T3.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T3.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T3.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T3.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T3.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T3.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T3_allKeys = _key_SRT2T3_allKeys.concat(theseKeys);
      if (_key_SRT2T3_allKeys.length > 0) {
        key_SRT2T3.keys = _key_SRT2T3_allKeys[_key_SRT2T3_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T3.rt = _key_SRT2T3_allKeys[_key_SRT2T3_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T3.keys == '0') {
            key_SRT2T3.corr = 1;
        } else {
            key_SRT2T3.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T3* updates
    if (t >= 0.0 && text_SRT2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T3.tStart = t;  // (not accounting for frame time here)
      text_SRT2T3.frameNStart = frameN;  // exact frame index
      
      text_SRT2T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T3.setAutoDraw(false);
    }
    
    // *phases_SRT2T3* updates
    if (t >= 0.0 && phases_SRT2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T3.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T3.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T3RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T3'-------
    SoundRecognitionT2T3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththab_shab.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T3.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT2T3.corr = 1;  // correct non-response
      } else {
         key_SRT2T3.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T3.keys', key_SRT2T3.keys);
    psychoJS.experiment.addData('key_SRT2T3.corr', key_SRT2T3.corr);
    if (typeof key_SRT2T3.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T3.rt', key_SRT2T3.rt);
        routineTimer.reset();
        }
    
    key_SRT2T3.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T4_allKeys;
var SoundRecognitionT2T4Components;
function SoundRecognitionT2T4RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T4'-------
    t = 0;
    SoundRecognitionT2T4Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_ththna_ththna.secs=5;
    sound_ththna_ththna.setVolume(1);
    key_SRT2T4.keys = undefined;
    key_SRT2T4.rt = undefined;
    _key_SRT2T4_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T4Components = [];
    SoundRecognitionT2T4Components.push(sound_ththna_ththna);
    SoundRecognitionT2T4Components.push(key_SRT2T4);
    SoundRecognitionT2T4Components.push(text_SRT2T4);
    SoundRecognitionT2T4Components.push(phases_SRT2T4);
    
    SoundRecognitionT2T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T4RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththna_ththna
    if (t >= 0.2 && sound_ththna_ththna.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththna_ththna.tStart = t;  // (not accounting for frame time here)
      sound_ththna_ththna.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththna_ththna.play(); });  // screen flip
      sound_ththna_ththna.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththna_ththna.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_ththna_ththna.stop();  // stop the sound (if longer than duration)
        sound_ththna_ththna.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T4* updates
    if (t >= 4.2 && key_SRT2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T4.tStart = t;  // (not accounting for frame time here)
      key_SRT2T4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T4.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T4.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T4.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T4_allKeys = _key_SRT2T4_allKeys.concat(theseKeys);
      if (_key_SRT2T4_allKeys.length > 0) {
        key_SRT2T4.keys = _key_SRT2T4_allKeys[_key_SRT2T4_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T4.rt = _key_SRT2T4_allKeys[_key_SRT2T4_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T4.keys == '1') {
            key_SRT2T4.corr = 1;
        } else {
            key_SRT2T4.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T4* updates
    if (t >= 0.0 && text_SRT2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T4.tStart = t;  // (not accounting for frame time here)
      text_SRT2T4.frameNStart = frameN;  // exact frame index
      
      text_SRT2T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T4.setAutoDraw(false);
    }
    
    // *phases_SRT2T4* updates
    if (t >= 0.0 && phases_SRT2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T4.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T4.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T4.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T4RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T4'-------
    SoundRecognitionT2T4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththna_ththna.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T4.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT2T4.corr = 1;  // correct non-response
      } else {
         key_SRT2T4.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T4.keys', key_SRT2T4.keys);
    psychoJS.experiment.addData('key_SRT2T4.corr', key_SRT2T4.corr);
    if (typeof key_SRT2T4.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T4.rt', key_SRT2T4.rt);
        routineTimer.reset();
        }
    
    key_SRT2T4.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T5_allKeys;
var SoundRecognitionT2T5Components;
function SoundRecognitionT2T5RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T5'-------
    t = 0;
    SoundRecognitionT2T5Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_thra_ththra.secs=5;
    sound_thra_ththra.setVolume(1);
    key_SRT2T5.keys = undefined;
    key_SRT2T5.rt = undefined;
    _key_SRT2T5_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T5Components = [];
    SoundRecognitionT2T5Components.push(sound_thra_ththra);
    SoundRecognitionT2T5Components.push(key_SRT2T5);
    SoundRecognitionT2T5Components.push(text_SRT2T5);
    SoundRecognitionT2T5Components.push(phases_SRT2T5);
    
    SoundRecognitionT2T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T5RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T5'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thra_ththra
    if (t >= 0.2 && sound_thra_ththra.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thra_ththra.tStart = t;  // (not accounting for frame time here)
      sound_thra_ththra.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thra_ththra.play(); });  // screen flip
      sound_thra_ththra.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thra_ththra.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thra_ththra.stop();  // stop the sound (if longer than duration)
        sound_thra_ththra.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T5* updates
    if (t >= 4.2 && key_SRT2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T5.tStart = t;  // (not accounting for frame time here)
      key_SRT2T5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T5.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T5.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T5.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T5_allKeys = _key_SRT2T5_allKeys.concat(theseKeys);
      if (_key_SRT2T5_allKeys.length > 0) {
        key_SRT2T5.keys = _key_SRT2T5_allKeys[_key_SRT2T5_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T5.rt = _key_SRT2T5_allKeys[_key_SRT2T5_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T5.keys == '0') {
            key_SRT2T5.corr = 1;
        } else {
            key_SRT2T5.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T5* updates
    if (t >= 0.0 && text_SRT2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T5.tStart = t;  // (not accounting for frame time here)
      text_SRT2T5.frameNStart = frameN;  // exact frame index
      
      text_SRT2T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T5.setAutoDraw(false);
    }
    
    // *phases_SRT2T5* updates
    if (t >= 0.0 && phases_SRT2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T5.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T5.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T5RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T5'-------
    SoundRecognitionT2T5Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thra_ththra.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T5.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT2T5.corr = 1;  // correct non-response
      } else {
         key_SRT2T5.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T5.keys', key_SRT2T5.keys);
    psychoJS.experiment.addData('key_SRT2T5.corr', key_SRT2T5.corr);
    if (typeof key_SRT2T5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T5.rt', key_SRT2T5.rt);
        routineTimer.reset();
        }
    
    key_SRT2T5.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T6_allKeys;
var SoundRecognitionT2T6Components;
function SoundRecognitionT2T6RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T6'-------
    t = 0;
    SoundRecognitionT2T6Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_thb7_shb7.secs=5;
    sound_thb7_shb7.setVolume(1);
    key_SRT2T6.keys = undefined;
    key_SRT2T6.rt = undefined;
    _key_SRT2T6_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T6Components = [];
    SoundRecognitionT2T6Components.push(sound_thb7_shb7);
    SoundRecognitionT2T6Components.push(key_SRT2T6);
    SoundRecognitionT2T6Components.push(text_SRT2T6);
    SoundRecognitionT2T6Components.push(phases_SRT2T6);
    
    SoundRecognitionT2T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T6RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T6'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thb7_shb7
    if (t >= 0.2 && sound_thb7_shb7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thb7_shb7.tStart = t;  // (not accounting for frame time here)
      sound_thb7_shb7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thb7_shb7.play(); });  // screen flip
      sound_thb7_shb7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thb7_shb7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thb7_shb7.stop();  // stop the sound (if longer than duration)
        sound_thb7_shb7.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T6* updates
    if (t >= 4.2 && key_SRT2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T6.tStart = t;  // (not accounting for frame time here)
      key_SRT2T6.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T6.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T6.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T6.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T6.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T6.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T6.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T6_allKeys = _key_SRT2T6_allKeys.concat(theseKeys);
      if (_key_SRT2T6_allKeys.length > 0) {
        key_SRT2T6.keys = _key_SRT2T6_allKeys[_key_SRT2T6_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T6.rt = _key_SRT2T6_allKeys[_key_SRT2T6_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T6.keys == '0') {
            key_SRT2T6.corr = 1;
        } else {
            key_SRT2T6.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T6* updates
    if (t >= 0.0 && text_SRT2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T6.tStart = t;  // (not accounting for frame time here)
      text_SRT2T6.frameNStart = frameN;  // exact frame index
      
      text_SRT2T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T6.setAutoDraw(false);
    }
    
    // *phases_SRT2T6* updates
    if (t >= 0.0 && phases_SRT2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T6.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T6.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T6.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T6RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T6'-------
    SoundRecognitionT2T6Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thb7_shb7.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T6.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT2T6.corr = 1;  // correct non-response
      } else {
         key_SRT2T6.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T6.keys', key_SRT2T6.keys);
    psychoJS.experiment.addData('key_SRT2T6.corr', key_SRT2T6.corr);
    if (typeof key_SRT2T6.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T6.rt', key_SRT2T6.rt);
        routineTimer.reset();
        }
    
    key_SRT2T6.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T7_allKeys;
var SoundRecognitionT2T7Components;
function SoundRecognitionT2T7RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T7'-------
    t = 0;
    SoundRecognitionT2T7Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_thwq_thwq.secs=5;
    sound_thwq_thwq.setVolume(1);
    key_SRT2T7.keys = undefined;
    key_SRT2T7.rt = undefined;
    _key_SRT2T7_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T7Components = [];
    SoundRecognitionT2T7Components.push(sound_thwq_thwq);
    SoundRecognitionT2T7Components.push(key_SRT2T7);
    SoundRecognitionT2T7Components.push(text_SRT2T7);
    SoundRecognitionT2T7Components.push(phases_SRT2T7);
    
    SoundRecognitionT2T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T7RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T7'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thwq_thwq
    if (t >= 0.2 && sound_thwq_thwq.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thwq_thwq.tStart = t;  // (not accounting for frame time here)
      sound_thwq_thwq.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thwq_thwq.play(); });  // screen flip
      sound_thwq_thwq.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thwq_thwq.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thwq_thwq.stop();  // stop the sound (if longer than duration)
        sound_thwq_thwq.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T7* updates
    if (t >= 4.2 && key_SRT2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T7.tStart = t;  // (not accounting for frame time here)
      key_SRT2T7.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T7.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T7.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T7.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T7.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T7.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T7.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T7_allKeys = _key_SRT2T7_allKeys.concat(theseKeys);
      if (_key_SRT2T7_allKeys.length > 0) {
        key_SRT2T7.keys = _key_SRT2T7_allKeys[_key_SRT2T7_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T7.rt = _key_SRT2T7_allKeys[_key_SRT2T7_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T7.keys == '1') {
            key_SRT2T7.corr = 1;
        } else {
            key_SRT2T7.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T7* updates
    if (t >= 0.0 && text_SRT2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T7.tStart = t;  // (not accounting for frame time here)
      text_SRT2T7.frameNStart = frameN;  // exact frame index
      
      text_SRT2T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T7.setAutoDraw(false);
    }
    
    // *phases_SRT2T7* updates
    if (t >= 0.0 && phases_SRT2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T7.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T7.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T7.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T7RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T7'-------
    SoundRecognitionT2T7Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thwq_thwq.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T7.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT2T7.corr = 1;  // correct non-response
      } else {
         key_SRT2T7.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T7.keys', key_SRT2T7.keys);
    psychoJS.experiment.addData('key_SRT2T7.corr', key_SRT2T7.corr);
    if (typeof key_SRT2T7.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T7.rt', key_SRT2T7.rt);
        routineTimer.reset();
        }
    
    key_SRT2T7.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T8_allKeys;
var SoundRecognitionT2T8Components;
function SoundRecognitionT2T8RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T8'-------
    t = 0;
    SoundRecognitionT2T8Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_thail_thail.secs=5;
    sound_thail_thail.setVolume(1);
    key_SRT2T8.keys = undefined;
    key_SRT2T8.rt = undefined;
    _key_SRT2T8_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T8Components = [];
    SoundRecognitionT2T8Components.push(sound_thail_thail);
    SoundRecognitionT2T8Components.push(key_SRT2T8);
    SoundRecognitionT2T8Components.push(text_SRT2T8);
    SoundRecognitionT2T8Components.push(phases_SRT2T8);
    
    SoundRecognitionT2T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T8RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T8'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T8Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thail_thail
    if (t >= 0.2 && sound_thail_thail.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thail_thail.tStart = t;  // (not accounting for frame time here)
      sound_thail_thail.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thail_thail.play(); });  // screen flip
      sound_thail_thail.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thail_thail.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thail_thail.stop();  // stop the sound (if longer than duration)
        sound_thail_thail.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T8* updates
    if (t >= 4.2 && key_SRT2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T8.tStart = t;  // (not accounting for frame time here)
      key_SRT2T8.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T8.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T8.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T8.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T8.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T8.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T8.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T8_allKeys = _key_SRT2T8_allKeys.concat(theseKeys);
      if (_key_SRT2T8_allKeys.length > 0) {
        key_SRT2T8.keys = _key_SRT2T8_allKeys[_key_SRT2T8_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T8.rt = _key_SRT2T8_allKeys[_key_SRT2T8_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T8.keys == '1') {
            key_SRT2T8.corr = 1;
        } else {
            key_SRT2T8.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T8* updates
    if (t >= 0.0 && text_SRT2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T8.tStart = t;  // (not accounting for frame time here)
      text_SRT2T8.frameNStart = frameN;  // exact frame index
      
      text_SRT2T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T8.setAutoDraw(false);
    }
    
    // *phases_SRT2T8* updates
    if (t >= 0.0 && phases_SRT2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T8.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T8.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T8.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T8RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T8'-------
    SoundRecognitionT2T8Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thail_thail.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T8.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT2T8.corr = 1;  // correct non-response
      } else {
         key_SRT2T8.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T8.keys', key_SRT2T8.keys);
    psychoJS.experiment.addData('key_SRT2T8.corr', key_SRT2T8.corr);
    if (typeof key_SRT2T8.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T8.rt', key_SRT2T8.rt);
        routineTimer.reset();
        }
    
    key_SRT2T8.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T9_allKeys;
var SoundRecognitionT2T9Components;
function SoundRecognitionT2T9RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T9'-------
    t = 0;
    SoundRecognitionT2T9Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_shrf_thrf.secs=5;
    sound_shrf_thrf.setVolume(1);
    key_SRT2T9.keys = undefined;
    key_SRT2T9.rt = undefined;
    _key_SRT2T9_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T9Components = [];
    SoundRecognitionT2T9Components.push(sound_shrf_thrf);
    SoundRecognitionT2T9Components.push(key_SRT2T9);
    SoundRecognitionT2T9Components.push(text_SRT2T9);
    SoundRecognitionT2T9Components.push(phases_SRT2T9);
    
    SoundRecognitionT2T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T9RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T9'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T9Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_shrf_thrf
    if (t >= 0.2 && sound_shrf_thrf.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_shrf_thrf.tStart = t;  // (not accounting for frame time here)
      sound_shrf_thrf.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_shrf_thrf.play(); });  // screen flip
      sound_shrf_thrf.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_shrf_thrf.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_shrf_thrf.stop();  // stop the sound (if longer than duration)
        sound_shrf_thrf.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T9* updates
    if (t >= 4.2 && key_SRT2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T9.tStart = t;  // (not accounting for frame time here)
      key_SRT2T9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T9.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T9.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T9.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T9_allKeys = _key_SRT2T9_allKeys.concat(theseKeys);
      if (_key_SRT2T9_allKeys.length > 0) {
        key_SRT2T9.keys = _key_SRT2T9_allKeys[_key_SRT2T9_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T9.rt = _key_SRT2T9_allKeys[_key_SRT2T9_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T9.keys == '0') {
            key_SRT2T9.corr = 1;
        } else {
            key_SRT2T9.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T9* updates
    if (t >= 0.0 && text_SRT2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T9.tStart = t;  // (not accounting for frame time here)
      text_SRT2T9.frameNStart = frameN;  // exact frame index
      
      text_SRT2T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T9.setAutoDraw(false);
    }
    
    // *phases_SRT2T9* updates
    if (t >= 0.0 && phases_SRT2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T9.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T9.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T9.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T9RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T9'-------
    SoundRecognitionT2T9Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_shrf_thrf.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T9.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT2T9.corr = 1;  // correct non-response
      } else {
         key_SRT2T9.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T9.keys', key_SRT2T9.keys);
    psychoJS.experiment.addData('key_SRT2T9.corr', key_SRT2T9.corr);
    if (typeof key_SRT2T9.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T9.rt', key_SRT2T9.rt);
        routineTimer.reset();
        }
    
    key_SRT2T9.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T10_allKeys;
var SoundRecognitionT2T10Components;
function SoundRecognitionT2T10RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T10'-------
    t = 0;
    SoundRecognitionT2T10Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_sh7m_sh7m.secs=5;
    sound_sh7m_sh7m.setVolume(1);
    key_SRT2T10.keys = undefined;
    key_SRT2T10.rt = undefined;
    _key_SRT2T10_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T10Components = [];
    SoundRecognitionT2T10Components.push(sound_sh7m_sh7m);
    SoundRecognitionT2T10Components.push(key_SRT2T10);
    SoundRecognitionT2T10Components.push(text_SRT2T10);
    SoundRecognitionT2T10Components.push(phases_SRT2T10);
    
    SoundRecognitionT2T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T10RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T10'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T10Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_sh7m_sh7m
    if (t >= 0.2 && sound_sh7m_sh7m.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh7m_sh7m.tStart = t;  // (not accounting for frame time here)
      sound_sh7m_sh7m.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh7m_sh7m.play(); });  // screen flip
      sound_sh7m_sh7m.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh7m_sh7m.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh7m_sh7m.stop();  // stop the sound (if longer than duration)
        sound_sh7m_sh7m.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T10* updates
    if (t >= 4.2 && key_SRT2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T10.tStart = t;  // (not accounting for frame time here)
      key_SRT2T10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T10.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T10.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T10.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T10_allKeys = _key_SRT2T10_allKeys.concat(theseKeys);
      if (_key_SRT2T10_allKeys.length > 0) {
        key_SRT2T10.keys = _key_SRT2T10_allKeys[_key_SRT2T10_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T10.rt = _key_SRT2T10_allKeys[_key_SRT2T10_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T10.keys == '1') {
            key_SRT2T10.corr = 1;
        } else {
            key_SRT2T10.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T10* updates
    if (t >= 0.0 && text_SRT2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T10.tStart = t;  // (not accounting for frame time here)
      text_SRT2T10.frameNStart = frameN;  // exact frame index
      
      text_SRT2T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T10.setAutoDraw(false);
    }
    
    // *phases_SRT2T10* updates
    if (t >= 0.0 && phases_SRT2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T10.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T10.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T10.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T10RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T10'-------
    SoundRecognitionT2T10Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_sh7m_sh7m.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T10.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT2T10.corr = 1;  // correct non-response
      } else {
         key_SRT2T10.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T10.keys', key_SRT2T10.keys);
    psychoJS.experiment.addData('key_SRT2T10.corr', key_SRT2T10.corr);
    if (typeof key_SRT2T10.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T10.rt', key_SRT2T10.rt);
        routineTimer.reset();
        }
    
    key_SRT2T10.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T11_allKeys;
var SoundRecognitionT2T11Components;
function SoundRecognitionT2T11RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T11'-------
    t = 0;
    SoundRecognitionT2T11Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_shra_ththra.secs=5;
    sound_shra_ththra.setVolume(1);
    key_SRT2T11.keys = undefined;
    key_SRT2T11.rt = undefined;
    _key_SRT2T11_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T11Components = [];
    SoundRecognitionT2T11Components.push(sound_shra_ththra);
    SoundRecognitionT2T11Components.push(key_SRT2T11);
    SoundRecognitionT2T11Components.push(text_SRT2T11);
    SoundRecognitionT2T11Components.push(phases_SRT2T11);
    
    SoundRecognitionT2T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T11RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T11'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T11Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_shra_ththra
    if (t >= 0.2 && sound_shra_ththra.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_shra_ththra.tStart = t;  // (not accounting for frame time here)
      sound_shra_ththra.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_shra_ththra.play(); });  // screen flip
      sound_shra_ththra.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_shra_ththra.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_shra_ththra.stop();  // stop the sound (if longer than duration)
        sound_shra_ththra.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T11* updates
    if (t >= 4.2 && key_SRT2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T11.tStart = t;  // (not accounting for frame time here)
      key_SRT2T11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T11.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T11.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T11.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T11_allKeys = _key_SRT2T11_allKeys.concat(theseKeys);
      if (_key_SRT2T11_allKeys.length > 0) {
        key_SRT2T11.keys = _key_SRT2T11_allKeys[_key_SRT2T11_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T11.rt = _key_SRT2T11_allKeys[_key_SRT2T11_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T11.keys == '0') {
            key_SRT2T11.corr = 1;
        } else {
            key_SRT2T11.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T11* updates
    if (t >= 0.0 && text_SRT2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T11.tStart = t;  // (not accounting for frame time here)
      text_SRT2T11.frameNStart = frameN;  // exact frame index
      
      text_SRT2T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T11.setAutoDraw(false);
    }
    
    // *phases_SRT2T11* updates
    if (t >= 0.0 && phases_SRT2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T11.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T11.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T11.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T11RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T11'-------
    SoundRecognitionT2T11Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_shra_ththra.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T11.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_SRT2T11.corr = 1;  // correct non-response
      } else {
         key_SRT2T11.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T11.keys', key_SRT2T11.keys);
    psychoJS.experiment.addData('key_SRT2T11.corr', key_SRT2T11.corr);
    if (typeof key_SRT2T11.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T11.rt', key_SRT2T11.rt);
        routineTimer.reset();
        }
    
    key_SRT2T11.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_SRT2T12_allKeys;
var SoundRecognitionT2T12Components;
function SoundRecognitionT2T12RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'SoundRecognitionT2T12'-------
    t = 0;
    SoundRecognitionT2T12Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_shfa_shfa.secs=5;
    sound_shfa_shfa.setVolume(1);
    key_SRT2T12.keys = undefined;
    key_SRT2T12.rt = undefined;
    _key_SRT2T12_allKeys = [];
    // keep track of which components have finished
    SoundRecognitionT2T12Components = [];
    SoundRecognitionT2T12Components.push(sound_shfa_shfa);
    SoundRecognitionT2T12Components.push(key_SRT2T12);
    SoundRecognitionT2T12Components.push(text_SRT2T12);
    SoundRecognitionT2T12Components.push(phases_SRT2T12);
    
    SoundRecognitionT2T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function SoundRecognitionT2T12RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'SoundRecognitionT2T12'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = SoundRecognitionT2T12Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_shfa_shfa
    if (t >= 0.2 && sound_shfa_shfa.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_shfa_shfa.tStart = t;  // (not accounting for frame time here)
      sound_shfa_shfa.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_shfa_shfa.play(); });  // screen flip
      sound_shfa_shfa.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_shfa_shfa.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_shfa_shfa.stop();  // stop the sound (if longer than duration)
        sound_shfa_shfa.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_SRT2T12* updates
    if (t >= 4.2 && key_SRT2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRT2T12.tStart = t;  // (not accounting for frame time here)
      key_SRT2T12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRT2T12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRT2T12.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_SRT2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_SRT2T12.status = PsychoJS.Status.FINISHED;
  }

    if (key_SRT2T12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRT2T12.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_SRT2T12_allKeys = _key_SRT2T12_allKeys.concat(theseKeys);
      if (_key_SRT2T12_allKeys.length > 0) {
        key_SRT2T12.keys = _key_SRT2T12_allKeys[_key_SRT2T12_allKeys.length - 1].name;  // just the last key pressed
        key_SRT2T12.rt = _key_SRT2T12_allKeys[_key_SRT2T12_allKeys.length - 1].rt;
        // was this correct?
        if (key_SRT2T12.keys == '1') {
            key_SRT2T12.corr = 1;
        } else {
            key_SRT2T12.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_SRT2T12* updates
    if (t >= 0.0 && text_SRT2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRT2T12.tStart = t;  // (not accounting for frame time here)
      text_SRT2T12.frameNStart = frameN;  // exact frame index
      
      text_SRT2T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_SRT2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_SRT2T12.setAutoDraw(false);
    }
    
    // *phases_SRT2T12* updates
    if (t >= 0.0 && phases_SRT2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_SRT2T12.tStart = t;  // (not accounting for frame time here)
      phases_SRT2T12.frameNStart = frameN;  // exact frame index
      
      phases_SRT2T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_SRT2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_SRT2T12.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    SoundRecognitionT2T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function SoundRecognitionT2T12RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'SoundRecognitionT2T12'-------
    SoundRecognitionT2T12Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_shfa_shfa.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_SRT2T12.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_SRT2T12.corr = 1;  // correct non-response
      } else {
         key_SRT2T12.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_SRT2T12.keys', key_SRT2T12.keys);
    psychoJS.experiment.addData('key_SRT2T12.corr', key_SRT2T12.corr);
    if (typeof key_SRT2T12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRT2T12.rt', key_SRT2T12.rt);
        routineTimer.reset();
        }
    
    key_SRT2T12.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_EndSR_allKeys;
var EndSoundRecognitionComponents;
function EndSoundRecognitionRoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'EndSoundRecognition'-------
    t = 0;
    EndSoundRecognitionClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_EndSR.keys = undefined;
    key_EndSR.rt = undefined;
    _key_EndSR_allKeys = [];
    // keep track of which components have finished
    EndSoundRecognitionComponents = [];
    EndSoundRecognitionComponents.push(text_EndSR);
    EndSoundRecognitionComponents.push(key_EndSR);
    EndSoundRecognitionComponents.push(phases_endSR);
    
    EndSoundRecognitionComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function EndSoundRecognitionRoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'EndSoundRecognition'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = EndSoundRecognitionClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_EndSR* updates
    if (t >= 0.0 && text_EndSR.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_EndSR.tStart = t;  // (not accounting for frame time here)
      text_EndSR.frameNStart = frameN;  // exact frame index
      
      text_EndSR.setAutoDraw(true);
    }

    
    // *key_EndSR* updates
    if (t >= 0.0 && key_EndSR.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_EndSR.tStart = t;  // (not accounting for frame time here)
      key_EndSR.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_EndSR.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_EndSR.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_EndSR.clearEvents(); });
    }

    if (key_EndSR.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_EndSR.getKeys({keyList: ['space'], waitRelease: false});
      _key_EndSR_allKeys = _key_EndSR_allKeys.concat(theseKeys);
      if (_key_EndSR_allKeys.length > 0) {
        key_EndSR.keys = _key_EndSR_allKeys[_key_EndSR_allKeys.length - 1].name;  // just the last key pressed
        key_EndSR.rt = _key_EndSR_allKeys[_key_EndSR_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_endSR* updates
    if (t >= 0.0 && phases_endSR.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_endSR.tStart = t;  // (not accounting for frame time here)
      phases_endSR.frameNStart = frameN;  // exact frame index
      
      phases_endSR.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    EndSoundRecognitionComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function EndSoundRecognitionRoutineEnd(trials) {
  return function () {
    //------Ending Routine 'EndSoundRecognition'-------
    EndSoundRecognitionComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_EndSR.keys', key_EndSR.keys);
    if (typeof key_EndSR.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_EndSR.rt', key_EndSR.rt);
        routineTimer.reset();
        }
    
    key_EndSR.stop();
    // the Routine "EndSoundRecognition" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_WLinst_allKeys;
var Phase2instructionsComponents;
function Phase2instructionsRoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase2instructions'-------
    t = 0;
    Phase2instructionsClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_WLinst.keys = undefined;
    key_WLinst.rt = undefined;
    _key_WLinst_allKeys = [];
    // keep track of which components have finished
    Phase2instructionsComponents = [];
    Phase2instructionsComponents.push(text);
    Phase2instructionsComponents.push(key_WLinst);
    
    Phase2instructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase2instructionsRoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase2instructions'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase2instructionsClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text* updates
    if (t >= 0.0 && text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text.tStart = t;  // (not accounting for frame time here)
      text.frameNStart = frameN;  // exact frame index
      
      text.setAutoDraw(true);
    }

    
    // *key_WLinst* updates
    if (t >= 0.0 && key_WLinst.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_WLinst.tStart = t;  // (not accounting for frame time here)
      key_WLinst.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_WLinst.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_WLinst.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_WLinst.clearEvents(); });
    }

    if (key_WLinst.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_WLinst.getKeys({keyList: ['space'], waitRelease: false});
      _key_WLinst_allKeys = _key_WLinst_allKeys.concat(theseKeys);
      if (_key_WLinst_allKeys.length > 0) {
        key_WLinst.keys = _key_WLinst_allKeys[_key_WLinst_allKeys.length - 1].name;  // just the last key pressed
        key_WLinst.rt = _key_WLinst_allKeys[_key_WLinst_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase2instructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase2instructionsRoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase2instructions'-------
    Phase2instructionsComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_WLinst.keys', key_WLinst.keys);
    if (typeof key_WLinst.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_WLinst.rt', key_WLinst.rt);
        routineTimer.reset();
        }
    
    key_WLinst.stop();
    // the Routine "Phase2instructions" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var trials;
var currentLoop;
function trialsLoopBegin(thisScheduler) {
  // set up handler to look after randomisation of conditions etc
  trials = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 10, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: undefined,
    seed: undefined, name: 'trials'
  });
  psychoJS.experiment.addLoop(trials); // add the loop to the experiment
  currentLoop = trials;  // we're now the current loop

  // Schedule all the trials in the trialList:
  trials.forEach(function() {
    const snapshot = trials.getSnapshot();

    thisScheduler.add(importConditions(snapshot));
    thisScheduler.add(WordLearningT1RoutineBegin(snapshot));
    thisScheduler.add(WordLearningT1RoutineEachFrame(snapshot));
    thisScheduler.add(WordLearningT1RoutineEnd(snapshot));
    thisScheduler.add(WordLearningT2RoutineBegin(snapshot));
    thisScheduler.add(WordLearningT2RoutineEachFrame(snapshot));
    thisScheduler.add(WordLearningT2RoutineEnd(snapshot));
    thisScheduler.add(WordLearningT3RoutineBegin(snapshot));
    thisScheduler.add(WordLearningT3RoutineEachFrame(snapshot));
    thisScheduler.add(WordLearningT3RoutineEnd(snapshot));
    thisScheduler.add(endLoopIteration(thisScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function trialsLoopEnd() {
  psychoJS.experiment.removeLoop(trials);

  return Scheduler.Event.NEXT;
}


var WordLearningT1Components;
function WordLearningT1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'WordLearningT1'-------
    t = 0;
    WordLearningT1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.000000);
    // update component parameters for each repeat
    sound_ththami.secs=5.2;
    sound_ththami.setVolume(1);
    sound_thami.secs=5;
    sound_thami.setVolume(1);
    // keep track of which components have finished
    WordLearningT1Components = [];
    WordLearningT1Components.push(sound_ththami);
    WordLearningT1Components.push(image_ththami);
    WordLearningT1Components.push(sound_thami);
    WordLearningT1Components.push(image_thami);
    
    WordLearningT1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function WordLearningT1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'WordLearningT1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = WordLearningT1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththami
    if (t >= 0.2 && sound_ththami.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththami.tStart = t;  // (not accounting for frame time here)
      sound_ththami.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththami.play(); });  // screen flip
      sound_ththami.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththami.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5.2 > 0.5) {  sound_ththami.stop();  // stop the sound (if longer than duration)
        sound_ththami.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththami* updates
    if (t >= 0.2 && image_ththami.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami.tStart = t;  // (not accounting for frame time here)
      image_ththami.frameNStart = frameN;  // exact frame index
      
      image_ththami.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9.8 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami.setAutoDraw(false);
    }
    // start/stop sound_thami
    if (t >= 5 && sound_thami.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thami.tStart = t;  // (not accounting for frame time here)
      sound_thami.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thami.play(); });  // screen flip
      sound_thami.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thami.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thami.stop();  // stop the sound (if longer than duration)
        sound_thami.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thami* updates
    if (t >= 5 && image_thami.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami.tStart = t;  // (not accounting for frame time here)
      image_thami.frameNStart = frameN;  // exact frame index
      
      image_thami.setAutoDraw(true);
    }

    frameRemains = 5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    WordLearningT1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function WordLearningT1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'WordLearningT1'-------
    WordLearningT1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththami.stop();  // ensure sound has stopped at end of routine
    sound_thami.stop();  // ensure sound has stopped at end of routine
    return Scheduler.Event.NEXT;
  };
}


var WordLearningT2Components;
function WordLearningT2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'WordLearningT2'-------
    t = 0;
    WordLearningT2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.000000);
    // update component parameters for each repeat
    sound_ththuri.secs=5.2;
    sound_ththuri.setVolume(1);
    sound_thuri.secs=5;
    sound_thuri.setVolume(1);
    // keep track of which components have finished
    WordLearningT2Components = [];
    WordLearningT2Components.push(sound_ththuri);
    WordLearningT2Components.push(image_ththuri);
    WordLearningT2Components.push(sound_thuri);
    WordLearningT2Components.push(image_thuri);
    
    WordLearningT2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function WordLearningT2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'WordLearningT2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = WordLearningT2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththuri
    if (t >= 0.2 && sound_ththuri.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththuri.tStart = t;  // (not accounting for frame time here)
      sound_ththuri.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththuri.play(); });  // screen flip
      sound_ththuri.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththuri.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5.2 > 0.5) {  sound_ththuri.stop();  // stop the sound (if longer than duration)
        sound_ththuri.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththuri* updates
    if (t >= 0.2 && image_ththuri.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri.tStart = t;  // (not accounting for frame time here)
      image_ththuri.frameNStart = frameN;  // exact frame index
      
      image_ththuri.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9.8 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri.setAutoDraw(false);
    }
    // start/stop sound_thuri
    if (t >= 5 && sound_thuri.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thuri.tStart = t;  // (not accounting for frame time here)
      sound_thuri.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thuri.play(); });  // screen flip
      sound_thuri.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thuri.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thuri.stop();  // stop the sound (if longer than duration)
        sound_thuri.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thuri* updates
    if (t >= 5 && image_thuri.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri.tStart = t;  // (not accounting for frame time here)
      image_thuri.frameNStart = frameN;  // exact frame index
      
      image_thuri.setAutoDraw(true);
    }

    frameRemains = 5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    WordLearningT2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function WordLearningT2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'WordLearningT2'-------
    WordLearningT2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththuri.stop();  // ensure sound has stopped at end of routine
    sound_thuri.stop();  // ensure sound has stopped at end of routine
    return Scheduler.Event.NEXT;
  };
}


var WordLearningT3Components;
function WordLearningT3RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'WordLearningT3'-------
    t = 0;
    WordLearningT3Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.000000);
    // update component parameters for each repeat
    sound_ththano.secs=5.2;
    sound_ththano.setVolume(1);
    sound_thano.secs=5;
    sound_thano.setVolume(1);
    // keep track of which components have finished
    WordLearningT3Components = [];
    WordLearningT3Components.push(sound_ththano);
    WordLearningT3Components.push(image_ththano);
    WordLearningT3Components.push(sound_thano);
    WordLearningT3Components.push(image_thano);
    
    WordLearningT3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function WordLearningT3RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'WordLearningT3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = WordLearningT3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththano
    if (t >= 0.2 && sound_ththano.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththano.tStart = t;  // (not accounting for frame time here)
      sound_ththano.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththano.play(); });  // screen flip
      sound_ththano.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththano.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5.2 > 0.5) {  sound_ththano.stop();  // stop the sound (if longer than duration)
        sound_ththano.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththano* updates
    if (t >= 0.2 && image_ththano.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano.tStart = t;  // (not accounting for frame time here)
      image_ththano.frameNStart = frameN;  // exact frame index
      
      image_ththano.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9.8 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano.setAutoDraw(false);
    }
    // start/stop sound_thano
    if (t >= 5 && sound_thano.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thano.tStart = t;  // (not accounting for frame time here)
      sound_thano.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thano.play(); });  // screen flip
      sound_thano.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thano.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thano.stop();  // stop the sound (if longer than duration)
        sound_thano.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thano* updates
    if (t >= 5 && image_thano.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano.tStart = t;  // (not accounting for frame time here)
      image_thano.frameNStart = frameN;  // exact frame index
      
      image_thano.setAutoDraw(true);
    }

    frameRemains = 5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    WordLearningT3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function WordLearningT3RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'WordLearningT3'-------
    WordLearningT3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththano.stop();  // ensure sound has stopped at end of routine
    sound_thano.stop();  // ensure sound has stopped at end of routine
    return Scheduler.Event.NEXT;
  };
}


var _key_EndWL_allKeys;
var EndWordLearningComponents;
function EndWordLearningRoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'EndWordLearning'-------
    t = 0;
    EndWordLearningClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_EndWL.keys = undefined;
    key_EndWL.rt = undefined;
    _key_EndWL_allKeys = [];
    // keep track of which components have finished
    EndWordLearningComponents = [];
    EndWordLearningComponents.push(text_EndWL);
    EndWordLearningComponents.push(key_EndWL);
    EndWordLearningComponents.push(phases_endWL);
    
    EndWordLearningComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function EndWordLearningRoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'EndWordLearning'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = EndWordLearningClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_EndWL* updates
    if (t >= 0.0 && text_EndWL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_EndWL.tStart = t;  // (not accounting for frame time here)
      text_EndWL.frameNStart = frameN;  // exact frame index
      
      text_EndWL.setAutoDraw(true);
    }

    
    // *key_EndWL* updates
    if (t >= 0.0 && key_EndWL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_EndWL.tStart = t;  // (not accounting for frame time here)
      key_EndWL.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_EndWL.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_EndWL.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_EndWL.clearEvents(); });
    }

    if (key_EndWL.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_EndWL.getKeys({keyList: ['space'], waitRelease: false});
      _key_EndWL_allKeys = _key_EndWL_allKeys.concat(theseKeys);
      if (_key_EndWL_allKeys.length > 0) {
        key_EndWL.keys = _key_EndWL_allKeys[_key_EndWL_allKeys.length - 1].name;  // just the last key pressed
        key_EndWL.rt = _key_EndWL_allKeys[_key_EndWL_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_endWL* updates
    if (t >= 0.0 && phases_endWL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_endWL.tStart = t;  // (not accounting for frame time here)
      phases_endWL.frameNStart = frameN;  // exact frame index
      
      phases_endWL.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    EndWordLearningComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function EndWordLearningRoutineEnd(trials) {
  return function () {
    //------Ending Routine 'EndWordLearning'-------
    EndWordLearningComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_EndWL.keys', key_EndWL.keys);
    if (typeof key_EndWL.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_EndWL.rt', key_EndWL.rt);
        routineTimer.reset();
        }
    
    key_EndWL.stop();
    // the Routine "EndWordLearning" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_CTinstructionsT1_allKeys;
var Phase3Instructions1Components;
function Phase3Instructions1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase3Instructions1'-------
    t = 0;
    Phase3Instructions1Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_CTinstructionsT1.keys = undefined;
    key_CTinstructionsT1.rt = undefined;
    _key_CTinstructionsT1_allKeys = [];
    // keep track of which components have finished
    Phase3Instructions1Components = [];
    Phase3Instructions1Components.push(text_CTInstructionsT1);
    Phase3Instructions1Components.push(key_CTinstructionsT1);
    
    Phase3Instructions1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase3Instructions1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase3Instructions1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase3Instructions1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_CTInstructionsT1* updates
    if (t >= 0.0 && text_CTInstructionsT1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CTInstructionsT1.tStart = t;  // (not accounting for frame time here)
      text_CTInstructionsT1.frameNStart = frameN;  // exact frame index
      
      text_CTInstructionsT1.setAutoDraw(true);
    }

    
    // *key_CTinstructionsT1* updates
    if (t >= 0.0 && key_CTinstructionsT1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CTinstructionsT1.tStart = t;  // (not accounting for frame time here)
      key_CTinstructionsT1.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CTinstructionsT1.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CTinstructionsT1.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CTinstructionsT1.clearEvents(); });
    }

    if (key_CTinstructionsT1.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CTinstructionsT1.getKeys({keyList: ['space'], waitRelease: false});
      _key_CTinstructionsT1_allKeys = _key_CTinstructionsT1_allKeys.concat(theseKeys);
      if (_key_CTinstructionsT1_allKeys.length > 0) {
        key_CTinstructionsT1.keys = _key_CTinstructionsT1_allKeys[_key_CTinstructionsT1_allKeys.length - 1].name;  // just the last key pressed
        key_CTinstructionsT1.rt = _key_CTinstructionsT1_allKeys[_key_CTinstructionsT1_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase3Instructions1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase3Instructions1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase3Instructions1'-------
    Phase3Instructions1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_CTinstructionsT1.keys', key_CTinstructionsT1.keys);
    if (typeof key_CTinstructionsT1.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CTinstructionsT1.rt', key_CTinstructionsT1.rt);
        routineTimer.reset();
        }
    
    key_CTinstructionsT1.stop();
    // the Routine "Phase3Instructions1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T1_allKeys;
var CriterionTestT1T1Components;
function CriterionTestT1T1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT1T1'-------
    t = 0;
    CriterionTestT1T1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thuri2.secs=4;
    sound_thuri2.setVolume(1);
    key_CT_T1T1.keys = undefined;
    key_CT_T1T1.rt = undefined;
    _key_CT_T1T1_allKeys = [];
    // keep track of which components have finished
    CriterionTestT1T1Components = [];
    CriterionTestT1T1Components.push(sound_thuri2);
    CriterionTestT1T1Components.push(image_thuri2);
    CriterionTestT1T1Components.push(Text_CT_T1T1);
    CriterionTestT1T1Components.push(key_CT_T1T1);
    CriterionTestT1T1Components.push(phases_CT_T1T1);
    
    CriterionTestT1T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT1T1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT1T1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT1T1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thuri2
    if (t >= 0.2 && sound_thuri2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thuri2.tStart = t;  // (not accounting for frame time here)
      sound_thuri2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thuri2.play(); });  // screen flip
      sound_thuri2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thuri2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thuri2.stop();  // stop the sound (if longer than duration)
        sound_thuri2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thuri2* updates
    if (t >= 0.2 && image_thuri2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri2.tStart = t;  // (not accounting for frame time here)
      image_thuri2.frameNStart = frameN;  // exact frame index
      
      image_thuri2.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri2.setAutoDraw(false);
    }
    
    // *Text_CT_T1T1* updates
    if (t >= 0.0 && Text_CT_T1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      Text_CT_T1T1.tStart = t;  // (not accounting for frame time here)
      Text_CT_T1T1.frameNStart = frameN;  // exact frame index
      
      Text_CT_T1T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (Text_CT_T1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      Text_CT_T1T1.setAutoDraw(false);
    }
    
    // *key_CT_T1T1* updates
    if (t >= 4.2 && key_CT_T1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T1.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T1.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T1.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T1.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T1.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T1.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T1.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T1.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T1_allKeys = _key_CT_T1T1_allKeys.concat(theseKeys);
      if (_key_CT_T1T1_allKeys.length > 0) {
        key_CT_T1T1.keys = _key_CT_T1T1_allKeys[_key_CT_T1T1_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T1.rt = _key_CT_T1T1_allKeys[_key_CT_T1T1_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T1.keys == '1') {
            key_CT_T1T1.corr = 1;
        } else {
            key_CT_T1T1.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T1* updates
    if (t >= 0.0 && phases_CT_T1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T1.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T1.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T1.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT1T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT1T1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT1T1'-------
    CriterionTestT1T1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thuri2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T1.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T1T1.corr = 1;  // correct non-response
      } else {
         key_CT_T1T1.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T1.keys', key_CT_T1T1.keys);
    psychoJS.experiment.addData('key_CT_T1T1.corr', key_CT_T1T1.corr);
    if (typeof key_CT_T1T1.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T1.rt', key_CT_T1T1.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T1.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T2_allKeys;
var CriterionTestT1T2Components;
function CriterionTestT1T2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT1T2'-------
    t = 0;
    CriterionTestT1T2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thano2.secs=4;
    sound_thano2.setVolume(1);
    key_CT_T1T2.keys = undefined;
    key_CT_T1T2.rt = undefined;
    _key_CT_T1T2_allKeys = [];
    // keep track of which components have finished
    CriterionTestT1T2Components = [];
    CriterionTestT1T2Components.push(sound_thano2);
    CriterionTestT1T2Components.push(image_ththami2);
    CriterionTestT1T2Components.push(text_CT_T1T2);
    CriterionTestT1T2Components.push(key_CT_T1T2);
    CriterionTestT1T2Components.push(phases_CT_T1T2);
    
    CriterionTestT1T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT1T2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT1T2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT1T2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thano2
    if (t >= 0.2 && sound_thano2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thano2.tStart = t;  // (not accounting for frame time here)
      sound_thano2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thano2.play(); });  // screen flip
      sound_thano2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thano2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thano2.stop();  // stop the sound (if longer than duration)
        sound_thano2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththami2* updates
    if (t >= 0.2 && image_ththami2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami2.tStart = t;  // (not accounting for frame time here)
      image_ththami2.frameNStart = frameN;  // exact frame index
      
      image_ththami2.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami2.setAutoDraw(false);
    }
    
    // *text_CT_T1T2* updates
    if (t >= 0.0 && text_CT_T1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T2.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T2.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T2.setAutoDraw(false);
    }
    
    // *key_CT_T1T2* updates
    if (t >= 4.2 && key_CT_T1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T2.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T2.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T2.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T2.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T2_allKeys = _key_CT_T1T2_allKeys.concat(theseKeys);
      if (_key_CT_T1T2_allKeys.length > 0) {
        key_CT_T1T2.keys = _key_CT_T1T2_allKeys[_key_CT_T1T2_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T2.rt = _key_CT_T1T2_allKeys[_key_CT_T1T2_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T2.keys == '0') {
            key_CT_T1T2.corr = 1;
        } else {
            key_CT_T1T2.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T2* updates
    if (t >= 0.0 && phases_CT_T1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T2.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T2.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT1T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT1T2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT1T2'-------
    CriterionTestT1T2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thano2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T2.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T1T2.corr = 1;  // correct non-response
      } else {
         key_CT_T1T2.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T2.keys', key_CT_T1T2.keys);
    psychoJS.experiment.addData('key_CT_T1T2.corr', key_CT_T1T2.corr);
    if (typeof key_CT_T1T2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T2.rt', key_CT_T1T2.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T2.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T3_allKeys;
var CriterionTestT1T3Components;
function CriterionTestT1T3RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT1T3'-------
    t = 0;
    CriterionTestT1T3Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththuri3.secs=4;
    sound_ththuri3.setVolume(1);
    key_CT_T1T3.keys = undefined;
    key_CT_T1T3.rt = undefined;
    _key_CT_T1T3_allKeys = [];
    // keep track of which components have finished
    CriterionTestT1T3Components = [];
    CriterionTestT1T3Components.push(sound_ththuri3);
    CriterionTestT1T3Components.push(image_ththuri3);
    CriterionTestT1T3Components.push(text_CT_T1T3);
    CriterionTestT1T3Components.push(key_CT_T1T3);
    CriterionTestT1T3Components.push(phases_CT_T1T3);
    
    CriterionTestT1T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT1T3RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT1T3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT1T3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththuri3
    if (t >= 0.2 && sound_ththuri3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththuri3.tStart = t;  // (not accounting for frame time here)
      sound_ththuri3.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththuri3.play(); });  // screen flip
      sound_ththuri3.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththuri3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththuri3.stop();  // stop the sound (if longer than duration)
        sound_ththuri3.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththuri3* updates
    if (t >= 0.2 && image_ththuri3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri3.tStart = t;  // (not accounting for frame time here)
      image_ththuri3.frameNStart = frameN;  // exact frame index
      
      image_ththuri3.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri3.setAutoDraw(false);
    }
    
    // *text_CT_T1T3* updates
    if (t >= 0.0 && text_CT_T1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T3.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T3.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T3.setAutoDraw(false);
    }
    
    // *key_CT_T1T3* updates
    if (t >= 4.2 && key_CT_T1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T3.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T3.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T3.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T3.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T3.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T3.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T3.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T3.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T3_allKeys = _key_CT_T1T3_allKeys.concat(theseKeys);
      if (_key_CT_T1T3_allKeys.length > 0) {
        key_CT_T1T3.keys = _key_CT_T1T3_allKeys[_key_CT_T1T3_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T3.rt = _key_CT_T1T3_allKeys[_key_CT_T1T3_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T3.keys == '1') {
            key_CT_T1T3.corr = 1;
        } else {
            key_CT_T1T3.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T3* updates
    if (t >= 0.0 && phases_CT_T1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T3.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T3.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT1T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT1T3RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT1T3'-------
    CriterionTestT1T3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththuri3.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T3.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T1T3.corr = 1;  // correct non-response
      } else {
         key_CT_T1T3.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T3.keys', key_CT_T1T3.keys);
    psychoJS.experiment.addData('key_CT_T1T3.corr', key_CT_T1T3.corr);
    if (typeof key_CT_T1T3.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T3.rt', key_CT_T1T3.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T3.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T4_allKeys;
var CriterionTestT1T4Components;
function CriterionTestT1T4RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT1T4'-------
    t = 0;
    CriterionTestT1T4Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thami3.secs=4;
    sound_thami3.setVolume(1);
    key_CT_T1T4.keys = undefined;
    key_CT_T1T4.rt = undefined;
    _key_CT_T1T4_allKeys = [];
    // keep track of which components have finished
    CriterionTestT1T4Components = [];
    CriterionTestT1T4Components.push(sound_thami3);
    CriterionTestT1T4Components.push(image_thami3);
    CriterionTestT1T4Components.push(text_CT_T1T4);
    CriterionTestT1T4Components.push(key_CT_T1T4);
    CriterionTestT1T4Components.push(phases_CT_T1T4);
    
    CriterionTestT1T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT1T4RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT1T4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT1T4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thami3
    if (t >= 0.2 && sound_thami3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thami3.tStart = t;  // (not accounting for frame time here)
      sound_thami3.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thami3.play(); });  // screen flip
      sound_thami3.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thami3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thami3.stop();  // stop the sound (if longer than duration)
        sound_thami3.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thami3* updates
    if (t >= 0.2 && image_thami3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami3.tStart = t;  // (not accounting for frame time here)
      image_thami3.frameNStart = frameN;  // exact frame index
      
      image_thami3.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami3.setAutoDraw(false);
    }
    
    // *text_CT_T1T4* updates
    if (t >= 0.0 && text_CT_T1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T4.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T4.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T4.setAutoDraw(false);
    }
    
    // *key_CT_T1T4* updates
    if (t >= 4.2 && key_CT_T1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T4.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T4.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T4.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T4.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T4_allKeys = _key_CT_T1T4_allKeys.concat(theseKeys);
      if (_key_CT_T1T4_allKeys.length > 0) {
        key_CT_T1T4.keys = _key_CT_T1T4_allKeys[_key_CT_T1T4_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T4.rt = _key_CT_T1T4_allKeys[_key_CT_T1T4_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T4.keys == '1') {
            key_CT_T1T4.corr = 1;
        } else {
            key_CT_T1T4.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T4* updates
    if (t >= 0.0 && phases_CT_T1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T4.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T4.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T4.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT1T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT1T4RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT1T4'-------
    CriterionTestT1T4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thami3.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T4.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T1T4.corr = 1;  // correct non-response
      } else {
         key_CT_T1T4.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T4.keys', key_CT_T1T4.keys);
    psychoJS.experiment.addData('key_CT_T1T4.corr', key_CT_T1T4.corr);
    if (typeof key_CT_T1T4.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T4.rt', key_CT_T1T4.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T4.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T5_allKeys;
var CriteterionTestT1T5Components;
function CriteterionTestT1T5RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriteterionTestT1T5'-------
    t = 0;
    CriteterionTestT1T5Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththano2.secs=4;
    sound_ththano2.setVolume(1);
    key_CT_T1T5.keys = undefined;
    key_CT_T1T5.rt = undefined;
    _key_CT_T1T5_allKeys = [];
    // keep track of which components have finished
    CriteterionTestT1T5Components = [];
    CriteterionTestT1T5Components.push(sound_ththano2);
    CriteterionTestT1T5Components.push(image_thuri3);
    CriteterionTestT1T5Components.push(text_CT_T1T5);
    CriteterionTestT1T5Components.push(key_CT_T1T5);
    CriteterionTestT1T5Components.push(phases_CT_T1T5);
    
    CriteterionTestT1T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriteterionTestT1T5RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriteterionTestT1T5'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriteterionTestT1T5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththano2
    if (t >= 0.2 && sound_ththano2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththano2.tStart = t;  // (not accounting for frame time here)
      sound_ththano2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththano2.play(); });  // screen flip
      sound_ththano2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththano2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththano2.stop();  // stop the sound (if longer than duration)
        sound_ththano2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thuri3* updates
    if (t >= 0.2 && image_thuri3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri3.tStart = t;  // (not accounting for frame time here)
      image_thuri3.frameNStart = frameN;  // exact frame index
      
      image_thuri3.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri3.setAutoDraw(false);
    }
    
    // *text_CT_T1T5* updates
    if (t >= 0.0 && text_CT_T1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T5.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T5.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T5.setAutoDraw(false);
    }
    
    // *key_CT_T1T5* updates
    if (t >= 4.2 && key_CT_T1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T5.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T5.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T5.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T5.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T5_allKeys = _key_CT_T1T5_allKeys.concat(theseKeys);
      if (_key_CT_T1T5_allKeys.length > 0) {
        key_CT_T1T5.keys = _key_CT_T1T5_allKeys[_key_CT_T1T5_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T5.rt = _key_CT_T1T5_allKeys[_key_CT_T1T5_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T5.keys == '0') {
            key_CT_T1T5.corr = 1;
        } else {
            key_CT_T1T5.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T5* updates
    if (t >= 0.0 && phases_CT_T1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T5.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T5.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriteterionTestT1T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriteterionTestT1T5RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriteterionTestT1T5'-------
    CriteterionTestT1T5Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththano2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T5.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T1T5.corr = 1;  // correct non-response
      } else {
         key_CT_T1T5.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T5.keys', key_CT_T1T5.keys);
    psychoJS.experiment.addData('key_CT_T1T5.corr', key_CT_T1T5.corr);
    if (typeof key_CT_T1T5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T5.rt', key_CT_T1T5.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T5.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T6_allKeys;
var CriterionTestT1T6Components;
function CriterionTestT1T6RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT1T6'-------
    t = 0;
    CriterionTestT1T6Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththami3.secs=4;
    sound_ththami3.setVolume(1);
    key_CT_T1T6.keys = undefined;
    key_CT_T1T6.rt = undefined;
    _key_CT_T1T6_allKeys = [];
    // keep track of which components have finished
    CriterionTestT1T6Components = [];
    CriterionTestT1T6Components.push(sound_ththami3);
    CriterionTestT1T6Components.push(image_ththami3);
    CriterionTestT1T6Components.push(text_CT_T1T6);
    CriterionTestT1T6Components.push(key_CT_T1T6);
    CriterionTestT1T6Components.push(phases_CT_T1T6);
    
    CriterionTestT1T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT1T6RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT1T6'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT1T6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththami3
    if (t >= 0.2 && sound_ththami3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththami3.tStart = t;  // (not accounting for frame time here)
      sound_ththami3.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththami3.play(); });  // screen flip
      sound_ththami3.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththami3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththami3.stop();  // stop the sound (if longer than duration)
        sound_ththami3.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththami3* updates
    if (t >= 0.2 && image_ththami3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami3.tStart = t;  // (not accounting for frame time here)
      image_ththami3.frameNStart = frameN;  // exact frame index
      
      image_ththami3.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami3.setAutoDraw(false);
    }
    
    // *text_CT_T1T6* updates
    if (t >= 0.0 && text_CT_T1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T6.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T6.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T6.setAutoDraw(false);
    }
    
    // *key_CT_T1T6* updates
    if (t >= 4.2 && key_CT_T1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T6.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T6.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T6.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T6.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T6.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T6.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T6.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T6.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T6_allKeys = _key_CT_T1T6_allKeys.concat(theseKeys);
      if (_key_CT_T1T6_allKeys.length > 0) {
        key_CT_T1T6.keys = _key_CT_T1T6_allKeys[_key_CT_T1T6_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T6.rt = _key_CT_T1T6_allKeys[_key_CT_T1T6_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T6.keys == '1') {
            key_CT_T1T6.corr = 1;
        } else {
            key_CT_T1T6.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T6* updates
    if (t >= 0.0 && phases_CT_T1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T6.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T6.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T6.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT1T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT1T6RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT1T6'-------
    CriterionTestT1T6Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththami3.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T6.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T1T6.corr = 1;  // correct non-response
      } else {
         key_CT_T1T6.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T6.keys', key_CT_T1T6.keys);
    psychoJS.experiment.addData('key_CT_T1T6.corr', key_CT_T1T6.corr);
    if (typeof key_CT_T1T6.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T6.rt', key_CT_T1T6.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T6.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T7_allKeys;
var CritertionTestT1T7Components;
function CritertionTestT1T7RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CritertionTestT1T7'-------
    t = 0;
    CritertionTestT1T7Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thuri3.secs=4;
    sound_thuri3.setVolume(1);
    key_CT_T1T7.keys = undefined;
    key_CT_T1T7.rt = undefined;
    _key_CT_T1T7_allKeys = [];
    // keep track of which components have finished
    CritertionTestT1T7Components = [];
    CritertionTestT1T7Components.push(sound_thuri3);
    CritertionTestT1T7Components.push(image_ththano2);
    CritertionTestT1T7Components.push(text_CT_T1T7);
    CritertionTestT1T7Components.push(key_CT_T1T7);
    CritertionTestT1T7Components.push(phases_CT_T1T7);
    
    CritertionTestT1T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CritertionTestT1T7RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CritertionTestT1T7'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CritertionTestT1T7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thuri3
    if (t >= 0.2 && sound_thuri3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thuri3.tStart = t;  // (not accounting for frame time here)
      sound_thuri3.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thuri3.play(); });  // screen flip
      sound_thuri3.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thuri3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thuri3.stop();  // stop the sound (if longer than duration)
        sound_thuri3.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththano2* updates
    if (t >= 0.2 && image_ththano2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano2.tStart = t;  // (not accounting for frame time here)
      image_ththano2.frameNStart = frameN;  // exact frame index
      
      image_ththano2.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano2.setAutoDraw(false);
    }
    
    // *text_CT_T1T7* updates
    if (t >= 0.0 && text_CT_T1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T7.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T7.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T7.setAutoDraw(false);
    }
    
    // *key_CT_T1T7* updates
    if (t >= 4.2 && key_CT_T1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T7.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T7.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T7.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T7.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T7.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T7.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T7.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T7.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T7_allKeys = _key_CT_T1T7_allKeys.concat(theseKeys);
      if (_key_CT_T1T7_allKeys.length > 0) {
        key_CT_T1T7.keys = _key_CT_T1T7_allKeys[_key_CT_T1T7_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T7.rt = _key_CT_T1T7_allKeys[_key_CT_T1T7_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T7.keys == '0') {
            key_CT_T1T7.corr = 1;
        } else {
            key_CT_T1T7.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T7* updates
    if (t >= 0.0 && phases_CT_T1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T7.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T7.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T7.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CritertionTestT1T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CritertionTestT1T7RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CritertionTestT1T7'-------
    CritertionTestT1T7Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thuri3.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T7.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T1T7.corr = 1;  // correct non-response
      } else {
         key_CT_T1T7.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T7.keys', key_CT_T1T7.keys);
    psychoJS.experiment.addData('key_CT_T1T7.corr', key_CT_T1T7.corr);
    if (typeof key_CT_T1T7.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T7.rt', key_CT_T1T7.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T7.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T8_allKeys;
var CriterionTestT1T8Components;
function CriterionTestT1T8RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT1T8'-------
    t = 0;
    CriterionTestT1T8Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththuri2.secs=4;
    sound_ththuri2.setVolume(1);
    key_CT_T1T8.keys = undefined;
    key_CT_T1T8.rt = undefined;
    _key_CT_T1T8_allKeys = [];
    // keep track of which components have finished
    CriterionTestT1T8Components = [];
    CriterionTestT1T8Components.push(sound_ththuri2);
    CriterionTestT1T8Components.push(image_thami2);
    CriterionTestT1T8Components.push(text_CT_T1T8);
    CriterionTestT1T8Components.push(key_CT_T1T8);
    CriterionTestT1T8Components.push(phases_CT_T1T8);
    
    CriterionTestT1T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT1T8RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT1T8'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT1T8Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththuri2
    if (t >= 0.2 && sound_ththuri2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththuri2.tStart = t;  // (not accounting for frame time here)
      sound_ththuri2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththuri2.play(); });  // screen flip
      sound_ththuri2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththuri2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththuri2.stop();  // stop the sound (if longer than duration)
        sound_ththuri2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thami2* updates
    if (t >= 0.2 && image_thami2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami2.tStart = t;  // (not accounting for frame time here)
      image_thami2.frameNStart = frameN;  // exact frame index
      
      image_thami2.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami2.setAutoDraw(false);
    }
    
    // *text_CT_T1T8* updates
    if (t >= 0.0 && text_CT_T1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T8.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T8.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T8.setAutoDraw(false);
    }
    
    // *key_CT_T1T8* updates
    if (t >= 4.2 && key_CT_T1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T8.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T8.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T8.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T8.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T8.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T8.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T8.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T8.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T8_allKeys = _key_CT_T1T8_allKeys.concat(theseKeys);
      if (_key_CT_T1T8_allKeys.length > 0) {
        key_CT_T1T8.keys = _key_CT_T1T8_allKeys[_key_CT_T1T8_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T8.rt = _key_CT_T1T8_allKeys[_key_CT_T1T8_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T8.keys == '0') {
            key_CT_T1T8.corr = 1;
        } else {
            key_CT_T1T8.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T8* updates
    if (t >= 0.0 && phases_CT_T1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T8.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T8.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T8.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT1T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT1T8RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT1T8'-------
    CriterionTestT1T8Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththuri2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T8.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T1T8.corr = 1;  // correct non-response
      } else {
         key_CT_T1T8.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T8.keys', key_CT_T1T8.keys);
    psychoJS.experiment.addData('key_CT_T1T8.corr', key_CT_T1T8.corr);
    if (typeof key_CT_T1T8.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T8.rt', key_CT_T1T8.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T8.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T9_allKeys;
var CriterionTestT1T9Components;
function CriterionTestT1T9RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT1T9'-------
    t = 0;
    CriterionTestT1T9Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thano3.secs=4;
    sound_thano3.setVolume(1);
    key_CT_T1T9.keys = undefined;
    key_CT_T1T9.rt = undefined;
    _key_CT_T1T9_allKeys = [];
    // keep track of which components have finished
    CriterionTestT1T9Components = [];
    CriterionTestT1T9Components.push(sound_thano3);
    CriterionTestT1T9Components.push(image_thano3);
    CriterionTestT1T9Components.push(text_CT_T1T9);
    CriterionTestT1T9Components.push(key_CT_T1T9);
    CriterionTestT1T9Components.push(phases_CT_T1T9);
    
    CriterionTestT1T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT1T9RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT1T9'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT1T9Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thano3
    if (t >= 0.2 && sound_thano3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thano3.tStart = t;  // (not accounting for frame time here)
      sound_thano3.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thano3.play(); });  // screen flip
      sound_thano3.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thano3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thano3.stop();  // stop the sound (if longer than duration)
        sound_thano3.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thano3* updates
    if (t >= 0.2 && image_thano3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano3.tStart = t;  // (not accounting for frame time here)
      image_thano3.frameNStart = frameN;  // exact frame index
      
      image_thano3.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano3.setAutoDraw(false);
    }
    
    // *text_CT_T1T9* updates
    if (t >= 0.0 && text_CT_T1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T9.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T9.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T9.setAutoDraw(false);
    }
    
    // *key_CT_T1T9* updates
    if (t >= 4.2 && key_CT_T1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T9.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T9.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T9.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T9.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T9_allKeys = _key_CT_T1T9_allKeys.concat(theseKeys);
      if (_key_CT_T1T9_allKeys.length > 0) {
        key_CT_T1T9.keys = _key_CT_T1T9_allKeys[_key_CT_T1T9_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T9.rt = _key_CT_T1T9_allKeys[_key_CT_T1T9_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T9.keys == '1') {
            key_CT_T1T9.corr = 1;
        } else {
            key_CT_T1T9.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T9* updates
    if (t >= 0.0 && phases_CT_T1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T9.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T9.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T9.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT1T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT1T9RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT1T9'-------
    CriterionTestT1T9Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thano3.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T9.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T1T9.corr = 1;  // correct non-response
      } else {
         key_CT_T1T9.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T9.keys', key_CT_T1T9.keys);
    psychoJS.experiment.addData('key_CT_T1T9.corr', key_CT_T1T9.corr);
    if (typeof key_CT_T1T9.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T9.rt', key_CT_T1T9.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T9.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T10_allKeys;
var CritertionTestT1T10Components;
function CritertionTestT1T10RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CritertionTestT1T10'-------
    t = 0;
    CritertionTestT1T10Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththami2.secs=4;
    sound_ththami2.setVolume(1);
    key_CT_T1T10.keys = undefined;
    key_CT_T1T10.rt = undefined;
    _key_CT_T1T10_allKeys = [];
    // keep track of which components have finished
    CritertionTestT1T10Components = [];
    CritertionTestT1T10Components.push(sound_ththami2);
    CritertionTestT1T10Components.push(image_thano2);
    CritertionTestT1T10Components.push(text_CT_T1T10);
    CritertionTestT1T10Components.push(key_CT_T1T10);
    CritertionTestT1T10Components.push(phases_CT_T1T10);
    
    CritertionTestT1T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CritertionTestT1T10RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CritertionTestT1T10'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CritertionTestT1T10Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththami2
    if (t >= 0.2 && sound_ththami2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththami2.tStart = t;  // (not accounting for frame time here)
      sound_ththami2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththami2.play(); });  // screen flip
      sound_ththami2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththami2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththami2.stop();  // stop the sound (if longer than duration)
        sound_ththami2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thano2* updates
    if (t >= 0.2 && image_thano2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano2.tStart = t;  // (not accounting for frame time here)
      image_thano2.frameNStart = frameN;  // exact frame index
      
      image_thano2.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano2.setAutoDraw(false);
    }
    
    // *text_CT_T1T10* updates
    if (t >= 0.0 && text_CT_T1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T10.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T10.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T10.setAutoDraw(false);
    }
    
    // *key_CT_T1T10* updates
    if (t >= 4.2 && key_CT_T1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T10.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T10.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T10.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T10.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T10_allKeys = _key_CT_T1T10_allKeys.concat(theseKeys);
      if (_key_CT_T1T10_allKeys.length > 0) {
        key_CT_T1T10.keys = _key_CT_T1T10_allKeys[_key_CT_T1T10_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T10.rt = _key_CT_T1T10_allKeys[_key_CT_T1T10_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T10.keys == '0') {
            key_CT_T1T10.corr = 1;
        } else {
            key_CT_T1T10.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T10* updates
    if (t >= 0.0 && phases_CT_T1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T10.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T10.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T10.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CritertionTestT1T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CritertionTestT1T10RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CritertionTestT1T10'-------
    CritertionTestT1T10Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththami2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T10.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T1T10.corr = 1;  // correct non-response
      } else {
         key_CT_T1T10.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T10.keys', key_CT_T1T10.keys);
    psychoJS.experiment.addData('key_CT_T1T10.corr', key_CT_T1T10.corr);
    if (typeof key_CT_T1T10.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T10.rt', key_CT_T1T10.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T10.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T11_allKeys;
var CriterionTestT1T11Components;
function CriterionTestT1T11RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT1T11'-------
    t = 0;
    CriterionTestT1T11Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththano3.secs=4;
    sound_ththano3.setVolume(1);
    key_CT_T1T11.keys = undefined;
    key_CT_T1T11.rt = undefined;
    _key_CT_T1T11_allKeys = [];
    // keep track of which components have finished
    CriterionTestT1T11Components = [];
    CriterionTestT1T11Components.push(sound_ththano3);
    CriterionTestT1T11Components.push(image_ththano3);
    CriterionTestT1T11Components.push(text_CT_T1T11);
    CriterionTestT1T11Components.push(key_CT_T1T11);
    CriterionTestT1T11Components.push(phases_CT_T1T11);
    
    CriterionTestT1T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT1T11RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT1T11'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT1T11Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththano3
    if (t >= 0.2 && sound_ththano3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththano3.tStart = t;  // (not accounting for frame time here)
      sound_ththano3.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththano3.play(); });  // screen flip
      sound_ththano3.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththano3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththano3.stop();  // stop the sound (if longer than duration)
        sound_ththano3.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththano3* updates
    if (t >= 0.2 && image_ththano3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano3.tStart = t;  // (not accounting for frame time here)
      image_ththano3.frameNStart = frameN;  // exact frame index
      
      image_ththano3.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano3.setAutoDraw(false);
    }
    
    // *text_CT_T1T11* updates
    if (t >= 0.0 && text_CT_T1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T11.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T11.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T11.setAutoDraw(false);
    }
    
    // *key_CT_T1T11* updates
    if (t >= 4.2 && key_CT_T1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T11.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T11.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T11.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T11.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T11_allKeys = _key_CT_T1T11_allKeys.concat(theseKeys);
      if (_key_CT_T1T11_allKeys.length > 0) {
        key_CT_T1T11.keys = _key_CT_T1T11_allKeys[_key_CT_T1T11_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T11.rt = _key_CT_T1T11_allKeys[_key_CT_T1T11_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T11.keys == '1') {
            key_CT_T1T11.corr = 1;
        } else {
            key_CT_T1T11.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T11* updates
    if (t >= 0.0 && phases_CT_T1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T11.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T11.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T11.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT1T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT1T11RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT1T11'-------
    CriterionTestT1T11Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththano3.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T11.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T1T11.corr = 1;  // correct non-response
      } else {
         key_CT_T1T11.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T11.keys', key_CT_T1T11.keys);
    psychoJS.experiment.addData('key_CT_T1T11.corr', key_CT_T1T11.corr);
    if (typeof key_CT_T1T11.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T11.rt', key_CT_T1T11.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T11.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T1T12_allKeys;
var CriterionTestT1T12Components;
function CriterionTestT1T12RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT1T12'-------
    t = 0;
    CriterionTestT1T12Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thami2.secs=4;
    sound_thami2.setVolume(1);
    key_CT_T1T12.keys = undefined;
    key_CT_T1T12.rt = undefined;
    _key_CT_T1T12_allKeys = [];
    // keep track of which components have finished
    CriterionTestT1T12Components = [];
    CriterionTestT1T12Components.push(sound_thami2);
    CriterionTestT1T12Components.push(image_ththuri2);
    CriterionTestT1T12Components.push(text_CT_T1T12);
    CriterionTestT1T12Components.push(key_CT_T1T12);
    CriterionTestT1T12Components.push(phases_CT_T1T12);
    
    CriterionTestT1T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT1T12RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT1T12'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT1T12Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thami2
    if (t >= 0.2 && sound_thami2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thami2.tStart = t;  // (not accounting for frame time here)
      sound_thami2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thami2.play(); });  // screen flip
      sound_thami2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thami2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thami2.stop();  // stop the sound (if longer than duration)
        sound_thami2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththuri2* updates
    if (t >= 0.2 && image_ththuri2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri2.tStart = t;  // (not accounting for frame time here)
      image_ththuri2.frameNStart = frameN;  // exact frame index
      
      image_ththuri2.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri2.setAutoDraw(false);
    }
    
    // *text_CT_T1T12* updates
    if (t >= 0.0 && text_CT_T1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T1T12.tStart = t;  // (not accounting for frame time here)
      text_CT_T1T12.frameNStart = frameN;  // exact frame index
      
      text_CT_T1T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T1T12.setAutoDraw(false);
    }
    
    // *key_CT_T1T12* updates
    if (t >= 4.2 && key_CT_T1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T1T12.tStart = t;  // (not accounting for frame time here)
      key_CT_T1T12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T1T12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T1T12.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T1T12.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T1T12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T1T12.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T1T12_allKeys = _key_CT_T1T12_allKeys.concat(theseKeys);
      if (_key_CT_T1T12_allKeys.length > 0) {
        key_CT_T1T12.keys = _key_CT_T1T12_allKeys[_key_CT_T1T12_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T1T12.rt = _key_CT_T1T12_allKeys[_key_CT_T1T12_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T1T12.keys == '0') {
            key_CT_T1T12.corr = 1;
        } else {
            key_CT_T1T12.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T1T12* updates
    if (t >= 0.0 && phases_CT_T1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T1T12.tStart = t;  // (not accounting for frame time here)
      phases_CT_T1T12.frameNStart = frameN;  // exact frame index
      
      phases_CT_T1T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T1T12.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT1T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT1T12RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT1T12'-------
    CriterionTestT1T12Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thami2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T1T12.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T1T12.corr = 1;  // correct non-response
      } else {
         key_CT_T1T12.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T1T12.keys', key_CT_T1T12.keys);
    psychoJS.experiment.addData('key_CT_T1T12.corr', key_CT_T1T12.corr);
    if (typeof key_CT_T1T12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T1T12.rt', key_CT_T1T12.rt);
        routineTimer.reset();
        }
    
    key_CT_T1T12.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CTinstructions2_allKeys;
var Phase3instructions2_2Components;
function Phase3instructions2_2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase3instructions2_2'-------
    t = 0;
    Phase3instructions2_2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_CTinstructions2.keys = undefined;
    key_CTinstructions2.rt = undefined;
    _key_CTinstructions2_allKeys = [];
    // keep track of which components have finished
    Phase3instructions2_2Components = [];
    Phase3instructions2_2Components.push(text_CTinstructions2);
    Phase3instructions2_2Components.push(key_CTinstructions2);
    
    Phase3instructions2_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase3instructions2_2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase3instructions2_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase3instructions2_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_CTinstructions2* updates
    if (t >= 0.0 && text_CTinstructions2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CTinstructions2.tStart = t;  // (not accounting for frame time here)
      text_CTinstructions2.frameNStart = frameN;  // exact frame index
      
      text_CTinstructions2.setAutoDraw(true);
    }

    
    // *key_CTinstructions2* updates
    if (t >= 0.0 && key_CTinstructions2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CTinstructions2.tStart = t;  // (not accounting for frame time here)
      key_CTinstructions2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CTinstructions2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CTinstructions2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CTinstructions2.clearEvents(); });
    }

    if (key_CTinstructions2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CTinstructions2.getKeys({keyList: ['space'], waitRelease: false});
      _key_CTinstructions2_allKeys = _key_CTinstructions2_allKeys.concat(theseKeys);
      if (_key_CTinstructions2_allKeys.length > 0) {
        key_CTinstructions2.keys = _key_CTinstructions2_allKeys[_key_CTinstructions2_allKeys.length - 1].name;  // just the last key pressed
        key_CTinstructions2.rt = _key_CTinstructions2_allKeys[_key_CTinstructions2_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase3instructions2_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase3instructions2_2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase3instructions2_2'-------
    Phase3instructions2_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_CTinstructions2.keys', key_CTinstructions2.keys);
    if (typeof key_CTinstructions2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CTinstructions2.rt', key_CTinstructions2.rt);
        routineTimer.reset();
        }
    
    key_CTinstructions2.stop();
    // the Routine "Phase3instructions2_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T1_allKeys;
var CriterionTestT2T1Components;
function CriterionTestT2T1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T1'-------
    t = 0;
    CriterionTestT2T1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththuri4.secs=4;
    sound_ththuri4.setVolume(1);
    key_CT_T2T1.keys = undefined;
    key_CT_T2T1.rt = undefined;
    _key_CT_T2T1_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T1Components = [];
    CriterionTestT2T1Components.push(image_ththuri4);
    CriterionTestT2T1Components.push(image_thano4);
    CriterionTestT2T1Components.push(text_CT_T2T1_1);
    CriterionTestT2T1Components.push(text_CT_T2T1_0);
    CriterionTestT2T1Components.push(sound_ththuri4);
    CriterionTestT2T1Components.push(text_CT_T2T1);
    CriterionTestT2T1Components.push(key_CT_T2T1);
    CriterionTestT2T1Components.push(phases_CT_T2T1);
    
    CriterionTestT2T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththuri4* updates
    if (t >= 0.2 && image_ththuri4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri4.tStart = t;  // (not accounting for frame time here)
      image_ththuri4.frameNStart = frameN;  // exact frame index
      
      image_ththuri4.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri4.setAutoDraw(false);
    }
    
    // *image_thano4* updates
    if (t >= 0.2 && image_thano4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano4.tStart = t;  // (not accounting for frame time here)
      image_thano4.frameNStart = frameN;  // exact frame index
      
      image_thano4.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano4.setAutoDraw(false);
    }
    
    // *text_CT_T2T1_1* updates
    if (t >= 0.2 && text_CT_T2T1_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T1_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T1_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T1_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T1_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T1_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T1_0* updates
    if (t >= 0.2 && text_CT_T2T1_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T1_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T1_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T1_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T1_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T1_0.setAutoDraw(false);
    }
    // start/stop sound_ththuri4
    if (t >= 0.2 && sound_ththuri4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththuri4.tStart = t;  // (not accounting for frame time here)
      sound_ththuri4.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththuri4.play(); });  // screen flip
      sound_ththuri4.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththuri4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththuri4.stop();  // stop the sound (if longer than duration)
        sound_ththuri4.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T1* updates
    if (t >= 0.0 && text_CT_T2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T1.setAutoDraw(false);
    }
    
    // *key_CT_T2T1* updates
    if (t >= 4.2 && key_CT_T2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T1.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T1.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T1.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T1.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T1.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T1.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T1.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T1.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T1_allKeys = _key_CT_T2T1_allKeys.concat(theseKeys);
      if (_key_CT_T2T1_allKeys.length > 0) {
        key_CT_T2T1.keys = _key_CT_T2T1_allKeys[_key_CT_T2T1_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T1.rt = _key_CT_T2T1_allKeys[_key_CT_T2T1_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T1.keys == '1') {
            key_CT_T2T1.corr = 1;
        } else {
            key_CT_T2T1.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T1* updates
    if (t >= 0.0 && phases_CT_T2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T1.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T1.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T1.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T1'-------
    CriterionTestT2T1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththuri4.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T1.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T2T1.corr = 1;  // correct non-response
      } else {
         key_CT_T2T1.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T1.keys', key_CT_T2T1.keys);
    psychoJS.experiment.addData('key_CT_T2T1.corr', key_CT_T2T1.corr);
    if (typeof key_CT_T2T1.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T1.rt', key_CT_T2T1.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T1.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T2_allKeys;
var CriterionTestT2T2Components;
function CriterionTestT2T2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T2'-------
    t = 0;
    CriterionTestT2T2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththami4.secs=4;
    sound_ththami4.setVolume(1);
    key_CT_T2T2.keys = undefined;
    key_CT_T2T2.rt = undefined;
    _key_CT_T2T2_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T2Components = [];
    CriterionTestT2T2Components.push(image_thuri4);
    CriterionTestT2T2Components.push(image_ththami4);
    CriterionTestT2T2Components.push(text_CT_T2T2_1);
    CriterionTestT2T2Components.push(text_CT_T2T2_0);
    CriterionTestT2T2Components.push(sound_ththami4);
    CriterionTestT2T2Components.push(text_CT_T2T2);
    CriterionTestT2T2Components.push(key_CT_T2T2);
    CriterionTestT2T2Components.push(CT_T2T2);
    
    CriterionTestT2T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_thuri4* updates
    if (t >= 0.2 && image_thuri4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri4.tStart = t;  // (not accounting for frame time here)
      image_thuri4.frameNStart = frameN;  // exact frame index
      
      image_thuri4.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri4.setAutoDraw(false);
    }
    
    // *image_ththami4* updates
    if (t >= 0.2 && image_ththami4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami4.tStart = t;  // (not accounting for frame time here)
      image_ththami4.frameNStart = frameN;  // exact frame index
      
      image_ththami4.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami4.setAutoDraw(false);
    }
    
    // *text_CT_T2T2_1* updates
    if (t >= 0.2 && text_CT_T2T2_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T2_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T2_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T2_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T2_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T2_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T2_0* updates
    if (t >= 0.2 && text_CT_T2T2_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T2_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T2_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T2_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T2_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T2_0.setAutoDraw(false);
    }
    // start/stop sound_ththami4
    if (t >= 0.2 && sound_ththami4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththami4.tStart = t;  // (not accounting for frame time here)
      sound_ththami4.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththami4.play(); });  // screen flip
      sound_ththami4.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththami4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththami4.stop();  // stop the sound (if longer than duration)
        sound_ththami4.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T2* updates
    if (t >= 0 && text_CT_T2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T2.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T2.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T2.setAutoDraw(true);
    }

    frameRemains = 0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T2.setAutoDraw(false);
    }
    
    // *key_CT_T2T2* updates
    if (t >= 0.0 && key_CT_T2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T2.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T2.clearEvents(); });
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T2.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T2.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T2_allKeys = _key_CT_T2T2_allKeys.concat(theseKeys);
      if (_key_CT_T2T2_allKeys.length > 0) {
        key_CT_T2T2.keys = _key_CT_T2T2_allKeys[_key_CT_T2T2_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T2.rt = _key_CT_T2T2_allKeys[_key_CT_T2T2_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T2.keys == '0') {
            key_CT_T2T2.corr = 1;
        } else {
            key_CT_T2T2.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *CT_T2T2* updates
    if (t >= 0.0 && CT_T2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      CT_T2T2.tStart = t;  // (not accounting for frame time here)
      CT_T2T2.frameNStart = frameN;  // exact frame index
      
      CT_T2T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (CT_T2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      CT_T2T2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T2'-------
    CriterionTestT2T2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththami4.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T2.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T2T2.corr = 1;  // correct non-response
      } else {
         key_CT_T2T2.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T2.keys', key_CT_T2T2.keys);
    psychoJS.experiment.addData('key_CT_T2T2.corr', key_CT_T2T2.corr);
    if (typeof key_CT_T2T2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T2.rt', key_CT_T2T2.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T2.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T3_allKeys;
var CriterionTestT2T3Components;
function CriterionTestT2T3RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T3'-------
    t = 0;
    CriterionTestT2T3Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththano4.secs=4;
    sound_ththano4.setVolume(1);
    key_CT_T2T3.keys = undefined;
    key_CT_T2T3.rt = undefined;
    _key_CT_T2T3_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T3Components = [];
    CriterionTestT2T3Components.push(image_ththano4);
    CriterionTestT2T3Components.push(image_thami4);
    CriterionTestT2T3Components.push(text_CT_T2T3_1);
    CriterionTestT2T3Components.push(text_CT_T2T3_0);
    CriterionTestT2T3Components.push(sound_ththano4);
    CriterionTestT2T3Components.push(text_CT_T2T3);
    CriterionTestT2T3Components.push(key_CT_T2T3);
    CriterionTestT2T3Components.push(phases_CT_T2T3);
    
    CriterionTestT2T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T3RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththano4* updates
    if (t >= 0.2 && image_ththano4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano4.tStart = t;  // (not accounting for frame time here)
      image_ththano4.frameNStart = frameN;  // exact frame index
      
      image_ththano4.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano4.setAutoDraw(false);
    }
    
    // *image_thami4* updates
    if (t >= 0.2 && image_thami4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami4.tStart = t;  // (not accounting for frame time here)
      image_thami4.frameNStart = frameN;  // exact frame index
      
      image_thami4.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami4.setAutoDraw(false);
    }
    
    // *text_CT_T2T3_1* updates
    if (t >= 0.2 && text_CT_T2T3_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T3_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T3_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T3_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T3_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T3_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T3_0* updates
    if (t >= 0.2 && text_CT_T2T3_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T3_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T3_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T3_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T3_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T3_0.setAutoDraw(false);
    }
    // start/stop sound_ththano4
    if (t >= 0.2 && sound_ththano4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththano4.tStart = t;  // (not accounting for frame time here)
      sound_ththano4.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththano4.play(); });  // screen flip
      sound_ththano4.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththano4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththano4.stop();  // stop the sound (if longer than duration)
        sound_ththano4.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T3* updates
    if (t >= 0.0 && text_CT_T2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T3.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T3.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T3.setAutoDraw(false);
    }
    
    // *key_CT_T2T3* updates
    if (t >= 4.2 && key_CT_T2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T3.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T3.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T3.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T3.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T3.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T3.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T3.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T3.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T3_allKeys = _key_CT_T2T3_allKeys.concat(theseKeys);
      if (_key_CT_T2T3_allKeys.length > 0) {
        key_CT_T2T3.keys = _key_CT_T2T3_allKeys[_key_CT_T2T3_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T3.rt = _key_CT_T2T3_allKeys[_key_CT_T2T3_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T3.keys == '1') {
            key_CT_T2T3.corr = 1;
        } else {
            key_CT_T2T3.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T3* updates
    if (t >= 0.0 && phases_CT_T2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T3.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T3.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T3RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T3'-------
    CriterionTestT2T3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththano4.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T3.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T2T3.corr = 1;  // correct non-response
      } else {
         key_CT_T2T3.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T3.keys', key_CT_T2T3.keys);
    psychoJS.experiment.addData('key_CT_T2T3.corr', key_CT_T2T3.corr);
    if (typeof key_CT_T2T3.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T3.rt', key_CT_T2T3.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T3.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T4_allKeys;
var CriterionTestT3T4Components;
function CriterionTestT3T4RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT3T4'-------
    t = 0;
    CriterionTestT3T4Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththami5.secs=4;
    sound_ththami5.setVolume(1);
    key_CT_T2T4.keys = undefined;
    key_CT_T2T4.rt = undefined;
    _key_CT_T2T4_allKeys = [];
    // keep track of which components have finished
    CriterionTestT3T4Components = [];
    CriterionTestT3T4Components.push(image_ththami5);
    CriterionTestT3T4Components.push(image_thano5);
    CriterionTestT3T4Components.push(text_CT_T2T4_1);
    CriterionTestT3T4Components.push(text_CT_T2T4_0);
    CriterionTestT3T4Components.push(sound_ththami5);
    CriterionTestT3T4Components.push(text_CT_T2T4);
    CriterionTestT3T4Components.push(key_CT_T2T4);
    CriterionTestT3T4Components.push(phases_CT_T2T4);
    
    CriterionTestT3T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT3T4RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT3T4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT3T4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththami5* updates
    if (t >= 0.2 && image_ththami5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami5.tStart = t;  // (not accounting for frame time here)
      image_ththami5.frameNStart = frameN;  // exact frame index
      
      image_ththami5.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami5.setAutoDraw(false);
    }
    
    // *image_thano5* updates
    if (t >= 0.2 && image_thano5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano5.tStart = t;  // (not accounting for frame time here)
      image_thano5.frameNStart = frameN;  // exact frame index
      
      image_thano5.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano5.setAutoDraw(false);
    }
    
    // *text_CT_T2T4_1* updates
    if (t >= 0.2 && text_CT_T2T4_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T4_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T4_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T4_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T4_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T4_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T4_0* updates
    if (t >= 0.2 && text_CT_T2T4_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T4_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T4_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T4_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T4_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T4_0.setAutoDraw(false);
    }
    // start/stop sound_ththami5
    if (t >= 0.2 && sound_ththami5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththami5.tStart = t;  // (not accounting for frame time here)
      sound_ththami5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththami5.play(); });  // screen flip
      sound_ththami5.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththami5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththami5.stop();  // stop the sound (if longer than duration)
        sound_ththami5.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T4* updates
    if (t >= 0 && text_CT_T2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T4.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T4.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T4.setAutoDraw(true);
    }

    frameRemains = 0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T4.setAutoDraw(false);
    }
    
    // *key_CT_T2T4* updates
    if (t >= 0.0 && key_CT_T2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T4.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T4.clearEvents(); });
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T4.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T4.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T4_allKeys = _key_CT_T2T4_allKeys.concat(theseKeys);
      if (_key_CT_T2T4_allKeys.length > 0) {
        key_CT_T2T4.keys = _key_CT_T2T4_allKeys[_key_CT_T2T4_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T4.rt = _key_CT_T2T4_allKeys[_key_CT_T2T4_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T4.keys == '1') {
            key_CT_T2T4.corr = 1;
        } else {
            key_CT_T2T4.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T4* updates
    if (t >= 0.0 && phases_CT_T2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T4.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T4.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T4.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT3T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT3T4RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT3T4'-------
    CriterionTestT3T4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththami5.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T4.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T2T4.corr = 1;  // correct non-response
      } else {
         key_CT_T2T4.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T4.keys', key_CT_T2T4.keys);
    psychoJS.experiment.addData('key_CT_T2T4.corr', key_CT_T2T4.corr);
    if (typeof key_CT_T2T4.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T4.rt', key_CT_T2T4.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T4.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T5_allKeys;
var CriterionTestT2T5Components;
function CriterionTestT2T5RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T5'-------
    t = 0;
    CriterionTestT2T5Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththuri5.secs=4;
    sound_ththuri5.setVolume(1);
    key_CT_T2T5.keys = undefined;
    key_CT_T2T5.rt = undefined;
    _key_CT_T2T5_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T5Components = [];
    CriterionTestT2T5Components.push(image_thami5);
    CriterionTestT2T5Components.push(image_ththuri5);
    CriterionTestT2T5Components.push(text_CT_T2T5_1);
    CriterionTestT2T5Components.push(text_CT_T2T5_0);
    CriterionTestT2T5Components.push(sound_ththuri5);
    CriterionTestT2T5Components.push(text_CT_T2T5);
    CriterionTestT2T5Components.push(key_CT_T2T5);
    CriterionTestT2T5Components.push(phases_CT_T2T5);
    
    CriterionTestT2T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T5RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T5'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_thami5* updates
    if (t >= 0.2 && image_thami5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami5.tStart = t;  // (not accounting for frame time here)
      image_thami5.frameNStart = frameN;  // exact frame index
      
      image_thami5.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami5.setAutoDraw(false);
    }
    
    // *image_ththuri5* updates
    if (t >= 0.2 && image_ththuri5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri5.tStart = t;  // (not accounting for frame time here)
      image_ththuri5.frameNStart = frameN;  // exact frame index
      
      image_ththuri5.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri5.setAutoDraw(false);
    }
    
    // *text_CT_T2T5_1* updates
    if (t >= 0.2 && text_CT_T2T5_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T5_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T5_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T5_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T5_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T5_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T5_0* updates
    if (t >= 0.2 && text_CT_T2T5_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T5_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T5_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T5_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T5_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T5_0.setAutoDraw(false);
    }
    // start/stop sound_ththuri5
    if (t >= 0.2 && sound_ththuri5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththuri5.tStart = t;  // (not accounting for frame time here)
      sound_ththuri5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththuri5.play(); });  // screen flip
      sound_ththuri5.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththuri5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththuri5.stop();  // stop the sound (if longer than duration)
        sound_ththuri5.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T5* updates
    if (t >= 0.0 && text_CT_T2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T5.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T5.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T5.setAutoDraw(false);
    }
    
    // *key_CT_T2T5* updates
    if (t >= 4.2 && key_CT_T2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T5.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T5.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T5.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T5.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T5_allKeys = _key_CT_T2T5_allKeys.concat(theseKeys);
      if (_key_CT_T2T5_allKeys.length > 0) {
        key_CT_T2T5.keys = _key_CT_T2T5_allKeys[_key_CT_T2T5_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T5.rt = _key_CT_T2T5_allKeys[_key_CT_T2T5_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T5.keys == '0') {
            key_CT_T2T5.corr = 1;
        } else {
            key_CT_T2T5.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T5* updates
    if (t >= 0.0 && phases_CT_T2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T5.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T5.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T5RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T5'-------
    CriterionTestT2T5Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththuri5.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T5.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T2T5.corr = 1;  // correct non-response
      } else {
         key_CT_T2T5.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T5.keys', key_CT_T2T5.keys);
    psychoJS.experiment.addData('key_CT_T2T5.corr', key_CT_T2T5.corr);
    if (typeof key_CT_T2T5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T5.rt', key_CT_T2T5.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T5.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T6_allKeys;
var CriterionTestT2T6Components;
function CriterionTestT2T6RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T6'-------
    t = 0;
    CriterionTestT2T6Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththano5.secs=4;
    sound_ththano5.setVolume(1);
    key_CT_T2T6.keys = undefined;
    key_CT_T2T6.rt = undefined;
    _key_CT_T2T6_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T6Components = [];
    CriterionTestT2T6Components.push(image_ththano5);
    CriterionTestT2T6Components.push(image_thuri5);
    CriterionTestT2T6Components.push(text_CT_T2T6_1);
    CriterionTestT2T6Components.push(text_CT_T2T6_0);
    CriterionTestT2T6Components.push(sound_ththano5);
    CriterionTestT2T6Components.push(text_CT_T2T6);
    CriterionTestT2T6Components.push(key_CT_T2T6);
    CriterionTestT2T6Components.push(phases_CT_T2T6);
    
    CriterionTestT2T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T6RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T6'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththano5* updates
    if (t >= 0.2 && image_ththano5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano5.tStart = t;  // (not accounting for frame time here)
      image_ththano5.frameNStart = frameN;  // exact frame index
      
      image_ththano5.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano5.setAutoDraw(false);
    }
    
    // *image_thuri5* updates
    if (t >= 0.2 && image_thuri5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri5.tStart = t;  // (not accounting for frame time here)
      image_thuri5.frameNStart = frameN;  // exact frame index
      
      image_thuri5.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri5.setAutoDraw(false);
    }
    
    // *text_CT_T2T6_1* updates
    if (t >= 0.2 && text_CT_T2T6_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T6_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T6_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T6_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T6_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T6_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T6_0* updates
    if (t >= 0.2 && text_CT_T2T6_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T6_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T6_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T6_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T6_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T6_0.setAutoDraw(false);
    }
    // start/stop sound_ththano5
    if (t >= 0.2 && sound_ththano5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththano5.tStart = t;  // (not accounting for frame time here)
      sound_ththano5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththano5.play(); });  // screen flip
      sound_ththano5.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththano5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththano5.stop();  // stop the sound (if longer than duration)
        sound_ththano5.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T6* updates
    if (t >= 0.0 && text_CT_T2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T6.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T6.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T6.setAutoDraw(false);
    }
    
    // *key_CT_T2T6* updates
    if (t >= 4.2 && key_CT_T2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T6.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T6.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T6.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T6.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T6.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T6.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T6.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T6.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T6_allKeys = _key_CT_T2T6_allKeys.concat(theseKeys);
      if (_key_CT_T2T6_allKeys.length > 0) {
        key_CT_T2T6.keys = _key_CT_T2T6_allKeys[_key_CT_T2T6_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T6.rt = _key_CT_T2T6_allKeys[_key_CT_T2T6_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T6.keys == '1') {
            key_CT_T2T6.corr = 1;
        } else {
            key_CT_T2T6.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T6* updates
    if (t >= 0.0 && phases_CT_T2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T6.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T6.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T6.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T6RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T6'-------
    CriterionTestT2T6Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththano5.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T6.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T2T6.corr = 1;  // correct non-response
      } else {
         key_CT_T2T6.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T6.keys', key_CT_T2T6.keys);
    psychoJS.experiment.addData('key_CT_T2T6.corr', key_CT_T2T6.corr);
    if (typeof key_CT_T2T6.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T6.rt', key_CT_T2T6.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T6.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T7_allKeys;
var CriterionTestT2T7Components;
function CriterionTestT2T7RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T7'-------
    t = 0;
    CriterionTestT2T7Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thuri5.secs=4;
    sound_thuri5.setVolume(1);
    key_CT_T2T7.keys = undefined;
    key_CT_T2T7.rt = undefined;
    _key_CT_T2T7_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T7Components = [];
    CriterionTestT2T7Components.push(image_ththami6);
    CriterionTestT2T7Components.push(image_thuri6);
    CriterionTestT2T7Components.push(text_CT_T2T7_1);
    CriterionTestT2T7Components.push(text_CT_T2T7_0);
    CriterionTestT2T7Components.push(sound_thuri5);
    CriterionTestT2T7Components.push(text_CT_T2T7);
    CriterionTestT2T7Components.push(key_CT_T2T7);
    CriterionTestT2T7Components.push(phases_CT_T2T7);
    
    CriterionTestT2T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T7RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T7'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththami6* updates
    if (t >= 0.2 && image_ththami6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami6.tStart = t;  // (not accounting for frame time here)
      image_ththami6.frameNStart = frameN;  // exact frame index
      
      image_ththami6.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami6.setAutoDraw(false);
    }
    
    // *image_thuri6* updates
    if (t >= 0.2 && image_thuri6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri6.tStart = t;  // (not accounting for frame time here)
      image_thuri6.frameNStart = frameN;  // exact frame index
      
      image_thuri6.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri6.setAutoDraw(false);
    }
    
    // *text_CT_T2T7_1* updates
    if (t >= 0.2 && text_CT_T2T7_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T7_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T7_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T7_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T7_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T7_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T7_0* updates
    if (t >= 0.2 && text_CT_T2T7_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T7_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T7_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T7_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T7_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T7_0.setAutoDraw(false);
    }
    // start/stop sound_thuri5
    if (t >= 0.2 && sound_thuri5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thuri5.tStart = t;  // (not accounting for frame time here)
      sound_thuri5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thuri5.play(); });  // screen flip
      sound_thuri5.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thuri5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thuri5.stop();  // stop the sound (if longer than duration)
        sound_thuri5.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T7* updates
    if (t >= 0.0 && text_CT_T2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T7.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T7.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T7.setAutoDraw(false);
    }
    
    // *key_CT_T2T7* updates
    if (t >= 4.2 && key_CT_T2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T7.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T7.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T7.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T7.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T7.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T7.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T7.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T7.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T7_allKeys = _key_CT_T2T7_allKeys.concat(theseKeys);
      if (_key_CT_T2T7_allKeys.length > 0) {
        key_CT_T2T7.keys = _key_CT_T2T7_allKeys[_key_CT_T2T7_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T7.rt = _key_CT_T2T7_allKeys[_key_CT_T2T7_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T7.keys == '0') {
            key_CT_T2T7.corr = 1;
        } else {
            key_CT_T2T7.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T7* updates
    if (t >= 0.0 && phases_CT_T2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T7.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T7.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T7.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T7RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T7'-------
    CriterionTestT2T7Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thuri5.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T7.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T2T7.corr = 1;  // correct non-response
      } else {
         key_CT_T2T7.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T7.keys', key_CT_T2T7.keys);
    psychoJS.experiment.addData('key_CT_T2T7.corr', key_CT_T2T7.corr);
    if (typeof key_CT_T2T7.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T7.rt', key_CT_T2T7.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T7.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T8_allKeys;
var CriterionTestT2T8Components;
function CriterionTestT2T8RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T8'-------
    t = 0;
    CriterionTestT2T8Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thami4.secs=4;
    sound_thami4.setVolume(1);
    key_CT_T2T8.keys = undefined;
    key_CT_T2T8.rt = undefined;
    _key_CT_T2T8_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T8Components = [];
    CriterionTestT2T8Components.push(image_ththano6);
    CriterionTestT2T8Components.push(image_thami6);
    CriterionTestT2T8Components.push(text_CT_T2T8_1);
    CriterionTestT2T8Components.push(text_CT_T2T8_0);
    CriterionTestT2T8Components.push(sound_thami4);
    CriterionTestT2T8Components.push(text_CT_T2T8);
    CriterionTestT2T8Components.push(key_CT_T2T8);
    CriterionTestT2T8Components.push(phases_CT_T2T8);
    
    CriterionTestT2T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T8RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T8'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T8Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththano6* updates
    if (t >= 0.2 && image_ththano6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano6.tStart = t;  // (not accounting for frame time here)
      image_ththano6.frameNStart = frameN;  // exact frame index
      
      image_ththano6.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano6.setAutoDraw(false);
    }
    
    // *image_thami6* updates
    if (t >= 0.2 && image_thami6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami6.tStart = t;  // (not accounting for frame time here)
      image_thami6.frameNStart = frameN;  // exact frame index
      
      image_thami6.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami6.setAutoDraw(false);
    }
    
    // *text_CT_T2T8_1* updates
    if (t >= 0.2 && text_CT_T2T8_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T8_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T8_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T8_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T8_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T8_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T8_0* updates
    if (t >= 0.2 && text_CT_T2T8_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T8_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T8_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T8_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T8_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T8_0.setAutoDraw(false);
    }
    // start/stop sound_thami4
    if (t >= 0.2 && sound_thami4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thami4.tStart = t;  // (not accounting for frame time here)
      sound_thami4.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thami4.play(); });  // screen flip
      sound_thami4.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thami4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thami4.stop();  // stop the sound (if longer than duration)
        sound_thami4.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T8* updates
    if (t >= 0.0 && text_CT_T2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T8.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T8.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T8.setAutoDraw(false);
    }
    
    // *key_CT_T2T8* updates
    if (t >= 4.2 && key_CT_T2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T8.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T8.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T8.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T8.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T8.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T8.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T8.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T8.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T8_allKeys = _key_CT_T2T8_allKeys.concat(theseKeys);
      if (_key_CT_T2T8_allKeys.length > 0) {
        key_CT_T2T8.keys = _key_CT_T2T8_allKeys[_key_CT_T2T8_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T8.rt = _key_CT_T2T8_allKeys[_key_CT_T2T8_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T8.keys == '0') {
            key_CT_T2T8.corr = 1;
        } else {
            key_CT_T2T8.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T8* updates
    if (t >= 0.0 && phases_CT_T2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T8.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T8.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T8.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T8RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T8'-------
    CriterionTestT2T8Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thami4.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T8.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T2T8.corr = 1;  // correct non-response
      } else {
         key_CT_T2T8.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T8.keys', key_CT_T2T8.keys);
    psychoJS.experiment.addData('key_CT_T2T8.corr', key_CT_T2T8.corr);
    if (typeof key_CT_T2T8.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T8.rt', key_CT_T2T8.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T8.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T9_allKeys;
var CriterionTestT2T9Components;
function CriterionTestT2T9RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T9'-------
    t = 0;
    CriterionTestT2T9Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thano4.secs=4;
    sound_thano4.setVolume(1);
    key_CT_T2T9.keys = undefined;
    key_CT_T2T9.rt = undefined;
    _key_CT_T2T9_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T9Components = [];
    CriterionTestT2T9Components.push(image_ththuri6);
    CriterionTestT2T9Components.push(image_thano6);
    CriterionTestT2T9Components.push(text_CT_T2T9_1);
    CriterionTestT2T9Components.push(text_CT_T2T9_0);
    CriterionTestT2T9Components.push(sound_thano4);
    CriterionTestT2T9Components.push(text_CT_T2T9);
    CriterionTestT2T9Components.push(key_CT_T2T9);
    CriterionTestT2T9Components.push(phases_CT_T2T9);
    
    CriterionTestT2T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T9RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T9'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T9Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththuri6* updates
    if (t >= 0.2 && image_ththuri6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri6.tStart = t;  // (not accounting for frame time here)
      image_ththuri6.frameNStart = frameN;  // exact frame index
      
      image_ththuri6.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri6.setAutoDraw(false);
    }
    
    // *image_thano6* updates
    if (t >= 0.2 && image_thano6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano6.tStart = t;  // (not accounting for frame time here)
      image_thano6.frameNStart = frameN;  // exact frame index
      
      image_thano6.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano6.setAutoDraw(false);
    }
    
    // *text_CT_T2T9_1* updates
    if (t >= 0.2 && text_CT_T2T9_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T9_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T9_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T9_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T9_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T9_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T9_0* updates
    if (t >= 0.2 && text_CT_T2T9_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T9_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T9_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T9_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T9_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T9_0.setAutoDraw(false);
    }
    // start/stop sound_thano4
    if (t >= 0.2 && sound_thano4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thano4.tStart = t;  // (not accounting for frame time here)
      sound_thano4.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thano4.play(); });  // screen flip
      sound_thano4.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thano4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thano4.stop();  // stop the sound (if longer than duration)
        sound_thano4.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T9* updates
    if (t >= 0.0 && text_CT_T2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T9.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T9.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T9.setAutoDraw(false);
    }
    
    // *key_CT_T2T9* updates
    if (t >= 4.2 && key_CT_T2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T9.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T9.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T9.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T9.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T9_allKeys = _key_CT_T2T9_allKeys.concat(theseKeys);
      if (_key_CT_T2T9_allKeys.length > 0) {
        key_CT_T2T9.keys = _key_CT_T2T9_allKeys[_key_CT_T2T9_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T9.rt = _key_CT_T2T9_allKeys[_key_CT_T2T9_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T9.keys == '0') {
            key_CT_T2T9.corr = 1;
        } else {
            key_CT_T2T9.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T9* updates
    if (t >= 0.0 && phases_CT_T2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T9.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T9.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T9.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T9RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T9'-------
    CriterionTestT2T9Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thano4.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T9.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T2T9.corr = 1;  // correct non-response
      } else {
         key_CT_T2T9.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T9.keys', key_CT_T2T9.keys);
    psychoJS.experiment.addData('key_CT_T2T9.corr', key_CT_T2T9.corr);
    if (typeof key_CT_T2T9.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T9.rt', key_CT_T2T9.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T9.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T10_allKeys;
var CriterionTestT2T10Components;
function CriterionTestT2T10RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T10'-------
    t = 0;
    CriterionTestT2T10Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thuri4.secs=4;
    sound_thuri4.setVolume(1);
    key_CT_T2T10.keys = undefined;
    key_CT_T2T10.rt = undefined;
    _key_CT_T2T10_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T10Components = [];
    CriterionTestT2T10Components.push(image_thuri7);
    CriterionTestT2T10Components.push(image_ththano7);
    CriterionTestT2T10Components.push(text_CT_T2T10_1);
    CriterionTestT2T10Components.push(text_CT_T2T10_0);
    CriterionTestT2T10Components.push(sound_thuri4);
    CriterionTestT2T10Components.push(text_CT_T2T10);
    CriterionTestT2T10Components.push(key_CT_T2T10);
    CriterionTestT2T10Components.push(phases_CT_T2T10);
    
    CriterionTestT2T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T10RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T10'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T10Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_thuri7* updates
    if (t >= 0.2 && image_thuri7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri7.tStart = t;  // (not accounting for frame time here)
      image_thuri7.frameNStart = frameN;  // exact frame index
      
      image_thuri7.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri7.setAutoDraw(false);
    }
    
    // *image_ththano7* updates
    if (t >= 0.2 && image_ththano7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano7.tStart = t;  // (not accounting for frame time here)
      image_ththano7.frameNStart = frameN;  // exact frame index
      
      image_ththano7.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano7.setAutoDraw(false);
    }
    
    // *text_CT_T2T10_1* updates
    if (t >= 0.2 && text_CT_T2T10_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T10_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T10_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T10_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T10_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T10_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T10_0* updates
    if (t >= 0.2 && text_CT_T2T10_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T10_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T10_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T10_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T10_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T10_0.setAutoDraw(false);
    }
    // start/stop sound_thuri4
    if (t >= 0.2 && sound_thuri4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thuri4.tStart = t;  // (not accounting for frame time here)
      sound_thuri4.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thuri4.play(); });  // screen flip
      sound_thuri4.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thuri4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thuri4.stop();  // stop the sound (if longer than duration)
        sound_thuri4.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T10* updates
    if (t >= 0.0 && text_CT_T2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T10.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T10.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T10.setAutoDraw(false);
    }
    
    // *key_CT_T2T10* updates
    if (t >= 4.2 && key_CT_T2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T10.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T10.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T10.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T10.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T10_allKeys = _key_CT_T2T10_allKeys.concat(theseKeys);
      if (_key_CT_T2T10_allKeys.length > 0) {
        key_CT_T2T10.keys = _key_CT_T2T10_allKeys[_key_CT_T2T10_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T10.rt = _key_CT_T2T10_allKeys[_key_CT_T2T10_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T10.keys == '1') {
            key_CT_T2T10.corr = 1;
        } else {
            key_CT_T2T10.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T10* updates
    if (t >= 0.0 && phases_CT_T2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T10.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T10.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T10.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T10RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T10'-------
    CriterionTestT2T10Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thuri4.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T10.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T2T10.corr = 1;  // correct non-response
      } else {
         key_CT_T2T10.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T10.keys', key_CT_T2T10.keys);
    psychoJS.experiment.addData('key_CT_T2T10.corr', key_CT_T2T10.corr);
    if (typeof key_CT_T2T10.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T10.rt', key_CT_T2T10.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T10.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T11_allKeys;
var CriterionTestT2T11Components;
function CriterionTestT2T11RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T11'-------
    t = 0;
    CriterionTestT2T11Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thano5.secs=4;
    sound_thano5.setVolume(1);
    key_CT_T2T11.keys = undefined;
    key_CT_T2T11.rt = undefined;
    _key_CT_T2T11_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T11Components = [];
    CriterionTestT2T11Components.push(image_ththami7);
    CriterionTestT2T11Components.push(image_thano7);
    CriterionTestT2T11Components.push(text_CT_T2T11_1);
    CriterionTestT2T11Components.push(text_CT_T2T11_0);
    CriterionTestT2T11Components.push(sound_thano5);
    CriterionTestT2T11Components.push(text_CT_T2T11);
    CriterionTestT2T11Components.push(key_CT_T2T11);
    CriterionTestT2T11Components.push(phases_CT_T2T11);
    
    CriterionTestT2T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T11RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T11'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T11Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththami7* updates
    if (t >= 0.2 && image_ththami7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami7.tStart = t;  // (not accounting for frame time here)
      image_ththami7.frameNStart = frameN;  // exact frame index
      
      image_ththami7.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami7.setAutoDraw(false);
    }
    
    // *image_thano7* updates
    if (t >= 0.2 && image_thano7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano7.tStart = t;  // (not accounting for frame time here)
      image_thano7.frameNStart = frameN;  // exact frame index
      
      image_thano7.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano7.setAutoDraw(false);
    }
    
    // *text_CT_T2T11_1* updates
    if (t >= 0.2 && text_CT_T2T11_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T11_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T11_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T11_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T11_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T11_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T11_0* updates
    if (t >= 0.2 && text_CT_T2T11_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T11_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T11_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T11_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T11_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T11_0.setAutoDraw(false);
    }
    // start/stop sound_thano5
    if (t >= 0.2 && sound_thano5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thano5.tStart = t;  // (not accounting for frame time here)
      sound_thano5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thano5.play(); });  // screen flip
      sound_thano5.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thano5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thano5.stop();  // stop the sound (if longer than duration)
        sound_thano5.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T11* updates
    if (t >= 0.0 && text_CT_T2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T11.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T11.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T11.setAutoDraw(false);
    }
    
    // *key_CT_T2T11* updates
    if (t >= 4.2 && key_CT_T2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T11.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T11.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T11.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T11.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T11_allKeys = _key_CT_T2T11_allKeys.concat(theseKeys);
      if (_key_CT_T2T11_allKeys.length > 0) {
        key_CT_T2T11.keys = _key_CT_T2T11_allKeys[_key_CT_T2T11_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T11.rt = _key_CT_T2T11_allKeys[_key_CT_T2T11_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T11.keys == '0') {
            key_CT_T2T11.corr = 1;
        } else {
            key_CT_T2T11.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T11* updates
    if (t >= 0.0 && phases_CT_T2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T11.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T11.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T11.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T11RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T11'-------
    CriterionTestT2T11Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thano5.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T11.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_CT_T2T11.corr = 1;  // correct non-response
      } else {
         key_CT_T2T11.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T11.keys', key_CT_T2T11.keys);
    psychoJS.experiment.addData('key_CT_T2T11.corr', key_CT_T2T11.corr);
    if (typeof key_CT_T2T11.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T11.rt', key_CT_T2T11.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T11.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_CT_T2T12_allKeys;
var CriterionTestT2T12Components;
function CriterionTestT2T12RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'CriterionTestT2T12'-------
    t = 0;
    CriterionTestT2T12Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thami5.secs=4;
    sound_thami5.setVolume(1);
    key_CT_T2T12.keys = undefined;
    key_CT_T2T12.rt = undefined;
    _key_CT_T2T12_allKeys = [];
    // keep track of which components have finished
    CriterionTestT2T12Components = [];
    CriterionTestT2T12Components.push(image_thami7);
    CriterionTestT2T12Components.push(image_ththuri7);
    CriterionTestT2T12Components.push(text_CT_T2T12_1);
    CriterionTestT2T12Components.push(text_CT_T2T12_0);
    CriterionTestT2T12Components.push(sound_thami5);
    CriterionTestT2T12Components.push(text_CT_T2T12);
    CriterionTestT2T12Components.push(key_CT_T2T12);
    CriterionTestT2T12Components.push(phases_CT_T2T12);
    
    CriterionTestT2T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function CriterionTestT2T12RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'CriterionTestT2T12'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = CriterionTestT2T12Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_thami7* updates
    if (t >= 0.2 && image_thami7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami7.tStart = t;  // (not accounting for frame time here)
      image_thami7.frameNStart = frameN;  // exact frame index
      
      image_thami7.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami7.setAutoDraw(false);
    }
    
    // *image_ththuri7* updates
    if (t >= 0.2 && image_ththuri7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri7.tStart = t;  // (not accounting for frame time here)
      image_ththuri7.frameNStart = frameN;  // exact frame index
      
      image_ththuri7.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri7.setAutoDraw(false);
    }
    
    // *text_CT_T2T12_1* updates
    if (t >= 0.2 && text_CT_T2T12_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T12_1.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T12_1.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T12_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T12_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T12_1.setAutoDraw(false);
    }
    
    // *text_CT_T2T12_0* updates
    if (t >= 0.2 && text_CT_T2T12_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T12_0.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T12_0.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T12_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T12_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T12_0.setAutoDraw(false);
    }
    // start/stop sound_thami5
    if (t >= 0.2 && sound_thami5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thami5.tStart = t;  // (not accounting for frame time here)
      sound_thami5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thami5.play(); });  // screen flip
      sound_thami5.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thami5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thami5.stop();  // stop the sound (if longer than duration)
        sound_thami5.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_CT_T2T12* updates
    if (t >= 0.0 && text_CT_T2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_CT_T2T12.tStart = t;  // (not accounting for frame time here)
      text_CT_T2T12.frameNStart = frameN;  // exact frame index
      
      text_CT_T2T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_CT_T2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_CT_T2T12.setAutoDraw(false);
    }
    
    // *key_CT_T2T12* updates
    if (t >= 4.2 && key_CT_T2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_CT_T2T12.tStart = t;  // (not accounting for frame time here)
      key_CT_T2T12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_CT_T2T12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_CT_T2T12.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_CT_T2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_CT_T2T12.status = PsychoJS.Status.FINISHED;
  }

    if (key_CT_T2T12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_CT_T2T12.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_CT_T2T12_allKeys = _key_CT_T2T12_allKeys.concat(theseKeys);
      if (_key_CT_T2T12_allKeys.length > 0) {
        key_CT_T2T12.keys = _key_CT_T2T12_allKeys[_key_CT_T2T12_allKeys.length - 1].name;  // just the last key pressed
        key_CT_T2T12.rt = _key_CT_T2T12_allKeys[_key_CT_T2T12_allKeys.length - 1].rt;
        // was this correct?
        if (key_CT_T2T12.keys == '1') {
            key_CT_T2T12.corr = 1;
        } else {
            key_CT_T2T12.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_CT_T2T12* updates
    if (t >= 0.0 && phases_CT_T2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_CT_T2T12.tStart = t;  // (not accounting for frame time here)
      phases_CT_T2T12.frameNStart = frameN;  // exact frame index
      
      phases_CT_T2T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_CT_T2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_CT_T2T12.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    CriterionTestT2T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function CriterionTestT2T12RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'CriterionTestT2T12'-------
    CriterionTestT2T12Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thami5.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_CT_T2T12.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_CT_T2T12.corr = 1;  // correct non-response
      } else {
         key_CT_T2T12.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_CT_T2T12.keys', key_CT_T2T12.keys);
    psychoJS.experiment.addData('key_CT_T2T12.corr', key_CT_T2T12.corr);
    if (typeof key_CT_T2T12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_CT_T2T12.rt', key_CT_T2T12.rt);
        routineTimer.reset();
        }
    
    key_CT_T2T12.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_EndCT_allKeys;
var EndCriterionTestComponents;
function EndCriterionTestRoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'EndCriterionTest'-------
    t = 0;
    EndCriterionTestClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_EndCT.keys = undefined;
    key_EndCT.rt = undefined;
    _key_EndCT_allKeys = [];
    // keep track of which components have finished
    EndCriterionTestComponents = [];
    EndCriterionTestComponents.push(text_EndCT);
    EndCriterionTestComponents.push(key_EndCT);
    EndCriterionTestComponents.push(phases_endCT);
    
    EndCriterionTestComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function EndCriterionTestRoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'EndCriterionTest'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = EndCriterionTestClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_EndCT* updates
    if (t >= 0.0 && text_EndCT.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_EndCT.tStart = t;  // (not accounting for frame time here)
      text_EndCT.frameNStart = frameN;  // exact frame index
      
      text_EndCT.setAutoDraw(true);
    }

    
    // *key_EndCT* updates
    if (t >= 0.0 && key_EndCT.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_EndCT.tStart = t;  // (not accounting for frame time here)
      key_EndCT.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_EndCT.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_EndCT.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_EndCT.clearEvents(); });
    }

    if (key_EndCT.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_EndCT.getKeys({keyList: ['space'], waitRelease: false});
      _key_EndCT_allKeys = _key_EndCT_allKeys.concat(theseKeys);
      if (_key_EndCT_allKeys.length > 0) {
        key_EndCT.keys = _key_EndCT_allKeys[_key_EndCT_allKeys.length - 1].name;  // just the last key pressed
        key_EndCT.rt = _key_EndCT_allKeys[_key_EndCT_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_endCT* updates
    if (t >= 0.0 && phases_endCT.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_endCT.tStart = t;  // (not accounting for frame time here)
      phases_endCT.frameNStart = frameN;  // exact frame index
      
      phases_endCT.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    EndCriterionTestComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function EndCriterionTestRoutineEnd(trials) {
  return function () {
    //------Ending Routine 'EndCriterionTest'-------
    EndCriterionTestComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_EndCT.keys', key_EndCT.keys);
    if (typeof key_EndCT.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_EndCT.rt', key_EndCT.rt);
        routineTimer.reset();
        }
    
    key_EndCT.stop();
    // the Routine "EndCriterionTest" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_FTinstructions1_allKeys;
var Phase4Instructions1Components;
function Phase4Instructions1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase4Instructions1'-------
    t = 0;
    Phase4Instructions1Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_FTinstructions1.keys = undefined;
    key_FTinstructions1.rt = undefined;
    _key_FTinstructions1_allKeys = [];
    // keep track of which components have finished
    Phase4Instructions1Components = [];
    Phase4Instructions1Components.push(text_FTinstructions1);
    Phase4Instructions1Components.push(key_FTinstructions1);
    
    Phase4Instructions1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase4Instructions1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase4Instructions1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase4Instructions1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_FTinstructions1* updates
    if (t >= 0.0 && text_FTinstructions1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FTinstructions1.tStart = t;  // (not accounting for frame time here)
      text_FTinstructions1.frameNStart = frameN;  // exact frame index
      
      text_FTinstructions1.setAutoDraw(true);
    }

    
    // *key_FTinstructions1* updates
    if (t >= 0.0 && key_FTinstructions1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FTinstructions1.tStart = t;  // (not accounting for frame time here)
      key_FTinstructions1.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FTinstructions1.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FTinstructions1.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FTinstructions1.clearEvents(); });
    }

    if (key_FTinstructions1.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FTinstructions1.getKeys({keyList: ['space'], waitRelease: false});
      _key_FTinstructions1_allKeys = _key_FTinstructions1_allKeys.concat(theseKeys);
      if (_key_FTinstructions1_allKeys.length > 0) {
        key_FTinstructions1.keys = _key_FTinstructions1_allKeys[_key_FTinstructions1_allKeys.length - 1].name;  // just the last key pressed
        key_FTinstructions1.rt = _key_FTinstructions1_allKeys[_key_FTinstructions1_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase4Instructions1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase4Instructions1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase4Instructions1'-------
    Phase4Instructions1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_FTinstructions1.keys', key_FTinstructions1.keys);
    if (typeof key_FTinstructions1.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FTinstructions1.rt', key_FTinstructions1.rt);
        routineTimer.reset();
        }
    
    key_FTinstructions1.stop();
    // the Routine "Phase4Instructions1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T1_allKeys;
var FinalTestT1T1Components;
function FinalTestT1T1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T1'-------
    t = 0;
    FinalTestT1T1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththuri6.secs=4;
    sound_ththuri6.setVolume(1);
    key_FT_T1T1.keys = undefined;
    key_FT_T1T1.rt = undefined;
    _key_FT_T1T1_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T1Components = [];
    FinalTestT1T1Components.push(sound_ththuri6);
    FinalTestT1T1Components.push(image_thuri8);
    FinalTestT1T1Components.push(text_FT_T1T1);
    FinalTestT1T1Components.push(key_FT_T1T1);
    FinalTestT1T1Components.push(phases_FT_T1T1);
    
    FinalTestT1T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththuri6
    if (t >= 0.2 && sound_ththuri6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththuri6.tStart = t;  // (not accounting for frame time here)
      sound_ththuri6.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththuri6.play(); });  // screen flip
      sound_ththuri6.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththuri6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththuri6.stop();  // stop the sound (if longer than duration)
        sound_ththuri6.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thuri8* updates
    if (t >= 0.2 && image_thuri8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri8.tStart = t;  // (not accounting for frame time here)
      image_thuri8.frameNStart = frameN;  // exact frame index
      
      image_thuri8.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri8.setAutoDraw(false);
    }
    
    // *text_FT_T1T1* updates
    if (t >= 0 && text_FT_T1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T1.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T1.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T1.setAutoDraw(true);
    }

    frameRemains = 0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T1.setAutoDraw(false);
    }
    
    // *key_FT_T1T1* updates
    if (t >= 4.2 && key_FT_T1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T1.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T1.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T1.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T1.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T1.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T1.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T1.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T1.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T1_allKeys = _key_FT_T1T1_allKeys.concat(theseKeys);
      if (_key_FT_T1T1_allKeys.length > 0) {
        key_FT_T1T1.keys = _key_FT_T1T1_allKeys[_key_FT_T1T1_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T1.rt = _key_FT_T1T1_allKeys[_key_FT_T1T1_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T1.keys == '0') {
            key_FT_T1T1.corr = 1;
        } else {
            key_FT_T1T1.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T1* updates
    if (t >= 0.0 && phases_FT_T1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T1.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T1.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T1.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T1'-------
    FinalTestT1T1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththuri6.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T1.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T1T1.corr = 1;  // correct non-response
      } else {
         key_FT_T1T1.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T1.keys', key_FT_T1T1.keys);
    psychoJS.experiment.addData('key_FT_T1T1.corr', key_FT_T1T1.corr);
    if (typeof key_FT_T1T1.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T1.rt', key_FT_T1T1.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T1.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T2_allKeys;
var FinalTestT1T2Components;
function FinalTestT1T2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T2'-------
    t = 0;
    FinalTestT1T2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thami6.secs=4;
    sound_thami6.setVolume(1);
    key_FT_T1T2.keys = undefined;
    key_FT_T1T2.rt = undefined;
    _key_FT_T1T2_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T2Components = [];
    FinalTestT1T2Components.push(sound_thami6);
    FinalTestT1T2Components.push(image_ththami8);
    FinalTestT1T2Components.push(text_FT_T1T2);
    FinalTestT1T2Components.push(key_FT_T1T2);
    FinalTestT1T2Components.push(phases_FT_T1T2);
    
    FinalTestT1T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thami6
    if (t >= 0.2 && sound_thami6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thami6.tStart = t;  // (not accounting for frame time here)
      sound_thami6.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thami6.play(); });  // screen flip
      sound_thami6.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thami6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thami6.stop();  // stop the sound (if longer than duration)
        sound_thami6.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththami8* updates
    if (t >= 0.2 && image_ththami8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami8.tStart = t;  // (not accounting for frame time here)
      image_ththami8.frameNStart = frameN;  // exact frame index
      
      image_ththami8.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami8.setAutoDraw(false);
    }
    
    // *text_FT_T1T2* updates
    if (t >= 0.0 && text_FT_T1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T2.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T2.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T2.setAutoDraw(false);
    }
    
    // *key_FT_T1T2* updates
    if (t >= 4.2 && key_FT_T1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T2.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T2.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T2.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T2.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T2_allKeys = _key_FT_T1T2_allKeys.concat(theseKeys);
      if (_key_FT_T1T2_allKeys.length > 0) {
        key_FT_T1T2.keys = _key_FT_T1T2_allKeys[_key_FT_T1T2_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T2.rt = _key_FT_T1T2_allKeys[_key_FT_T1T2_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T2.keys == '0') {
            key_FT_T1T2.corr = 1;
        } else {
            key_FT_T1T2.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T2* updates
    if (t >= 0.0 && phases_FT_T1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T2.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T2.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T2'-------
    FinalTestT1T2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thami6.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T2.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T1T2.corr = 1;  // correct non-response
      } else {
         key_FT_T1T2.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T2.keys', key_FT_T1T2.keys);
    psychoJS.experiment.addData('key_FT_T1T2.corr', key_FT_T1T2.corr);
    if (typeof key_FT_T1T2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T2.rt', key_FT_T1T2.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T2.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T3_allKeys;
var FinalTestT1T3Components;
function FinalTestT1T3RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T3'-------
    t = 0;
    FinalTestT1T3Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thuri6.secs=4;
    sound_thuri6.setVolume(1);
    key_FT_T1T3.keys = undefined;
    key_FT_T1T3.rt = undefined;
    _key_FT_T1T3_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T3Components = [];
    FinalTestT1T3Components.push(sound_thuri6);
    FinalTestT1T3Components.push(image_thuri9);
    FinalTestT1T3Components.push(text_FT_T1T3);
    FinalTestT1T3Components.push(key_FT_T1T3);
    FinalTestT1T3Components.push(phases_FT_T1T3);
    
    FinalTestT1T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T3RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thuri6
    if (t >= 0.2 && sound_thuri6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thuri6.tStart = t;  // (not accounting for frame time here)
      sound_thuri6.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thuri6.play(); });  // screen flip
      sound_thuri6.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thuri6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thuri6.stop();  // stop the sound (if longer than duration)
        sound_thuri6.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thuri9* updates
    if (t >= 0.2 && image_thuri9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri9.tStart = t;  // (not accounting for frame time here)
      image_thuri9.frameNStart = frameN;  // exact frame index
      
      image_thuri9.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri9.setAutoDraw(false);
    }
    
    // *text_FT_T1T3* updates
    if (t >= 0.0 && text_FT_T1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T3.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T3.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T3.setAutoDraw(false);
    }
    
    // *key_FT_T1T3* updates
    if (t >= 4.2 && key_FT_T1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T3.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T3.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T3.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T3.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T3.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T3.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T3.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T3.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T3_allKeys = _key_FT_T1T3_allKeys.concat(theseKeys);
      if (_key_FT_T1T3_allKeys.length > 0) {
        key_FT_T1T3.keys = _key_FT_T1T3_allKeys[_key_FT_T1T3_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T3.rt = _key_FT_T1T3_allKeys[_key_FT_T1T3_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T3.keys == '1') {
            key_FT_T1T3.corr = 1;
        } else {
            key_FT_T1T3.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T3* updates
    if (t >= 0.0 && phases_FT_T1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T3.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T3.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T3RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T3'-------
    FinalTestT1T3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thuri6.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T3.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T1T3.corr = 1;  // correct non-response
      } else {
         key_FT_T1T3.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T3.keys', key_FT_T1T3.keys);
    psychoJS.experiment.addData('key_FT_T1T3.corr', key_FT_T1T3.corr);
    if (typeof key_FT_T1T3.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T3.rt', key_FT_T1T3.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T3.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T4_allKeys;
var FinalTestT1T4Components;
function FinalTestT1T4RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T4'-------
    t = 0;
    FinalTestT1T4Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththami6.secs=4;
    sound_ththami6.setVolume(1);
    key_FT_T1T4.keys = undefined;
    key_FT_T1T4.rt = undefined;
    _key_FT_T1T4_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T4Components = [];
    FinalTestT1T4Components.push(sound_ththami6);
    FinalTestT1T4Components.push(image_thami8);
    FinalTestT1T4Components.push(text_FT_T1T4);
    FinalTestT1T4Components.push(key_FT_T1T4);
    FinalTestT1T4Components.push(phases_FT_T1T4);
    
    FinalTestT1T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T4RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththami6
    if (t >= 0.2 && sound_ththami6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththami6.tStart = t;  // (not accounting for frame time here)
      sound_ththami6.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththami6.play(); });  // screen flip
      sound_ththami6.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththami6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththami6.stop();  // stop the sound (if longer than duration)
        sound_ththami6.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thami8* updates
    if (t >= 0.2 && image_thami8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami8.tStart = t;  // (not accounting for frame time here)
      image_thami8.frameNStart = frameN;  // exact frame index
      
      image_thami8.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami8.setAutoDraw(false);
    }
    
    // *text_FT_T1T4* updates
    if (t >= 0.0 && text_FT_T1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T4.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T4.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T4.setAutoDraw(false);
    }
    
    // *key_FT_T1T4* updates
    if (t >= 4.2 && key_FT_T1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T4.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T4.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T4.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T4.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T4_allKeys = _key_FT_T1T4_allKeys.concat(theseKeys);
      if (_key_FT_T1T4_allKeys.length > 0) {
        key_FT_T1T4.keys = _key_FT_T1T4_allKeys[_key_FT_T1T4_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T4.rt = _key_FT_T1T4_allKeys[_key_FT_T1T4_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T4.keys == '0') {
            key_FT_T1T4.corr = 1;
        } else {
            key_FT_T1T4.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T4* updates
    if (t >= 0.0 && phases_FT_T1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T4.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T4.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T4.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T4RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T4'-------
    FinalTestT1T4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththami6.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T4.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T1T4.corr = 1;  // correct non-response
      } else {
         key_FT_T1T4.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T4.keys', key_FT_T1T4.keys);
    psychoJS.experiment.addData('key_FT_T1T4.corr', key_FT_T1T4.corr);
    if (typeof key_FT_T1T4.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T4.rt', key_FT_T1T4.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T4.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T5_allKeys;
var FinalTestT1T5Components;
function FinalTestT1T5RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T5'-------
    t = 0;
    FinalTestT1T5Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thano6.secs=4;
    sound_thano6.setVolume(1);
    key_FT_T1T5.keys = undefined;
    key_FT_T1T5.rt = undefined;
    _key_FT_T1T5_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T5Components = [];
    FinalTestT1T5Components.push(sound_thano6);
    FinalTestT1T5Components.push(image_thano8);
    FinalTestT1T5Components.push(text_FT_T1T5);
    FinalTestT1T5Components.push(key_FT_T1T5);
    FinalTestT1T5Components.push(phases_FT_T1T5);
    
    FinalTestT1T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T5RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T5'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thano6
    if (t >= 0.2 && sound_thano6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thano6.tStart = t;  // (not accounting for frame time here)
      sound_thano6.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thano6.play(); });  // screen flip
      sound_thano6.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thano6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thano6.stop();  // stop the sound (if longer than duration)
        sound_thano6.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thano8* updates
    if (t >= 0.2 && image_thano8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano8.tStart = t;  // (not accounting for frame time here)
      image_thano8.frameNStart = frameN;  // exact frame index
      
      image_thano8.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano8.setAutoDraw(false);
    }
    
    // *text_FT_T1T5* updates
    if (t >= 0.0 && text_FT_T1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T5.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T5.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T5.setAutoDraw(false);
    }
    
    // *key_FT_T1T5* updates
    if (t >= 4.2 && key_FT_T1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T5.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T5.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T5.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T5.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T5_allKeys = _key_FT_T1T5_allKeys.concat(theseKeys);
      if (_key_FT_T1T5_allKeys.length > 0) {
        key_FT_T1T5.keys = _key_FT_T1T5_allKeys[_key_FT_T1T5_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T5.rt = _key_FT_T1T5_allKeys[_key_FT_T1T5_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T5.keys == '1') {
            key_FT_T1T5.corr = 1;
        } else {
            key_FT_T1T5.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T5* updates
    if (t >= 0.0 && phases_FT_T1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T5.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T5.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T5RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T5'-------
    FinalTestT1T5Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thano6.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T5.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T1T5.corr = 1;  // correct non-response
      } else {
         key_FT_T1T5.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T5.keys', key_FT_T1T5.keys);
    psychoJS.experiment.addData('key_FT_T1T5.corr', key_FT_T1T5.corr);
    if (typeof key_FT_T1T5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T5.rt', key_FT_T1T5.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T5.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T6_allKeys;
var FinalTestT1T6Components;
function FinalTestT1T6RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T6'-------
    t = 0;
    FinalTestT1T6Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththami7.secs=4;
    sound_ththami7.setVolume(1);
    key_FT_T1T6.keys = undefined;
    key_FT_T1T6.rt = undefined;
    _key_FT_T1T6_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T6Components = [];
    FinalTestT1T6Components.push(sound_ththami7);
    FinalTestT1T6Components.push(image_ththami9);
    FinalTestT1T6Components.push(text_FT_T1T6);
    FinalTestT1T6Components.push(key_FT_T1T6);
    FinalTestT1T6Components.push(phases_FT_T1T6);
    
    FinalTestT1T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T6RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T6'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththami7
    if (t >= 0.2 && sound_ththami7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththami7.tStart = t;  // (not accounting for frame time here)
      sound_ththami7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththami7.play(); });  // screen flip
      sound_ththami7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththami7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththami7.stop();  // stop the sound (if longer than duration)
        sound_ththami7.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththami9* updates
    if (t >= 0.2 && image_ththami9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami9.tStart = t;  // (not accounting for frame time here)
      image_ththami9.frameNStart = frameN;  // exact frame index
      
      image_ththami9.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami9.setAutoDraw(false);
    }
    
    // *text_FT_T1T6* updates
    if (t >= 0.0 && text_FT_T1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T6.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T6.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T6.setAutoDraw(false);
    }
    
    // *key_FT_T1T6* updates
    if (t >= 4.2 && key_FT_T1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T6.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T6.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T6.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T6.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T6.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T6.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T6.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T6.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T6_allKeys = _key_FT_T1T6_allKeys.concat(theseKeys);
      if (_key_FT_T1T6_allKeys.length > 0) {
        key_FT_T1T6.keys = _key_FT_T1T6_allKeys[_key_FT_T1T6_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T6.rt = _key_FT_T1T6_allKeys[_key_FT_T1T6_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T6.keys == '1') {
            key_FT_T1T6.corr = 1;
        } else {
            key_FT_T1T6.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T6* updates
    if (t >= 0.0 && phases_FT_T1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T6.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T6.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T6.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T6RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T6'-------
    FinalTestT1T6Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththami7.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T6.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T1T6.corr = 1;  // correct non-response
      } else {
         key_FT_T1T6.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T6.keys', key_FT_T1T6.keys);
    psychoJS.experiment.addData('key_FT_T1T6.corr', key_FT_T1T6.corr);
    if (typeof key_FT_T1T6.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T6.rt', key_FT_T1T6.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T6.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T7_allKeys;
var FinalTestT1T7Components;
function FinalTestT1T7RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T7'-------
    t = 0;
    FinalTestT1T7Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thami7.secs=4;
    sound_thami7.setVolume(1);
    key_FT_T1T7.keys = undefined;
    key_FT_T1T7.rt = undefined;
    _key_FT_T1T7_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T7Components = [];
    FinalTestT1T7Components.push(sound_thami7);
    FinalTestT1T7Components.push(image_thami9);
    FinalTestT1T7Components.push(text_FT_T1T7);
    FinalTestT1T7Components.push(key_FT_T1T7);
    FinalTestT1T7Components.push(phases_FT_T1T7);
    
    FinalTestT1T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T7RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T7'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thami7
    if (t >= 0.2 && sound_thami7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thami7.tStart = t;  // (not accounting for frame time here)
      sound_thami7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thami7.play(); });  // screen flip
      sound_thami7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thami7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thami7.stop();  // stop the sound (if longer than duration)
        sound_thami7.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thami9* updates
    if (t >= 0.2 && image_thami9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami9.tStart = t;  // (not accounting for frame time here)
      image_thami9.frameNStart = frameN;  // exact frame index
      
      image_thami9.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami9.setAutoDraw(false);
    }
    
    // *text_FT_T1T7* updates
    if (t >= 0.0 && text_FT_T1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T7.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T7.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T7.setAutoDraw(false);
    }
    
    // *key_FT_T1T7* updates
    if (t >= 4.2 && key_FT_T1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T7.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T7.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T7.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T7.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T7.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T7.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T7.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T7.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T7_allKeys = _key_FT_T1T7_allKeys.concat(theseKeys);
      if (_key_FT_T1T7_allKeys.length > 0) {
        key_FT_T1T7.keys = _key_FT_T1T7_allKeys[_key_FT_T1T7_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T7.rt = _key_FT_T1T7_allKeys[_key_FT_T1T7_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T7.keys == '1') {
            key_FT_T1T7.corr = 1;
        } else {
            key_FT_T1T7.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T7* updates
    if (t >= 0.0 && phases_FT_T1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T7.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T7.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T7.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T7RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T7'-------
    FinalTestT1T7Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thami7.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T7.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T1T7.corr = 1;  // correct non-response
      } else {
         key_FT_T1T7.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T7.keys', key_FT_T1T7.keys);
    psychoJS.experiment.addData('key_FT_T1T7.corr', key_FT_T1T7.corr);
    if (typeof key_FT_T1T7.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T7.rt', key_FT_T1T7.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T7.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T8_allKeys;
var FinalTestT1T8Components;
function FinalTestT1T8RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T8'-------
    t = 0;
    FinalTestT1T8Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththano6.secs=4;
    sound_ththano6.setVolume(1);
    key_FT_T1T8.keys = undefined;
    key_FT_T1T8.rt = undefined;
    _key_FT_T1T8_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T8Components = [];
    FinalTestT1T8Components.push(sound_ththano6);
    FinalTestT1T8Components.push(image_thano9);
    FinalTestT1T8Components.push(text_FT_T1T8);
    FinalTestT1T8Components.push(key_FT_T1T8);
    FinalTestT1T8Components.push(phases_FT_T1T8);
    
    FinalTestT1T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T8RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T8'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T8Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththano6
    if (t >= 0.2 && sound_ththano6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththano6.tStart = t;  // (not accounting for frame time here)
      sound_ththano6.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththano6.play(); });  // screen flip
      sound_ththano6.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththano6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththano6.stop();  // stop the sound (if longer than duration)
        sound_ththano6.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_thano9* updates
    if (t >= 0.2 && image_thano9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano9.tStart = t;  // (not accounting for frame time here)
      image_thano9.frameNStart = frameN;  // exact frame index
      
      image_thano9.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano9.setAutoDraw(false);
    }
    
    // *text_FT_T1T8* updates
    if (t >= 0.0 && text_FT_T1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T8.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T8.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T8.setAutoDraw(false);
    }
    
    // *key_FT_T1T8* updates
    if (t >= 4.2 && key_FT_T1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T8.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T8.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T8.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T8.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T8.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T8.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T8.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T8.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T8_allKeys = _key_FT_T1T8_allKeys.concat(theseKeys);
      if (_key_FT_T1T8_allKeys.length > 0) {
        key_FT_T1T8.keys = _key_FT_T1T8_allKeys[_key_FT_T1T8_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T8.rt = _key_FT_T1T8_allKeys[_key_FT_T1T8_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T8.keys == '0') {
            key_FT_T1T8.corr = 1;
        } else {
            key_FT_T1T8.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T8* updates
    if (t >= 0.0 && phases_FT_T1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T8.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T8.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T8.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T8RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T8'-------
    FinalTestT1T8Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththano6.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T8.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T1T8.corr = 1;  // correct non-response
      } else {
         key_FT_T1T8.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T8.keys', key_FT_T1T8.keys);
    psychoJS.experiment.addData('key_FT_T1T8.corr', key_FT_T1T8.corr);
    if (typeof key_FT_T1T8.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T8.rt', key_FT_T1T8.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T8.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T9_allKeys;
var FinalTestT1T9Components;
function FinalTestT1T9RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T9'-------
    t = 0;
    FinalTestT1T9Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththuri7.secs=4;
    sound_ththuri7.setVolume(1);
    key_FT_T1T9.keys = undefined;
    key_FT_T1T9.rt = undefined;
    _key_FT_T1T9_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T9Components = [];
    FinalTestT1T9Components.push(sound_ththuri7);
    FinalTestT1T9Components.push(image_ththuri8);
    FinalTestT1T9Components.push(text_FT_T1T9);
    FinalTestT1T9Components.push(key_FT_T1T9);
    FinalTestT1T9Components.push(phases_FT_T1T9);
    
    FinalTestT1T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T9RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T9'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T9Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththuri7
    if (t >= 0.2 && sound_ththuri7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththuri7.tStart = t;  // (not accounting for frame time here)
      sound_ththuri7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththuri7.play(); });  // screen flip
      sound_ththuri7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththuri7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththuri7.stop();  // stop the sound (if longer than duration)
        sound_ththuri7.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththuri8* updates
    if (t >= 0.2 && image_ththuri8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri8.tStart = t;  // (not accounting for frame time here)
      image_ththuri8.frameNStart = frameN;  // exact frame index
      
      image_ththuri8.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri8.setAutoDraw(false);
    }
    
    // *text_FT_T1T9* updates
    if (t >= 0.0 && text_FT_T1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T9.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T9.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T9.setAutoDraw(false);
    }
    
    // *key_FT_T1T9* updates
    if (t >= 4.2 && key_FT_T1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T9.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T9.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T9.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T9.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T9_allKeys = _key_FT_T1T9_allKeys.concat(theseKeys);
      if (_key_FT_T1T9_allKeys.length > 0) {
        key_FT_T1T9.keys = _key_FT_T1T9_allKeys[_key_FT_T1T9_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T9.rt = _key_FT_T1T9_allKeys[_key_FT_T1T9_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T9.keys == '1') {
            key_FT_T1T9.corr = 1;
        } else {
            key_FT_T1T9.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T9* updates
    if (t >= 0.0 && phases_FT_T1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T9.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T9.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T9.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T9RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T9'-------
    FinalTestT1T9Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththuri7.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T9.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T1T9.corr = 1;  // correct non-response
      } else {
         key_FT_T1T9.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T9.keys', key_FT_T1T9.keys);
    psychoJS.experiment.addData('key_FT_T1T9.corr', key_FT_T1T9.corr);
    if (typeof key_FT_T1T9.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T9.rt', key_FT_T1T9.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T9.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T10_allKeys;
var FinalTestT1T10Components;
function FinalTestT1T10RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T10'-------
    t = 0;
    FinalTestT1T10Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thano7.secs=4;
    sound_thano7.setVolume(1);
    key_FT_T1T10.keys = undefined;
    key_FT_T1T10.rt = undefined;
    _key_FT_T1T10_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T10Components = [];
    FinalTestT1T10Components.push(sound_thano7);
    FinalTestT1T10Components.push(image_ththano8);
    FinalTestT1T10Components.push(text_FT_T1T10);
    FinalTestT1T10Components.push(key_FT_T1T10);
    FinalTestT1T10Components.push(phases_FT_T1T10);
    
    FinalTestT1T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T10RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T10'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T10Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thano7
    if (t >= 0.2 && sound_thano7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thano7.tStart = t;  // (not accounting for frame time here)
      sound_thano7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thano7.play(); });  // screen flip
      sound_thano7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thano7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thano7.stop();  // stop the sound (if longer than duration)
        sound_thano7.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththano8* updates
    if (t >= 0.2 && image_ththano8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano8.tStart = t;  // (not accounting for frame time here)
      image_ththano8.frameNStart = frameN;  // exact frame index
      
      image_ththano8.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano8.setAutoDraw(false);
    }
    
    // *text_FT_T1T10* updates
    if (t >= 0.0 && text_FT_T1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T10.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T10.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T10.setAutoDraw(false);
    }
    
    // *key_FT_T1T10* updates
    if (t >= 4.2 && key_FT_T1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T10.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T10.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T10.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T10.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T10_allKeys = _key_FT_T1T10_allKeys.concat(theseKeys);
      if (_key_FT_T1T10_allKeys.length > 0) {
        key_FT_T1T10.keys = _key_FT_T1T10_allKeys[_key_FT_T1T10_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T10.rt = _key_FT_T1T10_allKeys[_key_FT_T1T10_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T10.keys == '0') {
            key_FT_T1T10.corr = 1;
        } else {
            key_FT_T1T10.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T10* updates
    if (t >= 0.0 && phases_FT_T1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T10.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T10.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T10.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T10RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T10'-------
    FinalTestT1T10Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thano7.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T10.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T1T10.corr = 1;  // correct non-response
      } else {
         key_FT_T1T10.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T10.keys', key_FT_T1T10.keys);
    psychoJS.experiment.addData('key_FT_T1T10.corr', key_FT_T1T10.corr);
    if (typeof key_FT_T1T10.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T10.rt', key_FT_T1T10.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T10.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T11_allKeys;
var FinalTestT1T11Components;
function FinalTestT1T11RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T11'-------
    t = 0;
    FinalTestT1T11Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thuri7.secs=4;
    sound_thuri7.setVolume(1);
    key_FT_T1T11.keys = undefined;
    key_FT_T1T11.rt = undefined;
    _key_FT_T1T11_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T11Components = [];
    FinalTestT1T11Components.push(sound_thuri7);
    FinalTestT1T11Components.push(image_ththuri9);
    FinalTestT1T11Components.push(text_FT_T1T11);
    FinalTestT1T11Components.push(key_FT_T1T11);
    FinalTestT1T11Components.push(phases_FT_T1T11);
    
    FinalTestT1T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T11RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T11'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T11Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thuri7
    if (t >= 0.2 && sound_thuri7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thuri7.tStart = t;  // (not accounting for frame time here)
      sound_thuri7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thuri7.play(); });  // screen flip
      sound_thuri7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thuri7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thuri7.stop();  // stop the sound (if longer than duration)
        sound_thuri7.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththuri9* updates
    if (t >= 0.2 && image_ththuri9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri9.tStart = t;  // (not accounting for frame time here)
      image_ththuri9.frameNStart = frameN;  // exact frame index
      
      image_ththuri9.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri9.setAutoDraw(false);
    }
    
    // *text_FT_T1T11* updates
    if (t >= 0.0 && text_FT_T1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T11.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T11.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T11.setAutoDraw(false);
    }
    
    // *key_FT_T1T11* updates
    if (t >= 4.2 && key_FT_T1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T11.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T11.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T11.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T11.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T11_allKeys = _key_FT_T1T11_allKeys.concat(theseKeys);
      if (_key_FT_T1T11_allKeys.length > 0) {
        key_FT_T1T11.keys = _key_FT_T1T11_allKeys[_key_FT_T1T11_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T11.rt = _key_FT_T1T11_allKeys[_key_FT_T1T11_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T11.keys == '0') {
            key_FT_T1T11.corr = 1;
        } else {
            key_FT_T1T11.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T11* updates
    if (t >= 0.0 && phases_FT_T1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T11.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T11.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T11.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T11RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T11'-------
    FinalTestT1T11Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thuri7.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T11.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T1T11.corr = 1;  // correct non-response
      } else {
         key_FT_T1T11.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T11.keys', key_FT_T1T11.keys);
    psychoJS.experiment.addData('key_FT_T1T11.corr', key_FT_T1T11.corr);
    if (typeof key_FT_T1T11.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T11.rt', key_FT_T1T11.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T11.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T1T12_allKeys;
var FinalTestT1T12Components;
function FinalTestT1T12RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT1T12'-------
    t = 0;
    FinalTestT1T12Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththano7.secs=4;
    sound_ththano7.setVolume(1);
    key_FT_T1T12.keys = undefined;
    key_FT_T1T12.rt = undefined;
    _key_FT_T1T12_allKeys = [];
    // keep track of which components have finished
    FinalTestT1T12Components = [];
    FinalTestT1T12Components.push(sound_ththano7);
    FinalTestT1T12Components.push(image_ththano9);
    FinalTestT1T12Components.push(text_FT_T1T12);
    FinalTestT1T12Components.push(key_FT_T1T12);
    FinalTestT1T12Components.push(phases_FT_T1T12);
    
    FinalTestT1T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT1T12RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT1T12'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT1T12Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththano7
    if (t >= 0.2 && sound_ththano7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththano7.tStart = t;  // (not accounting for frame time here)
      sound_ththano7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththano7.play(); });  // screen flip
      sound_ththano7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththano7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththano7.stop();  // stop the sound (if longer than duration)
        sound_ththano7.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *image_ththano9* updates
    if (t >= 0.2 && image_ththano9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano9.tStart = t;  // (not accounting for frame time here)
      image_ththano9.frameNStart = frameN;  // exact frame index
      
      image_ththano9.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano9.setAutoDraw(false);
    }
    
    // *text_FT_T1T12* updates
    if (t >= 0.0 && text_FT_T1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T1T12.tStart = t;  // (not accounting for frame time here)
      text_FT_T1T12.frameNStart = frameN;  // exact frame index
      
      text_FT_T1T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T1T12.setAutoDraw(false);
    }
    
    // *key_FT_T1T12* updates
    if (t >= 4.2 && key_FT_T1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T1T12.tStart = t;  // (not accounting for frame time here)
      key_FT_T1T12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T1T12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T1T12.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T1T12.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T1T12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T1T12.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T1T12_allKeys = _key_FT_T1T12_allKeys.concat(theseKeys);
      if (_key_FT_T1T12_allKeys.length > 0) {
        key_FT_T1T12.keys = _key_FT_T1T12_allKeys[_key_FT_T1T12_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T1T12.rt = _key_FT_T1T12_allKeys[_key_FT_T1T12_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T1T12.keys == '1') {
            key_FT_T1T12.corr = 1;
        } else {
            key_FT_T1T12.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T1T12* updates
    if (t >= 0.0 && phases_FT_T1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T1T12.tStart = t;  // (not accounting for frame time here)
      phases_FT_T1T12.frameNStart = frameN;  // exact frame index
      
      phases_FT_T1T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T1T12.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT1T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT1T12RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT1T12'-------
    FinalTestT1T12Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththano7.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T1T12.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T1T12.corr = 1;  // correct non-response
      } else {
         key_FT_T1T12.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T1T12.keys', key_FT_T1T12.keys);
    psychoJS.experiment.addData('key_FT_T1T12.corr', key_FT_T1T12.corr);
    if (typeof key_FT_T1T12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T1T12.rt', key_FT_T1T12.rt);
        routineTimer.reset();
        }
    
    key_FT_T1T12.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FTinstructions2_allKeys;
var Phase4Instructions2Components;
function Phase4Instructions2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase4Instructions2'-------
    t = 0;
    Phase4Instructions2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_FTinstructions2.keys = undefined;
    key_FTinstructions2.rt = undefined;
    _key_FTinstructions2_allKeys = [];
    // keep track of which components have finished
    Phase4Instructions2Components = [];
    Phase4Instructions2Components.push(text_FTinstructiosn2);
    Phase4Instructions2Components.push(key_FTinstructions2);
    
    Phase4Instructions2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase4Instructions2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase4Instructions2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase4Instructions2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_FTinstructiosn2* updates
    if (t >= 0.0 && text_FTinstructiosn2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FTinstructiosn2.tStart = t;  // (not accounting for frame time here)
      text_FTinstructiosn2.frameNStart = frameN;  // exact frame index
      
      text_FTinstructiosn2.setAutoDraw(true);
    }

    
    // *key_FTinstructions2* updates
    if (t >= 0.0 && key_FTinstructions2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FTinstructions2.tStart = t;  // (not accounting for frame time here)
      key_FTinstructions2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FTinstructions2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FTinstructions2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FTinstructions2.clearEvents(); });
    }

    if (key_FTinstructions2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FTinstructions2.getKeys({keyList: ['space'], waitRelease: false});
      _key_FTinstructions2_allKeys = _key_FTinstructions2_allKeys.concat(theseKeys);
      if (_key_FTinstructions2_allKeys.length > 0) {
        key_FTinstructions2.keys = _key_FTinstructions2_allKeys[_key_FTinstructions2_allKeys.length - 1].name;  // just the last key pressed
        key_FTinstructions2.rt = _key_FTinstructions2_allKeys[_key_FTinstructions2_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase4Instructions2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase4Instructions2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase4Instructions2'-------
    Phase4Instructions2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_FTinstructions2.keys', key_FTinstructions2.keys);
    if (typeof key_FTinstructions2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FTinstructions2.rt', key_FTinstructions2.rt);
        routineTimer.reset();
        }
    
    key_FTinstructions2.stop();
    // the Routine "Phase4Instructions2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T1_allKeys;
var FinalTestT2T1Components;
function FinalTestT2T1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T1'-------
    t = 0;
    FinalTestT2T1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththami8.secs=4;
    sound_ththami8.setVolume(1);
    key_FT_T2T1.keys = undefined;
    key_FT_T2T1.rt = undefined;
    _key_FT_T2T1_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T1Components = [];
    FinalTestT2T1Components.push(image_ththami10);
    FinalTestT2T1Components.push(image_thami10);
    FinalTestT2T1Components.push(text_FT_T2T1_1);
    FinalTestT2T1Components.push(text_FT_T2T1_0);
    FinalTestT2T1Components.push(sound_ththami8);
    FinalTestT2T1Components.push(text_FT_T2T1);
    FinalTestT2T1Components.push(key_FT_T2T1);
    FinalTestT2T1Components.push(phases_FT_T2T1);
    
    FinalTestT2T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththami10* updates
    if (t >= 0.2 && image_ththami10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami10.tStart = t;  // (not accounting for frame time here)
      image_ththami10.frameNStart = frameN;  // exact frame index
      
      image_ththami10.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami10.setAutoDraw(false);
    }
    
    // *image_thami10* updates
    if (t >= 0.2 && image_thami10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami10.tStart = t;  // (not accounting for frame time here)
      image_thami10.frameNStart = frameN;  // exact frame index
      
      image_thami10.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami10.setAutoDraw(false);
    }
    
    // *text_FT_T2T1_1* updates
    if (t >= 0.2 && text_FT_T2T1_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T1_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T1_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T1_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T1_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T1_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T1_0* updates
    if (t >= 0.2 && text_FT_T2T1_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T1_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T1_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T1_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T1_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T1_0.setAutoDraw(false);
    }
    // start/stop sound_ththami8
    if (t >= 0.2 && sound_ththami8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththami8.tStart = t;  // (not accounting for frame time here)
      sound_ththami8.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththami8.play(); });  // screen flip
      sound_ththami8.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththami8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththami8.stop();  // stop the sound (if longer than duration)
        sound_ththami8.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T1* updates
    if (t >= 0.0 && text_FT_T2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T1.setAutoDraw(false);
    }
    
    // *key_FT_T2T1* updates
    if (t >= 4.2 && key_FT_T2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T1.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T1.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T1.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T1.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T1.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T1.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T1.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T1.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T1_allKeys = _key_FT_T2T1_allKeys.concat(theseKeys);
      if (_key_FT_T2T1_allKeys.length > 0) {
        key_FT_T2T1.keys = _key_FT_T2T1_allKeys[_key_FT_T2T1_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T1.rt = _key_FT_T2T1_allKeys[_key_FT_T2T1_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T1.keys == '1') {
            key_FT_T2T1.corr = 1;
        } else {
            key_FT_T2T1.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T1* updates
    if (t >= 0.0 && phases_FT_T2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T1.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T1.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T1.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T1'-------
    FinalTestT2T1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththami8.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T1.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T2T1.corr = 1;  // correct non-response
      } else {
         key_FT_T2T1.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T1.keys', key_FT_T2T1.keys);
    psychoJS.experiment.addData('key_FT_T2T1.corr', key_FT_T2T1.corr);
    if (typeof key_FT_T2T1.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T1.rt', key_FT_T2T1.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T1.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T2_allKeys;
var FinalTestT2T2Components;
function FinalTestT2T2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T2'-------
    t = 0;
    FinalTestT2T2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thano8.secs=4;
    sound_thano8.setVolume(1);
    key_FT_T2T2.keys = undefined;
    key_FT_T2T2.rt = undefined;
    _key_FT_T2T2_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T2Components = [];
    FinalTestT2T2Components.push(image_thano10);
    FinalTestT2T2Components.push(image_ththano10);
    FinalTestT2T2Components.push(text_FT_T2T2_1);
    FinalTestT2T2Components.push(text_FT_T2T2_0);
    FinalTestT2T2Components.push(sound_thano8);
    FinalTestT2T2Components.push(text_FT_T2T2);
    FinalTestT2T2Components.push(key_FT_T2T2);
    FinalTestT2T2Components.push(phases_FT_T2T2);
    
    FinalTestT2T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_thano10* updates
    if (t >= 0.2 && image_thano10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano10.tStart = t;  // (not accounting for frame time here)
      image_thano10.frameNStart = frameN;  // exact frame index
      
      image_thano10.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano10.setAutoDraw(false);
    }
    
    // *image_ththano10* updates
    if (t >= 0.2 && image_ththano10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano10.tStart = t;  // (not accounting for frame time here)
      image_ththano10.frameNStart = frameN;  // exact frame index
      
      image_ththano10.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano10.setAutoDraw(false);
    }
    
    // *text_FT_T2T2_1* updates
    if (t >= 0.2 && text_FT_T2T2_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T2_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T2_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T2_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T2_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T2_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T2_0* updates
    if (t >= 0.2 && text_FT_T2T2_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T2_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T2_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T2_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T2_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T2_0.setAutoDraw(false);
    }
    // start/stop sound_thano8
    if (t >= 0.2 && sound_thano8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thano8.tStart = t;  // (not accounting for frame time here)
      sound_thano8.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thano8.play(); });  // screen flip
      sound_thano8.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thano8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thano8.stop();  // stop the sound (if longer than duration)
        sound_thano8.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T2* updates
    if (t >= 0.0 && text_FT_T2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T2.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T2.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T2.setAutoDraw(false);
    }
    
    // *key_FT_T2T2* updates
    if (t >= 4.2 && key_FT_T2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T2.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T2.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T2.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T2.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T2_allKeys = _key_FT_T2T2_allKeys.concat(theseKeys);
      if (_key_FT_T2T2_allKeys.length > 0) {
        key_FT_T2T2.keys = _key_FT_T2T2_allKeys[_key_FT_T2T2_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T2.rt = _key_FT_T2T2_allKeys[_key_FT_T2T2_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T2.keys == '1') {
            key_FT_T2T2.corr = 1;
        } else {
            key_FT_T2T2.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T2* updates
    if (t >= 0.0 && phases_FT_T2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T2.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T2.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T2'-------
    FinalTestT2T2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thano8.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T2.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T2T2.corr = 1;  // correct non-response
      } else {
         key_FT_T2T2.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T2.keys', key_FT_T2T2.keys);
    psychoJS.experiment.addData('key_FT_T2T2.corr', key_FT_T2T2.corr);
    if (typeof key_FT_T2T2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T2.rt', key_FT_T2T2.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T2.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T3_allKeys;
var FinalTestT2T3Components;
function FinalTestT2T3RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T3'-------
    t = 0;
    FinalTestT2T3Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thuri8.secs=4;
    sound_thuri8.setVolume(1);
    key_FT_T2T3.keys = undefined;
    key_FT_T2T3.rt = undefined;
    _key_FT_T2T3_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T3Components = [];
    FinalTestT2T3Components.push(image_ththuri10);
    FinalTestT2T3Components.push(image_thuri10);
    FinalTestT2T3Components.push(text_FT_T2T3_1);
    FinalTestT2T3Components.push(text_FT_T2T3_0);
    FinalTestT2T3Components.push(sound_thuri8);
    FinalTestT2T3Components.push(text_FT_T2T3);
    FinalTestT2T3Components.push(key_FT_T2T3);
    FinalTestT2T3Components.push(phases_FT_T2T3);
    
    FinalTestT2T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T3RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththuri10* updates
    if (t >= 0.2 && image_ththuri10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri10.tStart = t;  // (not accounting for frame time here)
      image_ththuri10.frameNStart = frameN;  // exact frame index
      
      image_ththuri10.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri10.setAutoDraw(false);
    }
    
    // *image_thuri10* updates
    if (t >= 0.2 && image_thuri10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri10.tStart = t;  // (not accounting for frame time here)
      image_thuri10.frameNStart = frameN;  // exact frame index
      
      image_thuri10.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri10.setAutoDraw(false);
    }
    
    // *text_FT_T2T3_1* updates
    if (t >= 0.2 && text_FT_T2T3_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T3_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T3_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T3_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T3_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T3_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T3_0* updates
    if (t >= 0.2 && text_FT_T2T3_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T3_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T3_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T3_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T3_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T3_0.setAutoDraw(false);
    }
    // start/stop sound_thuri8
    if (t >= 0.2 && sound_thuri8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thuri8.tStart = t;  // (not accounting for frame time here)
      sound_thuri8.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thuri8.play(); });  // screen flip
      sound_thuri8.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thuri8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thuri8.stop();  // stop the sound (if longer than duration)
        sound_thuri8.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T3* updates
    if (t >= 0.0 && text_FT_T2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T3.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T3.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T3.setAutoDraw(false);
    }
    
    // *key_FT_T2T3* updates
    if (t >= 4.2 && key_FT_T2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T3.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T3.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T3.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T3.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T3.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T3.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T3.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T3.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T3_allKeys = _key_FT_T2T3_allKeys.concat(theseKeys);
      if (_key_FT_T2T3_allKeys.length > 0) {
        key_FT_T2T3.keys = _key_FT_T2T3_allKeys[_key_FT_T2T3_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T3.rt = _key_FT_T2T3_allKeys[_key_FT_T2T3_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T3.keys == '0') {
            key_FT_T2T3.corr = 1;
        } else {
            key_FT_T2T3.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T3* updates
    if (t >= 0.0 && phases_FT_T2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T3.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T3.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T3RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T3'-------
    FinalTestT2T3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thuri8.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T3.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T2T3.corr = 1;  // correct non-response
      } else {
         key_FT_T2T3.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T3.keys', key_FT_T2T3.keys);
    psychoJS.experiment.addData('key_FT_T2T3.corr', key_FT_T2T3.corr);
    if (typeof key_FT_T2T3.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T3.rt', key_FT_T2T3.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T3.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T4_allKeys;
var FinalTestT2T4Components;
function FinalTestT2T4RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T4'-------
    t = 0;
    FinalTestT2T4Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thami8.secs=4;
    sound_thami8.setVolume(1);
    key_FT_T2T4.keys = undefined;
    key_FT_T2T4.rt = undefined;
    _key_FT_T2T4_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T4Components = [];
    FinalTestT2T4Components.push(image_thami11);
    FinalTestT2T4Components.push(image_ththami11);
    FinalTestT2T4Components.push(text_FT_T2T4_1);
    FinalTestT2T4Components.push(text_FT_T2T4_0);
    FinalTestT2T4Components.push(sound_thami8);
    FinalTestT2T4Components.push(text_FT_T2T4);
    FinalTestT2T4Components.push(key_FT_T2T4);
    FinalTestT2T4Components.push(phases_FT_T2T4);
    
    FinalTestT2T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T4RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_thami11* updates
    if (t >= 0.2 && image_thami11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami11.tStart = t;  // (not accounting for frame time here)
      image_thami11.frameNStart = frameN;  // exact frame index
      
      image_thami11.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami11.setAutoDraw(false);
    }
    
    // *image_ththami11* updates
    if (t >= 0.2 && image_ththami11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami11.tStart = t;  // (not accounting for frame time here)
      image_ththami11.frameNStart = frameN;  // exact frame index
      
      image_ththami11.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami11.setAutoDraw(false);
    }
    
    // *text_FT_T2T4_1* updates
    if (t >= 0.2 && text_FT_T2T4_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T4_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T4_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T4_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T4_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T4_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T4_0* updates
    if (t >= 0.2 && text_FT_T2T4_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T4_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T4_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T4_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T4_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T4_0.setAutoDraw(false);
    }
    // start/stop sound_thami8
    if (t >= 0.2 && sound_thami8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thami8.tStart = t;  // (not accounting for frame time here)
      sound_thami8.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thami8.play(); });  // screen flip
      sound_thami8.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thami8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thami8.stop();  // stop the sound (if longer than duration)
        sound_thami8.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T4* updates
    if (t >= 0.0 && text_FT_T2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T4.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T4.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T4.setAutoDraw(false);
    }
    
    // *key_FT_T2T4* updates
    if (t >= 4.2 && key_FT_T2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T4.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T4.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T4.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T4.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T4_allKeys = _key_FT_T2T4_allKeys.concat(theseKeys);
      if (_key_FT_T2T4_allKeys.length > 0) {
        key_FT_T2T4.keys = _key_FT_T2T4_allKeys[_key_FT_T2T4_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T4.rt = _key_FT_T2T4_allKeys[_key_FT_T2T4_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T4.keys == '1') {
            key_FT_T2T4.corr = 1;
        } else {
            key_FT_T2T4.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T4* updates
    if (t >= 0.0 && phases_FT_T2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T4.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T4.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T4.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T4RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T4'-------
    FinalTestT2T4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thami8.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T4.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T2T4.corr = 1;  // correct non-response
      } else {
         key_FT_T2T4.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T4.keys', key_FT_T2T4.keys);
    psychoJS.experiment.addData('key_FT_T2T4.corr', key_FT_T2T4.corr);
    if (typeof key_FT_T2T4.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T4.rt', key_FT_T2T4.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T4.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T5_allKeys;
var FinalTestT2T5Components;
function FinalTestT2T5RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T5'-------
    t = 0;
    FinalTestT2T5Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thano9.secs=4;
    sound_thano9.setVolume(0);
    key_FT_T2T5.keys = undefined;
    key_FT_T2T5.rt = undefined;
    _key_FT_T2T5_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T5Components = [];
    FinalTestT2T5Components.push(image_ththano11);
    FinalTestT2T5Components.push(image_thano11);
    FinalTestT2T5Components.push(text_FT_T2T5_1);
    FinalTestT2T5Components.push(text_FT_T2T5_0);
    FinalTestT2T5Components.push(sound_thano9);
    FinalTestT2T5Components.push(text_FT_T2T5);
    FinalTestT2T5Components.push(key_FT_T2T5);
    FinalTestT2T5Components.push(phases_FT_T2T5);
    
    FinalTestT2T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T5RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T5'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththano11* updates
    if (t >= 0.2 && image_ththano11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano11.tStart = t;  // (not accounting for frame time here)
      image_ththano11.frameNStart = frameN;  // exact frame index
      
      image_ththano11.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano11.setAutoDraw(false);
    }
    
    // *image_thano11* updates
    if (t >= 0.2 && image_thano11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano11.tStart = t;  // (not accounting for frame time here)
      image_thano11.frameNStart = frameN;  // exact frame index
      
      image_thano11.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano11.setAutoDraw(false);
    }
    
    // *text_FT_T2T5_1* updates
    if (t >= 0.2 && text_FT_T2T5_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T5_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T5_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T5_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T5_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T5_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T5_0* updates
    if (t >= 0.2 && text_FT_T2T5_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T5_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T5_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T5_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T5_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T5_0.setAutoDraw(false);
    }
    // start/stop sound_thano9
    if (t >= 0.2 && sound_thano9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thano9.tStart = t;  // (not accounting for frame time here)
      sound_thano9.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thano9.play(); });  // screen flip
      sound_thano9.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thano9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thano9.stop();  // stop the sound (if longer than duration)
        sound_thano9.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T5* updates
    if (t >= 0.0 && text_FT_T2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T5.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T5.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T5.setAutoDraw(false);
    }
    
    // *key_FT_T2T5* updates
    if (t >= 4.2 && key_FT_T2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T5.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T5.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T5.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T5.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T5_allKeys = _key_FT_T2T5_allKeys.concat(theseKeys);
      if (_key_FT_T2T5_allKeys.length > 0) {
        key_FT_T2T5.keys = _key_FT_T2T5_allKeys[_key_FT_T2T5_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T5.rt = _key_FT_T2T5_allKeys[_key_FT_T2T5_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T5.keys == '0') {
            key_FT_T2T5.corr = 1;
        } else {
            key_FT_T2T5.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T5* updates
    if (t >= 0.0 && phases_FT_T2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T5.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T5.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T5RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T5'-------
    FinalTestT2T5Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thano9.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T5.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T2T5.corr = 1;  // correct non-response
      } else {
         key_FT_T2T5.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T5.keys', key_FT_T2T5.keys);
    psychoJS.experiment.addData('key_FT_T2T5.corr', key_FT_T2T5.corr);
    if (typeof key_FT_T2T5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T5.rt', key_FT_T2T5.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T5.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T6_allKeys;
var FinalTestT2T6Components;
function FinalTestT2T6RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T6'-------
    t = 0;
    FinalTestT2T6Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththuri8.secs=4;
    sound_ththuri8.setVolume(0);
    key_FT_T2T6.keys = undefined;
    key_FT_T2T6.rt = undefined;
    _key_FT_T2T6_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T6Components = [];
    FinalTestT2T6Components.push(image_thuri11);
    FinalTestT2T6Components.push(image_ththuri11);
    FinalTestT2T6Components.push(text_FT_T2T6_1);
    FinalTestT2T6Components.push(text_FT_T2T6_0);
    FinalTestT2T6Components.push(sound_ththuri8);
    FinalTestT2T6Components.push(text_FT_T2T6);
    FinalTestT2T6Components.push(key_FT_T2T6);
    FinalTestT2T6Components.push(phases_FT_T2T6);
    
    FinalTestT2T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T6RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T6'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_thuri11* updates
    if (t >= 0.2 && image_thuri11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri11.tStart = t;  // (not accounting for frame time here)
      image_thuri11.frameNStart = frameN;  // exact frame index
      
      image_thuri11.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri11.setAutoDraw(false);
    }
    
    // *image_ththuri11* updates
    if (t >= 0.2 && image_ththuri11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri11.tStart = t;  // (not accounting for frame time here)
      image_ththuri11.frameNStart = frameN;  // exact frame index
      
      image_ththuri11.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri11.setAutoDraw(false);
    }
    
    // *text_FT_T2T6_1* updates
    if (t >= 0.2 && text_FT_T2T6_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T6_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T6_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T6_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T6_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T6_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T6_0* updates
    if (t >= 0.2 && text_FT_T2T6_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T6_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T6_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T6_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T6_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T6_0.setAutoDraw(false);
    }
    // start/stop sound_ththuri8
    if (t >= 0.2 && sound_ththuri8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththuri8.tStart = t;  // (not accounting for frame time here)
      sound_ththuri8.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththuri8.play(); });  // screen flip
      sound_ththuri8.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththuri8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththuri8.stop();  // stop the sound (if longer than duration)
        sound_ththuri8.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T6* updates
    if (t >= 0.0 && text_FT_T2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T6.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T6.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T6.setAutoDraw(false);
    }
    
    // *key_FT_T2T6* updates
    if (t >= 4.2 && key_FT_T2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T6.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T6.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T6.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T6.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T6.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T6.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T6.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T6.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T6_allKeys = _key_FT_T2T6_allKeys.concat(theseKeys);
      if (_key_FT_T2T6_allKeys.length > 0) {
        key_FT_T2T6.keys = _key_FT_T2T6_allKeys[_key_FT_T2T6_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T6.rt = _key_FT_T2T6_allKeys[_key_FT_T2T6_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T6* updates
    if (t >= 0.0 && phases_FT_T2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T6.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T6.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T6.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T6RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T6'-------
    FinalTestT2T6Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththuri8.stop();  // ensure sound has stopped at end of routine
    psychoJS.experiment.addData('key_FT_T2T6.keys', key_FT_T2T6.keys);
    if (typeof key_FT_T2T6.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T6.rt', key_FT_T2T6.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T6.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T7_allKeys;
var FinalTestT2T7Components;
function FinalTestT2T7RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T7'-------
    t = 0;
    FinalTestT2T7Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththano9.secs=4;
    sound_ththano9.setVolume(1);
    key_FT_T2T7.keys = undefined;
    key_FT_T2T7.rt = undefined;
    _key_FT_T2T7_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T7Components = [];
    FinalTestT2T7Components.push(image_ththano12);
    FinalTestT2T7Components.push(image_thano12);
    FinalTestT2T7Components.push(text_FT_T2T7_1);
    FinalTestT2T7Components.push(text_FT_T2T7_0);
    FinalTestT2T7Components.push(sound_ththano9);
    FinalTestT2T7Components.push(text_FT_T2T7);
    FinalTestT2T7Components.push(key_FT_T2T7);
    FinalTestT2T7Components.push(phases_FT_T2T7);
    
    FinalTestT2T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T7RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T7'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththano12* updates
    if (t >= 0.2 && image_ththano12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano12.tStart = t;  // (not accounting for frame time here)
      image_ththano12.frameNStart = frameN;  // exact frame index
      
      image_ththano12.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano12.setAutoDraw(false);
    }
    
    // *image_thano12* updates
    if (t >= 0.2 && image_thano12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano12.tStart = t;  // (not accounting for frame time here)
      image_thano12.frameNStart = frameN;  // exact frame index
      
      image_thano12.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano12.setAutoDraw(false);
    }
    
    // *text_FT_T2T7_1* updates
    if (t >= 0.2 && text_FT_T2T7_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T7_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T7_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T7_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T7_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T7_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T7_0* updates
    if (t >= 0.2 && text_FT_T2T7_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T7_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T7_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T7_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T7_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T7_0.setAutoDraw(false);
    }
    // start/stop sound_ththano9
    if (t >= 0.2 && sound_ththano9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththano9.tStart = t;  // (not accounting for frame time here)
      sound_ththano9.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththano9.play(); });  // screen flip
      sound_ththano9.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththano9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththano9.stop();  // stop the sound (if longer than duration)
        sound_ththano9.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T7* updates
    if (t >= 0.0 && text_FT_T2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T7.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T7.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T7.setAutoDraw(false);
    }
    
    // *key_FT_T2T7* updates
    if (t >= 4.2 && key_FT_T2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T7.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T7.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T7.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T7.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T7.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T7.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T7.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T7.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T7_allKeys = _key_FT_T2T7_allKeys.concat(theseKeys);
      if (_key_FT_T2T7_allKeys.length > 0) {
        key_FT_T2T7.keys = _key_FT_T2T7_allKeys[_key_FT_T2T7_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T7.rt = _key_FT_T2T7_allKeys[_key_FT_T2T7_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T7.keys == '1') {
            key_FT_T2T7.corr = 1;
        } else {
            key_FT_T2T7.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T7* updates
    if (t >= 0.0 && phases_FT_T2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T7.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T7.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T7.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T7RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T7'-------
    FinalTestT2T7Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththano9.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T7.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T2T7.corr = 1;  // correct non-response
      } else {
         key_FT_T2T7.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T7.keys', key_FT_T2T7.keys);
    psychoJS.experiment.addData('key_FT_T2T7.corr', key_FT_T2T7.corr);
    if (typeof key_FT_T2T7.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T7.rt', key_FT_T2T7.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T7.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T8_allKeys;
var FinalTestT2T8Components;
function FinalTestT2T8RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T8'-------
    t = 0;
    FinalTestT2T8Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thami9.secs=4;
    sound_thami9.setVolume(1);
    key_FT_T2T8.keys = undefined;
    key_FT_T2T8.rt = undefined;
    _key_FT_T2T8_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T8Components = [];
    FinalTestT2T8Components.push(image_ththami12);
    FinalTestT2T8Components.push(image_thami12);
    FinalTestT2T8Components.push(text_FT_T2T8_1);
    FinalTestT2T8Components.push(text_FT_T2T8_0);
    FinalTestT2T8Components.push(sound_thami9);
    FinalTestT2T8Components.push(text_FT_T2T8);
    FinalTestT2T8Components.push(key_FT_T2T8);
    FinalTestT2T8Components.push(phases_FT_T2T8);
    
    FinalTestT2T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T8RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T8'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T8Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththami12* updates
    if (t >= 0.2 && image_ththami12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami12.tStart = t;  // (not accounting for frame time here)
      image_ththami12.frameNStart = frameN;  // exact frame index
      
      image_ththami12.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami12.setAutoDraw(false);
    }
    
    // *image_thami12* updates
    if (t >= 0.2 && image_thami12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami12.tStart = t;  // (not accounting for frame time here)
      image_thami12.frameNStart = frameN;  // exact frame index
      
      image_thami12.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami12.setAutoDraw(false);
    }
    
    // *text_FT_T2T8_1* updates
    if (t >= 0.2 && text_FT_T2T8_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T8_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T8_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T8_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T8_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T8_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T8_0* updates
    if (t >= 0.2 && text_FT_T2T8_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T8_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T8_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T8_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T8_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T8_0.setAutoDraw(false);
    }
    // start/stop sound_thami9
    if (t >= 0.2 && sound_thami9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thami9.tStart = t;  // (not accounting for frame time here)
      sound_thami9.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thami9.play(); });  // screen flip
      sound_thami9.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thami9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thami9.stop();  // stop the sound (if longer than duration)
        sound_thami9.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T8* updates
    if (t >= 0.0 && text_FT_T2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T8.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T8.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T8.setAutoDraw(false);
    }
    
    // *key_FT_T2T8* updates
    if (t >= 4.2 && key_FT_T2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T8.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T8.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T8.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T8.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T8.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T8.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T8.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T8.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T8_allKeys = _key_FT_T2T8_allKeys.concat(theseKeys);
      if (_key_FT_T2T8_allKeys.length > 0) {
        key_FT_T2T8.keys = _key_FT_T2T8_allKeys[_key_FT_T2T8_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T8.rt = _key_FT_T2T8_allKeys[_key_FT_T2T8_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T8.keys == '0') {
            key_FT_T2T8.corr = 1;
        } else {
            key_FT_T2T8.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T8* updates
    if (t >= 0.0 && phases_FT_T2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T8.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T8.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T8.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T8RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T8'-------
    FinalTestT2T8Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thami9.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T8.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T2T8.corr = 1;  // correct non-response
      } else {
         key_FT_T2T8.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T8.keys', key_FT_T2T8.keys);
    psychoJS.experiment.addData('key_FT_T2T8.corr', key_FT_T2T8.corr);
    if (typeof key_FT_T2T8.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T8.rt', key_FT_T2T8.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T8.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T9_allKeys;
var FinalTestT2T9Components;
function FinalTestT2T9RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T9'-------
    t = 0;
    FinalTestT2T9Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_thuri9.secs=4;
    sound_thuri9.setVolume(1);
    key_FT_T2T9.keys = undefined;
    key_FT_T2T9.rt = undefined;
    _key_FT_T2T9_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T9Components = [];
    FinalTestT2T9Components.push(image_thuri12);
    FinalTestT2T9Components.push(image_ththuri12);
    FinalTestT2T9Components.push(text_FT_T2T9_1);
    FinalTestT2T9Components.push(text_FT_T2T9_0);
    FinalTestT2T9Components.push(sound_thuri9);
    FinalTestT2T9Components.push(text_FT_T2T9);
    FinalTestT2T9Components.push(key_FT_T2T9);
    FinalTestT2T9Components.push(phases_FT_T2T9);
    
    FinalTestT2T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T9RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T9'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T9Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_thuri12* updates
    if (t >= 0.2 && image_thuri12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri12.tStart = t;  // (not accounting for frame time here)
      image_thuri12.frameNStart = frameN;  // exact frame index
      
      image_thuri12.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri12.setAutoDraw(false);
    }
    
    // *image_ththuri12* updates
    if (t >= 0.2 && image_ththuri12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri12.tStart = t;  // (not accounting for frame time here)
      image_ththuri12.frameNStart = frameN;  // exact frame index
      
      image_ththuri12.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri12.setAutoDraw(false);
    }
    
    // *text_FT_T2T9_1* updates
    if (t >= 0.2 && text_FT_T2T9_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T9_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T9_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T9_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T9_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T9_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T9_0* updates
    if (t >= 0.2 && text_FT_T2T9_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T9_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T9_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T9_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T9_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T9_0.setAutoDraw(false);
    }
    // start/stop sound_thuri9
    if (t >= 0.2 && sound_thuri9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thuri9.tStart = t;  // (not accounting for frame time here)
      sound_thuri9.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thuri9.play(); });  // screen flip
      sound_thuri9.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thuri9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_thuri9.stop();  // stop the sound (if longer than duration)
        sound_thuri9.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T9* updates
    if (t >= 0.0 && text_FT_T2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T9.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T9.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T9.setAutoDraw(false);
    }
    
    // *key_FT_T2T9* updates
    if (t >= 4.2 && key_FT_T2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T9.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T9.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T9.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T9.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T9_allKeys = _key_FT_T2T9_allKeys.concat(theseKeys);
      if (_key_FT_T2T9_allKeys.length > 0) {
        key_FT_T2T9.keys = _key_FT_T2T9_allKeys[_key_FT_T2T9_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T9.rt = _key_FT_T2T9_allKeys[_key_FT_T2T9_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T9.keys == '1') {
            key_FT_T2T9.corr = 1;
        } else {
            key_FT_T2T9.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T9* updates
    if (t >= 0.0 && phases_FT_T2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T9.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T9.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T9.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T9RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T9'-------
    FinalTestT2T9Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thuri9.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T9.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T2T9.corr = 1;  // correct non-response
      } else {
         key_FT_T2T9.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T9.keys', key_FT_T2T9.keys);
    psychoJS.experiment.addData('key_FT_T2T9.corr', key_FT_T2T9.corr);
    if (typeof key_FT_T2T9.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T9.rt', key_FT_T2T9.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T9.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T10_allKeys;
var FinalTestT2T10Components;
function FinalTestT2T10RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T10'-------
    t = 0;
    FinalTestT2T10Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththami9.secs=4;
    sound_ththami9.setVolume(1);
    key_FT_T2T10.keys = undefined;
    key_FT_T2T10.rt = undefined;
    _key_FT_T2T10_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T10Components = [];
    FinalTestT2T10Components.push(image_thami13);
    FinalTestT2T10Components.push(image_ththami13);
    FinalTestT2T10Components.push(text_FT_T2T10_1);
    FinalTestT2T10Components.push(text_FT_T2T10_0);
    FinalTestT2T10Components.push(sound_ththami9);
    FinalTestT2T10Components.push(text_FT_T2T10);
    FinalTestT2T10Components.push(key_FT_T2T10);
    FinalTestT2T10Components.push(phases_FT_T2T10);
    
    FinalTestT2T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T10RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T10'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T10Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_thami13* updates
    if (t >= 0.2 && image_thami13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thami13.tStart = t;  // (not accounting for frame time here)
      image_thami13.frameNStart = frameN;  // exact frame index
      
      image_thami13.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thami13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thami13.setAutoDraw(false);
    }
    
    // *image_ththami13* updates
    if (t >= 0.2 && image_ththami13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththami13.tStart = t;  // (not accounting for frame time here)
      image_ththami13.frameNStart = frameN;  // exact frame index
      
      image_ththami13.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththami13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththami13.setAutoDraw(false);
    }
    
    // *text_FT_T2T10_1* updates
    if (t >= 0.2 && text_FT_T2T10_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T10_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T10_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T10_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T10_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T10_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T10_0* updates
    if (t >= 0.2 && text_FT_T2T10_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T10_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T10_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T10_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T10_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T10_0.setAutoDraw(false);
    }
    // start/stop sound_ththami9
    if (t >= 0.2 && sound_ththami9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththami9.tStart = t;  // (not accounting for frame time here)
      sound_ththami9.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththami9.play(); });  // screen flip
      sound_ththami9.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththami9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththami9.stop();  // stop the sound (if longer than duration)
        sound_ththami9.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T10* updates
    if (t >= 0.0 && text_FT_T2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T10.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T10.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T10.setAutoDraw(false);
    }
    
    // *key_FT_T2T10* updates
    if (t >= 4.2 && key_FT_T2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T10.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T10.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T10.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T10.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T10_allKeys = _key_FT_T2T10_allKeys.concat(theseKeys);
      if (_key_FT_T2T10_allKeys.length > 0) {
        key_FT_T2T10.keys = _key_FT_T2T10_allKeys[_key_FT_T2T10_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T10.rt = _key_FT_T2T10_allKeys[_key_FT_T2T10_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T10.keys == '0') {
            key_FT_T2T10.corr = 1;
        } else {
            key_FT_T2T10.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T10* updates
    if (t >= 0.0 && phases_FT_T2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T10.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T10.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T10.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T10RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T10'-------
    FinalTestT2T10Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththami9.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T10.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T2T10.corr = 1;  // correct non-response
      } else {
         key_FT_T2T10.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T10.keys', key_FT_T2T10.keys);
    psychoJS.experiment.addData('key_FT_T2T10.corr', key_FT_T2T10.corr);
    if (typeof key_FT_T2T10.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T10.rt', key_FT_T2T10.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T10.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T11_allKeys;
var FinalTestT2T11Components;
function FinalTestT2T11RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T11'-------
    t = 0;
    FinalTestT2T11Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththano10.secs=4;
    sound_ththano10.setVolume(1);
    key_FT_T2T11.keys = undefined;
    key_FT_T2T11.rt = undefined;
    _key_FT_T2T11_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T11Components = [];
    FinalTestT2T11Components.push(image_thano13);
    FinalTestT2T11Components.push(image_ththano13);
    FinalTestT2T11Components.push(text_FT_T2T11_1);
    FinalTestT2T11Components.push(text_FT_T2T11_0);
    FinalTestT2T11Components.push(sound_ththano10);
    FinalTestT2T11Components.push(text_FT_T2T11);
    FinalTestT2T11Components.push(key_FT_T2T11);
    FinalTestT2T11Components.push(phases_FT_T2T11);
    
    FinalTestT2T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T11RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T11'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T11Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_thano13* updates
    if (t >= 0.2 && image_thano13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thano13.tStart = t;  // (not accounting for frame time here)
      image_thano13.frameNStart = frameN;  // exact frame index
      
      image_thano13.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thano13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thano13.setAutoDraw(false);
    }
    
    // *image_ththano13* updates
    if (t >= 0.2 && image_ththano13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththano13.tStart = t;  // (not accounting for frame time here)
      image_ththano13.frameNStart = frameN;  // exact frame index
      
      image_ththano13.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththano13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththano13.setAutoDraw(false);
    }
    
    // *text_FT_T2T11_1* updates
    if (t >= 0.2 && text_FT_T2T11_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T11_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T11_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T11_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T11_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T11_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T11_0* updates
    if (t >= 0.2 && text_FT_T2T11_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T11_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T11_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T11_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T11_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T11_0.setAutoDraw(false);
    }
    // start/stop sound_ththano10
    if (t >= 0.2 && sound_ththano10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththano10.tStart = t;  // (not accounting for frame time here)
      sound_ththano10.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththano10.play(); });  // screen flip
      sound_ththano10.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththano10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththano10.stop();  // stop the sound (if longer than duration)
        sound_ththano10.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T11* updates
    if (t >= 0.0 && text_FT_T2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T11.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T11.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T11.setAutoDraw(false);
    }
    
    // *key_FT_T2T11* updates
    if (t >= 4.2 && key_FT_T2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T11.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T11.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T11.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T11.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T11_allKeys = _key_FT_T2T11_allKeys.concat(theseKeys);
      if (_key_FT_T2T11_allKeys.length > 0) {
        key_FT_T2T11.keys = _key_FT_T2T11_allKeys[_key_FT_T2T11_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T11.rt = _key_FT_T2T11_allKeys[_key_FT_T2T11_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T11.keys == '0') {
            key_FT_T2T11.corr = 1;
        } else {
            key_FT_T2T11.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T11* updates
    if (t >= 0.0 && phases_FT_T2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T11.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T11.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T11.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T11RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T11'-------
    FinalTestT2T11Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththano10.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T11.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_FT_T2T11.corr = 1;  // correct non-response
      } else {
         key_FT_T2T11.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T11.keys', key_FT_T2T11.keys);
    psychoJS.experiment.addData('key_FT_T2T11.corr', key_FT_T2T11.corr);
    if (typeof key_FT_T2T11.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T11.rt', key_FT_T2T11.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T11.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FT_T2T12_allKeys;
var FinalTestT2T12Components;
function FinalTestT2T12RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'FinalTestT2T12'-------
    t = 0;
    FinalTestT2T12Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(9.200000);
    // update component parameters for each repeat
    sound_ththuri9.secs=4;
    sound_ththuri9.setVolume(1);
    key_FT_T2T12.keys = undefined;
    key_FT_T2T12.rt = undefined;
    _key_FT_T2T12_allKeys = [];
    // keep track of which components have finished
    FinalTestT2T12Components = [];
    FinalTestT2T12Components.push(image_ththuri13);
    FinalTestT2T12Components.push(image_thuri13);
    FinalTestT2T12Components.push(text_FT_T2T12_1);
    FinalTestT2T12Components.push(text_FT_T2T12_0);
    FinalTestT2T12Components.push(sound_ththuri9);
    FinalTestT2T12Components.push(text_FT_T2T12);
    FinalTestT2T12Components.push(key_FT_T2T12);
    FinalTestT2T12Components.push(phases_FT_T2T12);
    
    FinalTestT2T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function FinalTestT2T12RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'FinalTestT2T12'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FinalTestT2T12Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *image_ththuri13* updates
    if (t >= 0.2 && image_ththuri13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_ththuri13.tStart = t;  // (not accounting for frame time here)
      image_ththuri13.frameNStart = frameN;  // exact frame index
      
      image_ththuri13.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_ththuri13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_ththuri13.setAutoDraw(false);
    }
    
    // *image_thuri13* updates
    if (t >= 0.2 && image_thuri13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_thuri13.tStart = t;  // (not accounting for frame time here)
      image_thuri13.frameNStart = frameN;  // exact frame index
      
      image_thuri13.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (image_thuri13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      image_thuri13.setAutoDraw(false);
    }
    
    // *text_FT_T2T12_1* updates
    if (t >= 0.2 && text_FT_T2T12_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T12_1.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T12_1.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T12_1.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T12_1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T12_1.setAutoDraw(false);
    }
    
    // *text_FT_T2T12_0* updates
    if (t >= 0.2 && text_FT_T2T12_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T12_0.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T12_0.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T12_0.setAutoDraw(true);
    }

    frameRemains = 0.2 + 9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T12_0.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T12_0.setAutoDraw(false);
    }
    // start/stop sound_ththuri9
    if (t >= 0.2 && sound_ththuri9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththuri9.tStart = t;  // (not accounting for frame time here)
      sound_ththuri9.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththuri9.play(); });  // screen flip
      sound_ththuri9.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 4 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththuri9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (4 > 0.5) {  sound_ththuri9.stop();  // stop the sound (if longer than duration)
        sound_ththuri9.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *text_FT_T2T12* updates
    if (t >= 0.0 && text_FT_T2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_FT_T2T12.tStart = t;  // (not accounting for frame time here)
      text_FT_T2T12.frameNStart = frameN;  // exact frame index
      
      text_FT_T2T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_FT_T2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_FT_T2T12.setAutoDraw(false);
    }
    
    // *key_FT_T2T12* updates
    if (t >= 4.2 && key_FT_T2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FT_T2T12.tStart = t;  // (not accounting for frame time here)
      key_FT_T2T12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FT_T2T12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FT_T2T12.clearEvents(); });
    }

    frameRemains = 4.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_FT_T2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_FT_T2T12.status = PsychoJS.Status.FINISHED;
  }

    if (key_FT_T2T12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FT_T2T12.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_FT_T2T12_allKeys = _key_FT_T2T12_allKeys.concat(theseKeys);
      if (_key_FT_T2T12_allKeys.length > 0) {
        key_FT_T2T12.keys = _key_FT_T2T12_allKeys[_key_FT_T2T12_allKeys.length - 1].name;  // just the last key pressed
        key_FT_T2T12.rt = _key_FT_T2T12_allKeys[_key_FT_T2T12_allKeys.length - 1].rt;
        // was this correct?
        if (key_FT_T2T12.keys == '1') {
            key_FT_T2T12.corr = 1;
        } else {
            key_FT_T2T12.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_FT_T2T12* updates
    if (t >= 0.0 && phases_FT_T2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_FT_T2T12.tStart = t;  // (not accounting for frame time here)
      phases_FT_T2T12.frameNStart = frameN;  // exact frame index
      
      phases_FT_T2T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 9.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_FT_T2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_FT_T2T12.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FinalTestT2T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FinalTestT2T12RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'FinalTestT2T12'-------
    FinalTestT2T12Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththuri9.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_FT_T2T12.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_FT_T2T12.corr = 1;  // correct non-response
      } else {
         key_FT_T2T12.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_FT_T2T12.keys', key_FT_T2T12.keys);
    psychoJS.experiment.addData('key_FT_T2T12.corr', key_FT_T2T12.corr);
    if (typeof key_FT_T2T12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FT_T2T12.rt', key_FT_T2T12.rt);
        routineTimer.reset();
        }
    
    key_FT_T2T12.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_FTEng_allKeys;
var EndPhase4Components;
function EndPhase4RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'EndPhase4'-------
    t = 0;
    EndPhase4Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_FTEng.keys = undefined;
    key_FTEng.rt = undefined;
    _key_FTEng_allKeys = [];
    // keep track of which components have finished
    EndPhase4Components = [];
    EndPhase4Components.push(text_EndFT);
    EndPhase4Components.push(key_FTEng);
    EndPhase4Components.push(phases_endFT);
    
    EndPhase4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function EndPhase4RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'EndPhase4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = EndPhase4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_EndFT* updates
    if (t >= 0.0 && text_EndFT.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_EndFT.tStart = t;  // (not accounting for frame time here)
      text_EndFT.frameNStart = frameN;  // exact frame index
      
      text_EndFT.setAutoDraw(true);
    }

    
    // *key_FTEng* updates
    if (t >= 0.0 && key_FTEng.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_FTEng.tStart = t;  // (not accounting for frame time here)
      key_FTEng.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_FTEng.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_FTEng.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_FTEng.clearEvents(); });
    }

    if (key_FTEng.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_FTEng.getKeys({keyList: ['space'], waitRelease: false});
      _key_FTEng_allKeys = _key_FTEng_allKeys.concat(theseKeys);
      if (_key_FTEng_allKeys.length > 0) {
        key_FTEng.keys = _key_FTEng_allKeys[_key_FTEng_allKeys.length - 1].name;  // just the last key pressed
        key_FTEng.rt = _key_FTEng_allKeys[_key_FTEng_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_endFT* updates
    if (t >= 0.0 && phases_endFT.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_endFT.tStart = t;  // (not accounting for frame time here)
      phases_endFT.frameNStart = frameN;  // exact frame index
      
      phases_endFT.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    EndPhase4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function EndPhase4RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'EndPhase4'-------
    EndPhase4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_FTEng.keys', key_FTEng.keys);
    if (typeof key_FTEng.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_FTEng.rt', key_FTEng.rt);
        routineTimer.reset();
        }
    
    key_FTEng.stop();
    // the Routine "EndPhase4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_SRpos_instructions_allKeys;
var Phase5Instructions1Components;
function Phase5Instructions1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5Instructions1'-------
    t = 0;
    Phase5Instructions1Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_SRpos_instructions.keys = undefined;
    key_SRpos_instructions.rt = undefined;
    _key_SRpos_instructions_allKeys = [];
    // keep track of which components have finished
    Phase5Instructions1Components = [];
    Phase5Instructions1Components.push(text_SRpos_tinstructions1);
    Phase5Instructions1Components.push(key_SRpos_instructions);
    
    Phase5Instructions1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5Instructions1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5Instructions1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5Instructions1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_SRpos_tinstructions1* updates
    if (t >= 0.0 && text_SRpos_tinstructions1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_SRpos_tinstructions1.tStart = t;  // (not accounting for frame time here)
      text_SRpos_tinstructions1.frameNStart = frameN;  // exact frame index
      
      text_SRpos_tinstructions1.setAutoDraw(true);
    }

    
    // *key_SRpos_instructions* updates
    if (t >= 0.0 && key_SRpos_instructions.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_SRpos_instructions.tStart = t;  // (not accounting for frame time here)
      key_SRpos_instructions.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_SRpos_instructions.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_SRpos_instructions.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_SRpos_instructions.clearEvents(); });
    }

    if (key_SRpos_instructions.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_SRpos_instructions.getKeys({keyList: ['space'], waitRelease: false});
      _key_SRpos_instructions_allKeys = _key_SRpos_instructions_allKeys.concat(theseKeys);
      if (_key_SRpos_instructions_allKeys.length > 0) {
        key_SRpos_instructions.keys = _key_SRpos_instructions_allKeys[_key_SRpos_instructions_allKeys.length - 1].name;  // just the last key pressed
        key_SRpos_instructions.rt = _key_SRpos_instructions_allKeys[_key_SRpos_instructions_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5Instructions1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5Instructions1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5Instructions1'-------
    Phase5Instructions1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_SRpos_instructions.keys', key_SRpos_instructions.keys);
    if (typeof key_SRpos_instructions.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_SRpos_instructions.rt', key_SRpos_instructions.rt);
        routineTimer.reset();
        }
    
    key_SRpos_instructions.stop();
    // the Routine "Phase5Instructions1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T1_allKeys;
var Phase5T1T1Components;
function Phase5T1T1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T1'-------
    t = 0;
    Phase5T1T1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_thth9.secs=5;
    sound_thth9.setVolume(1);
    sound_th6.secs=5;
    sound_th6.setVolume(1);
    key_Ph5T1T1.keys = undefined;
    key_Ph5T1T1.rt = undefined;
    _key_Ph5T1T1_allKeys = [];
    // keep track of which components have finished
    Phase5T1T1Components = [];
    Phase5T1T1Components.push(sound_thth9);
    Phase5T1T1Components.push(sound_th6);
    Phase5T1T1Components.push(key_Ph5T1T1);
    Phase5T1T1Components.push(text_Ph5T1T1);
    Phase5T1T1Components.push(phases_Ph5T1T1);
    
    Phase5T1T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thth9
    if (t >= 0.2 && sound_thth9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth9.tStart = t;  // (not accounting for frame time here)
      sound_thth9.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth9.play(); });  // screen flip
      sound_thth9.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth9.stop();  // stop the sound (if longer than duration)
        sound_thth9.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_th6
    if (t >= 4.5 && sound_th6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th6.tStart = t;  // (not accounting for frame time here)
      sound_th6.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th6.play(); });  // screen flip
      sound_th6.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th6.stop();  // stop the sound (if longer than duration)
        sound_th6.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T1* updates
    if (t >= 8 && key_Ph5T1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T1.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T1.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T1.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T1.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T1.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T1.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T1.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T1.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T1_allKeys = _key_Ph5T1T1_allKeys.concat(theseKeys);
      if (_key_Ph5T1T1_allKeys.length > 0) {
        key_Ph5T1T1.keys = _key_Ph5T1T1_allKeys[_key_Ph5T1T1_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T1.rt = _key_Ph5T1T1_allKeys[_key_Ph5T1T1_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T1.keys == '0') {
            key_Ph5T1T1.corr = 1;
        } else {
            key_Ph5T1T1.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T1* updates
    if (t >= 0.0 && text_Ph5T1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T1.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T1.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T1.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T1* updates
    if (t >= 0.0 && phases_Ph5T1T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T1.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T1.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T1.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T1'-------
    Phase5T1T1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thth9.stop();  // ensure sound has stopped at end of routine
    sound_th6.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T1.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T1T1.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T1.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T1.keys', key_Ph5T1T1.keys);
    psychoJS.experiment.addData('key_Ph5T1T1.corr', key_Ph5T1T1.corr);
    if (typeof key_Ph5T1T1.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T1.rt', key_Ph5T1T1.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T1.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T2_allKeys;
var Phase5T1T2Components;
function Phase5T1T2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T2'-------
    t = 0;
    Phase5T1T2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_thth10.secs=5;
    sound_thth10.setVolume(1);
    sound_thth11.secs=5;
    sound_thth11.setVolume(1);
    key_Ph5T1T2.keys = undefined;
    key_Ph5T1T2.rt = undefined;
    _key_Ph5T1T2_allKeys = [];
    // keep track of which components have finished
    Phase5T1T2Components = [];
    Phase5T1T2Components.push(sound_thth10);
    Phase5T1T2Components.push(sound_thth11);
    Phase5T1T2Components.push(key_Ph5T1T2);
    Phase5T1T2Components.push(text_Ph5T1T2);
    Phase5T1T2Components.push(phases_Ph5T1T2);
    
    Phase5T1T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thth10
    if (t >= 0.2 && sound_thth10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth10.tStart = t;  // (not accounting for frame time here)
      sound_thth10.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth10.play(); });  // screen flip
      sound_thth10.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth10.stop();  // stop the sound (if longer than duration)
        sound_thth10.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_thth11
    if (t >= 4.5 && sound_thth11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth11.tStart = t;  // (not accounting for frame time here)
      sound_thth11.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth11.play(); });  // screen flip
      sound_thth11.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth11.stop();  // stop the sound (if longer than duration)
        sound_thth11.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T2* updates
    if (t >= 8 && key_Ph5T1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T2.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T2.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T2.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T2.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T2_allKeys = _key_Ph5T1T2_allKeys.concat(theseKeys);
      if (_key_Ph5T1T2_allKeys.length > 0) {
        key_Ph5T1T2.keys = _key_Ph5T1T2_allKeys[_key_Ph5T1T2_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T2.rt = _key_Ph5T1T2_allKeys[_key_Ph5T1T2_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T2.keys == '1') {
            key_Ph5T1T2.corr = 1;
        } else {
            key_Ph5T1T2.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T2* updates
    if (t >= 0.0 && text_Ph5T1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T2.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T2.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T2.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T2* updates
    if (t >= 0.0 && phases_Ph5T1T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T2.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T2.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T2'-------
    Phase5T1T2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thth10.stop();  // ensure sound has stopped at end of routine
    sound_thth11.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T2.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T1T2.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T2.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T2.keys', key_Ph5T1T2.keys);
    psychoJS.experiment.addData('key_Ph5T1T2.corr', key_Ph5T1T2.corr);
    if (typeof key_Ph5T1T2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T2.rt', key_Ph5T1T2.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T2.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T3_allKeys;
var Phase5T1T3Components;
function Phase5T1T3RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T3'-------
    t = 0;
    Phase5T1T3Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_thth12.secs=5;
    sound_thth12.setVolume(1);
    sound_sh9.secs=5;
    sound_sh9.setVolume(1);
    key_Ph5T1T3.keys = undefined;
    key_Ph5T1T3.rt = undefined;
    _key_Ph5T1T3_allKeys = [];
    // keep track of which components have finished
    Phase5T1T3Components = [];
    Phase5T1T3Components.push(sound_thth12);
    Phase5T1T3Components.push(sound_sh9);
    Phase5T1T3Components.push(key_Ph5T1T3);
    Phase5T1T3Components.push(text_Ph5T1T3);
    Phase5T1T3Components.push(phases_Ph5T1T3);
    
    Phase5T1T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T3RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thth12
    if (t >= 0.2 && sound_thth12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth12.tStart = t;  // (not accounting for frame time here)
      sound_thth12.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth12.play(); });  // screen flip
      sound_thth12.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth12.stop();  // stop the sound (if longer than duration)
        sound_thth12.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_sh9
    if (t >= 4.5 && sound_sh9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh9.tStart = t;  // (not accounting for frame time here)
      sound_sh9.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh9.play(); });  // screen flip
      sound_sh9.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh9.stop();  // stop the sound (if longer than duration)
        sound_sh9.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T3* updates
    if (t >= 8 && key_Ph5T1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T3.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T3.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T3.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T3.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T3.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T3.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T3.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T3.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T3_allKeys = _key_Ph5T1T3_allKeys.concat(theseKeys);
      if (_key_Ph5T1T3_allKeys.length > 0) {
        key_Ph5T1T3.keys = _key_Ph5T1T3_allKeys[_key_Ph5T1T3_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T3.rt = _key_Ph5T1T3_allKeys[_key_Ph5T1T3_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T3.keys == '0') {
            key_Ph5T1T3.corr = 1;
        } else {
            key_Ph5T1T3.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T3* updates
    if (t >= 0.0 && text_Ph5T1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T3.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T3.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T3.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T3* updates
    if (t >= 0.0 && phases_Ph5T1T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T3.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T3.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T3RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T3'-------
    Phase5T1T3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thth12.stop();  // ensure sound has stopped at end of routine
    sound_sh9.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T3.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T1T3.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T3.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T3.keys', key_Ph5T1T3.keys);
    psychoJS.experiment.addData('key_Ph5T1T3.corr', key_Ph5T1T3.corr);
    if (typeof key_Ph5T1T3.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T3.rt', key_Ph5T1T3.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T3.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T4_allKeys;
var Phase5T1T4Components;
function Phase5T1T4RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T4'-------
    t = 0;
    Phase5T1T4Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_thth13.secs=5;
    sound_thth13.setVolume(1);
    sound_thth14.secs=5;
    sound_thth14.setVolume(1);
    key_Ph5T1T4.keys = undefined;
    key_Ph5T1T4.rt = undefined;
    _key_Ph5T1T4_allKeys = [];
    // keep track of which components have finished
    Phase5T1T4Components = [];
    Phase5T1T4Components.push(sound_thth13);
    Phase5T1T4Components.push(sound_thth14);
    Phase5T1T4Components.push(key_Ph5T1T4);
    Phase5T1T4Components.push(text_Ph5T1T4);
    Phase5T1T4Components.push(phases_Ph5T1T4);
    
    Phase5T1T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T4RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thth13
    if (t >= 0.2 && sound_thth13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth13.tStart = t;  // (not accounting for frame time here)
      sound_thth13.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth13.play(); });  // screen flip
      sound_thth13.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth13.stop();  // stop the sound (if longer than duration)
        sound_thth13.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_thth14
    if (t >= 4.5 && sound_thth14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth14.tStart = t;  // (not accounting for frame time here)
      sound_thth14.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth14.play(); });  // screen flip
      sound_thth14.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth14.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth14.stop();  // stop the sound (if longer than duration)
        sound_thth14.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T4* updates
    if (t >= 8 && key_Ph5T1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T4.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T4.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T4.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T4.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T4_allKeys = _key_Ph5T1T4_allKeys.concat(theseKeys);
      if (_key_Ph5T1T4_allKeys.length > 0) {
        key_Ph5T1T4.keys = _key_Ph5T1T4_allKeys[_key_Ph5T1T4_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T4.rt = _key_Ph5T1T4_allKeys[_key_Ph5T1T4_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T4.keys == '1') {
            key_Ph5T1T4.corr = 1;
        } else {
            key_Ph5T1T4.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T4* updates
    if (t >= 0.0 && text_Ph5T1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T4.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T4.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T4.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T4* updates
    if (t >= 0.0 && phases_Ph5T1T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T4.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T4.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T4.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T4RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T4'-------
    Phase5T1T4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thth13.stop();  // ensure sound has stopped at end of routine
    sound_thth14.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T4.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T1T4.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T4.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T4.keys', key_Ph5T1T4.keys);
    psychoJS.experiment.addData('key_Ph5T1T4.corr', key_Ph5T1T4.corr);
    if (typeof key_Ph5T1T4.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T4.rt', key_Ph5T1T4.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T4.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T5_allKeys;
var Phase5T1T5Components;
function Phase5T1T5RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T5'-------
    t = 0;
    Phase5T1T5Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_th10.secs=5;
    sound_th10.setVolume(1);
    sound_thth15.secs=5;
    sound_thth15.setVolume(1);
    key_Ph5T1T5.keys = undefined;
    key_Ph5T1T5.rt = undefined;
    _key_Ph5T1T5_allKeys = [];
    // keep track of which components have finished
    Phase5T1T5Components = [];
    Phase5T1T5Components.push(sound_th10);
    Phase5T1T5Components.push(sound_thth15);
    Phase5T1T5Components.push(key_Ph5T1T5);
    Phase5T1T5Components.push(text_Ph5T1T5);
    Phase5T1T5Components.push(phases_Ph5T1T5);
    
    Phase5T1T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T5RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T5'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_th10
    if (t >= 0.2 && sound_th10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th10.tStart = t;  // (not accounting for frame time here)
      sound_th10.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th10.play(); });  // screen flip
      sound_th10.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th10.stop();  // stop the sound (if longer than duration)
        sound_th10.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_thth15
    if (t >= 4.5 && sound_thth15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth15.tStart = t;  // (not accounting for frame time here)
      sound_thth15.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth15.play(); });  // screen flip
      sound_thth15.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth15.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth15.stop();  // stop the sound (if longer than duration)
        sound_thth15.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T5* updates
    if (t >= 8 && key_Ph5T1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T5.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T5.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T5.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T5.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T5_allKeys = _key_Ph5T1T5_allKeys.concat(theseKeys);
      if (_key_Ph5T1T5_allKeys.length > 0) {
        key_Ph5T1T5.keys = _key_Ph5T1T5_allKeys[_key_Ph5T1T5_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T5.rt = _key_Ph5T1T5_allKeys[_key_Ph5T1T5_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T5.keys == '0') {
            key_Ph5T1T5.corr = 1;
        } else {
            key_Ph5T1T5.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T5* updates
    if (t >= 0.0 && text_Ph5T1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T5.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T5.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T5.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T5* updates
    if (t >= 0.0 && phases_Ph5T1T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T5.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T5.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T5RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T5'-------
    Phase5T1T5Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_th10.stop();  // ensure sound has stopped at end of routine
    sound_thth15.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T5.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T1T5.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T5.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T5.keys', key_Ph5T1T5.keys);
    psychoJS.experiment.addData('key_Ph5T1T5.corr', key_Ph5T1T5.corr);
    if (typeof key_Ph5T1T5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T5.rt', key_Ph5T1T5.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T5.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T6_allKeys;
var Phase5T1T6Components;
function Phase5T1T6RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T6'-------
    t = 0;
    Phase5T1T6Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_th11.secs=5;
    sound_th11.setVolume(1);
    sound_th12.secs=5;
    sound_th12.setVolume(1);
    key_Ph5T1T6.keys = undefined;
    key_Ph5T1T6.rt = undefined;
    _key_Ph5T1T6_allKeys = [];
    // keep track of which components have finished
    Phase5T1T6Components = [];
    Phase5T1T6Components.push(sound_th11);
    Phase5T1T6Components.push(sound_th12);
    Phase5T1T6Components.push(key_Ph5T1T6);
    Phase5T1T6Components.push(text_Ph5T1T6);
    Phase5T1T6Components.push(phases_Ph5T1T6);
    
    Phase5T1T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T6RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T6'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_th11
    if (t >= 0.2 && sound_th11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th11.tStart = t;  // (not accounting for frame time here)
      sound_th11.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th11.play(); });  // screen flip
      sound_th11.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th11.stop();  // stop the sound (if longer than duration)
        sound_th11.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_th12
    if (t >= 4.5 && sound_th12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th12.tStart = t;  // (not accounting for frame time here)
      sound_th12.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th12.play(); });  // screen flip
      sound_th12.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th12.stop();  // stop the sound (if longer than duration)
        sound_th12.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T6* updates
    if (t >= 8 && key_Ph5T1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T6.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T6.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T6.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T6.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T6.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T6.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T6.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T6.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T6_allKeys = _key_Ph5T1T6_allKeys.concat(theseKeys);
      if (_key_Ph5T1T6_allKeys.length > 0) {
        key_Ph5T1T6.keys = _key_Ph5T1T6_allKeys[_key_Ph5T1T6_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T6.rt = _key_Ph5T1T6_allKeys[_key_Ph5T1T6_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T6.keys == '1') {
            key_Ph5T1T6.corr = 1;
        } else {
            key_Ph5T1T6.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T6* updates
    if (t >= 0.0 && text_Ph5T1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T6.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T6.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T6.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T6* updates
    if (t >= 0.0 && phases_Ph5T1T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T6.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T6.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T6.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T6RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T6'-------
    Phase5T1T6Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_th11.stop();  // ensure sound has stopped at end of routine
    sound_th12.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T6.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T1T6.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T6.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T6.keys', key_Ph5T1T6.keys);
    psychoJS.experiment.addData('key_Ph5T1T6.corr', key_Ph5T1T6.corr);
    if (typeof key_Ph5T1T6.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T6.rt', key_Ph5T1T6.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T6.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T7_allKeys;
var Phase5T1T7Components;
function Phase5T1T7RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T7'-------
    t = 0;
    Phase5T1T7Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_th13.secs=5;
    sound_th13.setVolume(1);
    sound_sh10.secs=5;
    sound_sh10.setVolume(1);
    key_Ph5T1T7.keys = undefined;
    key_Ph5T1T7.rt = undefined;
    _key_Ph5T1T7_allKeys = [];
    // keep track of which components have finished
    Phase5T1T7Components = [];
    Phase5T1T7Components.push(sound_th13);
    Phase5T1T7Components.push(sound_sh10);
    Phase5T1T7Components.push(key_Ph5T1T7);
    Phase5T1T7Components.push(text_Ph5T1T7);
    Phase5T1T7Components.push(phases_Ph5T1T7);
    
    Phase5T1T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T7RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T7'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_th13
    if (t >= 0.2 && sound_th13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th13.tStart = t;  // (not accounting for frame time here)
      sound_th13.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th13.play(); });  // screen flip
      sound_th13.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th13.stop();  // stop the sound (if longer than duration)
        sound_th13.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_sh10
    if (t >= 4.5 && sound_sh10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh10.tStart = t;  // (not accounting for frame time here)
      sound_sh10.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh10.play(); });  // screen flip
      sound_sh10.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh10.stop();  // stop the sound (if longer than duration)
        sound_sh10.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T7* updates
    if (t >= 8 && key_Ph5T1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T7.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T7.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T7.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T7.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T7.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T7.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T7.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T7.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T7_allKeys = _key_Ph5T1T7_allKeys.concat(theseKeys);
      if (_key_Ph5T1T7_allKeys.length > 0) {
        key_Ph5T1T7.keys = _key_Ph5T1T7_allKeys[_key_Ph5T1T7_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T7.rt = _key_Ph5T1T7_allKeys[_key_Ph5T1T7_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T7.keys == '0') {
            key_Ph5T1T7.corr = 1;
        } else {
            key_Ph5T1T7.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T7* updates
    if (t >= 0.0 && text_Ph5T1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T7.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T7.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T7.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T7* updates
    if (t >= 0.0 && phases_Ph5T1T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T7.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T7.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T7.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T7RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T7'-------
    Phase5T1T7Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_th13.stop();  // ensure sound has stopped at end of routine
    sound_sh10.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T7.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T1T7.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T7.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T7.keys', key_Ph5T1T7.keys);
    psychoJS.experiment.addData('key_Ph5T1T7.corr', key_Ph5T1T7.corr);
    if (typeof key_Ph5T1T7.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T7.rt', key_Ph5T1T7.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T7.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T8_allKeys;
var Phase5T1T8Components;
function Phase5T1T8RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T8'-------
    t = 0;
    Phase5T1T8Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_th14.secs=5;
    sound_th14.setVolume(1);
    sound_th15.secs=5;
    sound_th15.setVolume(1);
    key_Ph5T1T8.keys = undefined;
    key_Ph5T1T8.rt = undefined;
    _key_Ph5T1T8_allKeys = [];
    // keep track of which components have finished
    Phase5T1T8Components = [];
    Phase5T1T8Components.push(sound_th14);
    Phase5T1T8Components.push(sound_th15);
    Phase5T1T8Components.push(key_Ph5T1T8);
    Phase5T1T8Components.push(text_Ph5T1T8);
    Phase5T1T8Components.push(phases_Ph5T1T8);
    
    Phase5T1T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T8RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T8'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T8Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_th14
    if (t >= 0.2 && sound_th14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th14.tStart = t;  // (not accounting for frame time here)
      sound_th14.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th14.play(); });  // screen flip
      sound_th14.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th14.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th14.stop();  // stop the sound (if longer than duration)
        sound_th14.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_th15
    if (t >= 4.5 && sound_th15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th15.tStart = t;  // (not accounting for frame time here)
      sound_th15.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th15.play(); });  // screen flip
      sound_th15.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th15.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th15.stop();  // stop the sound (if longer than duration)
        sound_th15.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T8* updates
    if (t >= 8 && key_Ph5T1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T8.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T8.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T8.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T8.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T8.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T8.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T8.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T8.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T8_allKeys = _key_Ph5T1T8_allKeys.concat(theseKeys);
      if (_key_Ph5T1T8_allKeys.length > 0) {
        key_Ph5T1T8.keys = _key_Ph5T1T8_allKeys[_key_Ph5T1T8_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T8.rt = _key_Ph5T1T8_allKeys[_key_Ph5T1T8_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T8.keys == '0') {
            key_Ph5T1T8.corr = 1;
        } else {
            key_Ph5T1T8.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T8* updates
    if (t >= 0.0 && text_Ph5T1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T8.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T8.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T8.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T8* updates
    if (t >= 0.0 && phases_Ph5T1T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T8.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T8.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T8.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T8RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T8'-------
    Phase5T1T8Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_th14.stop();  // ensure sound has stopped at end of routine
    sound_th15.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T8.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T1T8.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T8.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T8.keys', key_Ph5T1T8.keys);
    psychoJS.experiment.addData('key_Ph5T1T8.corr', key_Ph5T1T8.corr);
    if (typeof key_Ph5T1T8.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T8.rt', key_Ph5T1T8.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T8.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T9_allKeys;
var Phase5T1T9Components;
function Phase5T1T9RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T9'-------
    t = 0;
    Phase5T1T9Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_sh11.secs=5;
    sound_sh11.setVolume(1);
    sound_thth16.secs=5;
    sound_thth16.setVolume(1);
    key_Ph5T1T9.keys = undefined;
    key_Ph5T1T9.rt = undefined;
    _key_Ph5T1T9_allKeys = [];
    // keep track of which components have finished
    Phase5T1T9Components = [];
    Phase5T1T9Components.push(sound_sh11);
    Phase5T1T9Components.push(sound_thth16);
    Phase5T1T9Components.push(key_Ph5T1T9);
    Phase5T1T9Components.push(text_Ph5T1T9);
    Phase5T1T9Components.push(phases_Ph5T1T9);
    
    Phase5T1T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T9RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T9'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T9Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_sh11
    if (t >= 0.2 && sound_sh11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh11.tStart = t;  // (not accounting for frame time here)
      sound_sh11.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh11.play(); });  // screen flip
      sound_sh11.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh11.stop();  // stop the sound (if longer than duration)
        sound_sh11.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_thth16
    if (t >= 4.5 && sound_thth16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thth16.tStart = t;  // (not accounting for frame time here)
      sound_thth16.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thth16.play(); });  // screen flip
      sound_thth16.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thth16.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thth16.stop();  // stop the sound (if longer than duration)
        sound_thth16.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T9* updates
    if (t >= 8 && key_Ph5T1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T9.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T9.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T9.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T9.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T9_allKeys = _key_Ph5T1T9_allKeys.concat(theseKeys);
      if (_key_Ph5T1T9_allKeys.length > 0) {
        key_Ph5T1T9.keys = _key_Ph5T1T9_allKeys[_key_Ph5T1T9_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T9.rt = _key_Ph5T1T9_allKeys[_key_Ph5T1T9_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T9.keys == '0') {
            key_Ph5T1T9.corr = 1;
        } else {
            key_Ph5T1T9.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T9* updates
    if (t >= 0.0 && text_Ph5T1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T9.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T9.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T9.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T9* updates
    if (t >= 0.0 && phases_Ph5T1T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T9.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T9.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T9.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T9RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T9'-------
    Phase5T1T9Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_sh11.stop();  // ensure sound has stopped at end of routine
    sound_thth16.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T9.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T1T9.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T9.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T9.keys', key_Ph5T1T9.keys);
    psychoJS.experiment.addData('key_Ph5T1T9.corr', key_Ph5T1T9.corr);
    if (typeof key_Ph5T1T9.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T9.rt', key_Ph5T1T9.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T9.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T10_allKeys;
var Phase5T1T10Components;
function Phase5T1T10RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T10'-------
    t = 0;
    Phase5T1T10Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_sh12.secs=5;
    sound_sh12.setVolume(1);
    sound_th16.secs=5;
    sound_th16.setVolume(1);
    key_Ph5T1T10.keys = undefined;
    key_Ph5T1T10.rt = undefined;
    _key_Ph5T1T10_allKeys = [];
    // keep track of which components have finished
    Phase5T1T10Components = [];
    Phase5T1T10Components.push(sound_sh12);
    Phase5T1T10Components.push(sound_th16);
    Phase5T1T10Components.push(key_Ph5T1T10);
    Phase5T1T10Components.push(text_Ph5T1T10);
    Phase5T1T10Components.push(phases_Ph5T1T10);
    
    Phase5T1T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T10RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T10'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T10Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_sh12
    if (t >= 0.2 && sound_sh12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh12.tStart = t;  // (not accounting for frame time here)
      sound_sh12.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh12.play(); });  // screen flip
      sound_sh12.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh12.stop();  // stop the sound (if longer than duration)
        sound_sh12.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_th16
    if (t >= 4.5 && sound_th16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_th16.tStart = t;  // (not accounting for frame time here)
      sound_th16.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_th16.play(); });  // screen flip
      sound_th16.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_th16.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_th16.stop();  // stop the sound (if longer than duration)
        sound_th16.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T10* updates
    if (t >= 8 && key_Ph5T1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T10.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T10.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T10.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T10.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T10_allKeys = _key_Ph5T1T10_allKeys.concat(theseKeys);
      if (_key_Ph5T1T10_allKeys.length > 0) {
        key_Ph5T1T10.keys = _key_Ph5T1T10_allKeys[_key_Ph5T1T10_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T10.rt = _key_Ph5T1T10_allKeys[_key_Ph5T1T10_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T10.keys == '0') {
            key_Ph5T1T10.corr = 1;
        } else {
            key_Ph5T1T10.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T10* updates
    if (t >= 0.0 && text_Ph5T1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T10.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T10.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T10.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T10* updates
    if (t >= 0.0 && phases_Ph5T1T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T10.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T10.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T10.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T10RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T10'-------
    Phase5T1T10Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_sh12.stop();  // ensure sound has stopped at end of routine
    sound_th16.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T10.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T1T10.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T10.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T10.keys', key_Ph5T1T10.keys);
    psychoJS.experiment.addData('key_Ph5T1T10.corr', key_Ph5T1T10.corr);
    if (typeof key_Ph5T1T10.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T10.rt', key_Ph5T1T10.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T10.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T11_allKeys;
var Phase5T1T11Components;
function Phase5T1T11RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T11'-------
    t = 0;
    Phase5T1T11Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_sh13.secs=5;
    sound_sh13.setVolume(1);
    sound_sh14.secs=5;
    sound_sh14.setVolume(1);
    key_Ph5T1T11.keys = undefined;
    key_Ph5T1T11.rt = undefined;
    _key_Ph5T1T11_allKeys = [];
    // keep track of which components have finished
    Phase5T1T11Components = [];
    Phase5T1T11Components.push(sound_sh13);
    Phase5T1T11Components.push(sound_sh14);
    Phase5T1T11Components.push(key_Ph5T1T11);
    Phase5T1T11Components.push(text_Ph5T1T11);
    Phase5T1T11Components.push(phases_Ph5T1T11);
    
    Phase5T1T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T11RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T11'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T11Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_sh13
    if (t >= 0.2 && sound_sh13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh13.tStart = t;  // (not accounting for frame time here)
      sound_sh13.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh13.play(); });  // screen flip
      sound_sh13.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh13.stop();  // stop the sound (if longer than duration)
        sound_sh13.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_sh14
    if (t >= 4.5 && sound_sh14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh14.tStart = t;  // (not accounting for frame time here)
      sound_sh14.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh14.play(); });  // screen flip
      sound_sh14.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh14.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh14.stop();  // stop the sound (if longer than duration)
        sound_sh14.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T11* updates
    if (t >= 8 && key_Ph5T1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T11.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T11.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T11.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T11.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T11_allKeys = _key_Ph5T1T11_allKeys.concat(theseKeys);
      if (_key_Ph5T1T11_allKeys.length > 0) {
        key_Ph5T1T11.keys = _key_Ph5T1T11_allKeys[_key_Ph5T1T11_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T11.rt = _key_Ph5T1T11_allKeys[_key_Ph5T1T11_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T11.keys == '1') {
            key_Ph5T1T11.corr = 1;
        } else {
            key_Ph5T1T11.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T11* updates
    if (t >= 0.0 && text_Ph5T1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T11.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T11.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T11.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T11* updates
    if (t >= 0.0 && phases_Ph5T1T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T11.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T11.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T11.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T11RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T11'-------
    Phase5T1T11Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_sh13.stop();  // ensure sound has stopped at end of routine
    sound_sh14.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T11.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T1T11.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T11.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T11.keys', key_Ph5T1T11.keys);
    psychoJS.experiment.addData('key_Ph5T1T11.corr', key_Ph5T1T11.corr);
    if (typeof key_Ph5T1T11.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T11.rt', key_Ph5T1T11.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T11.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T1T12_allKeys;
var Phase5T1T12Components;
function Phase5T1T12RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T1T12'-------
    t = 0;
    Phase5T1T12Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(14.500000);
    // update component parameters for each repeat
    sound_sh15.secs=5;
    sound_sh15.setVolume(1);
    sound_sh16.secs=5;
    sound_sh16.setVolume(1);
    key_Ph5T1T12.keys = undefined;
    key_Ph5T1T12.rt = undefined;
    _key_Ph5T1T12_allKeys = [];
    // keep track of which components have finished
    Phase5T1T12Components = [];
    Phase5T1T12Components.push(sound_sh15);
    Phase5T1T12Components.push(sound_sh16);
    Phase5T1T12Components.push(key_Ph5T1T12);
    Phase5T1T12Components.push(text_Ph5T1T12);
    Phase5T1T12Components.push(phases_Ph5T1T12);
    
    Phase5T1T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T1T12RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T1T12'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T1T12Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_sh15
    if (t >= 0.2 && sound_sh15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh15.tStart = t;  // (not accounting for frame time here)
      sound_sh15.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh15.play(); });  // screen flip
      sound_sh15.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh15.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh15.stop();  // stop the sound (if longer than duration)
        sound_sh15.status = PsychoJS.Status.FINISHED;
      }
    }
    // start/stop sound_sh16
    if (t >= 4.5 && sound_sh16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh16.tStart = t;  // (not accounting for frame time here)
      sound_sh16.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh16.play(); });  // screen flip
      sound_sh16.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 4.5 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh16.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh16.stop();  // stop the sound (if longer than duration)
        sound_sh16.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T1T12* updates
    if (t >= 8 && key_Ph5T1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T1T12.tStart = t;  // (not accounting for frame time here)
      key_Ph5T1T12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T1T12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T1T12.clearEvents(); });
    }

    frameRemains = 8 + 6.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T1T12.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T1T12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T1T12.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T1T12_allKeys = _key_Ph5T1T12_allKeys.concat(theseKeys);
      if (_key_Ph5T1T12_allKeys.length > 0) {
        key_Ph5T1T12.keys = _key_Ph5T1T12_allKeys[_key_Ph5T1T12_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T1T12.rt = _key_Ph5T1T12_allKeys[_key_Ph5T1T12_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T1T12.keys == '1') {
            key_Ph5T1T12.corr = 1;
        } else {
            key_Ph5T1T12.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T1T12* updates
    if (t >= 0.0 && text_Ph5T1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T1T12.tStart = t;  // (not accounting for frame time here)
      text_Ph5T1T12.frameNStart = frameN;  // exact frame index
      
      text_Ph5T1T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T1T12.setAutoDraw(false);
    }
    
    // *phases_Ph5T1T12* updates
    if (t >= 0.0 && phases_Ph5T1T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T1T12.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T1T12.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T1T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 14.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T1T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T1T12.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T1T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T1T12RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T1T12'-------
    Phase5T1T12Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_sh15.stop();  // ensure sound has stopped at end of routine
    sound_sh16.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T1T12.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T1T12.corr = 1;  // correct non-response
      } else {
         key_Ph5T1T12.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T1T12.keys', key_Ph5T1T12.keys);
    psychoJS.experiment.addData('key_Ph5T1T12.corr', key_Ph5T1T12.corr);
    if (typeof key_Ph5T1T12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T1T12.rt', key_Ph5T1T12.rt);
        routineTimer.reset();
        }
    
    key_Ph5T1T12.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T1_allKeys;
var Phase5T2T1Components;
function Phase5T2T1RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T1'-------
    t = 0;
    Phase5T2T1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_thrwa_thrwa2.secs=5;
    sound_thrwa_thrwa2.setVolume(1);
    key_Ph5T2T1.keys = undefined;
    key_Ph5T2T1.rt = undefined;
    _key_Ph5T2T1_allKeys = [];
    // keep track of which components have finished
    Phase5T2T1Components = [];
    Phase5T2T1Components.push(sound_thrwa_thrwa2);
    Phase5T2T1Components.push(key_Ph5T2T1);
    Phase5T2T1Components.push(text_2);
    Phase5T2T1Components.push(phases_Ph5T2T1);
    
    Phase5T2T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T1RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thrwa_thrwa2
    if (t >= 0.2 && sound_thrwa_thrwa2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thrwa_thrwa2.tStart = t;  // (not accounting for frame time here)
      sound_thrwa_thrwa2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thrwa_thrwa2.play(); });  // screen flip
      sound_thrwa_thrwa2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thrwa_thrwa2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thrwa_thrwa2.stop();  // stop the sound (if longer than duration)
        sound_thrwa_thrwa2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T1* updates
    if (t >= 4.2 && key_Ph5T2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T1.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T1.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T1.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T1.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T1.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T1.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T1.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T1.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T1_allKeys = _key_Ph5T2T1_allKeys.concat(theseKeys);
      if (_key_Ph5T2T1_allKeys.length > 0) {
        key_Ph5T2T1.keys = _key_Ph5T2T1_allKeys[_key_Ph5T2T1_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T1.rt = _key_Ph5T2T1_allKeys[_key_Ph5T2T1_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T1.keys == '1') {
            key_Ph5T2T1.corr = 1;
        } else {
            key_Ph5T2T1.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_2* updates
    if (t >= 0.0 && text_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_2.tStart = t;  // (not accounting for frame time here)
      text_2.frameNStart = frameN;  // exact frame index
      
      text_2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_2.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T1* updates
    if (t >= 0.0 && phases_Ph5T2T1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T1.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T1.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T1.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T1.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T1.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T1RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T1'-------
    Phase5T2T1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thrwa_thrwa2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T1.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T2T1.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T1.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T1.keys', key_Ph5T2T1.keys);
    psychoJS.experiment.addData('key_Ph5T2T1.corr', key_Ph5T2T1.corr);
    if (typeof key_Ph5T2T1.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T1.rt', key_Ph5T2T1.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T1.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T2_allKeys;
var Phase5T2T2Components;
function Phase5T2T2RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T2'-------
    t = 0;
    Phase5T2T2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_ththm_thm2.secs=5;
    sound_ththm_thm2.setVolume(1);
    key_Ph5T2T2.keys = undefined;
    key_Ph5T2T2.rt = undefined;
    _key_Ph5T2T2_allKeys = [];
    // keep track of which components have finished
    Phase5T2T2Components = [];
    Phase5T2T2Components.push(sound_ththm_thm2);
    Phase5T2T2Components.push(key_Ph5T2T2);
    Phase5T2T2Components.push(text_Ph5T2T2);
    Phase5T2T2Components.push(phases_Ph5T2T2);
    
    Phase5T2T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T2RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththm_thm2
    if (t >= 0.2 && sound_ththm_thm2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththm_thm2.tStart = t;  // (not accounting for frame time here)
      sound_ththm_thm2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththm_thm2.play(); });  // screen flip
      sound_ththm_thm2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththm_thm2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_ththm_thm2.stop();  // stop the sound (if longer than duration)
        sound_ththm_thm2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T2* updates
    if (t >= 4.2 && key_Ph5T2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T2.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T2.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T2.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T2.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T2_allKeys = _key_Ph5T2T2_allKeys.concat(theseKeys);
      if (_key_Ph5T2T2_allKeys.length > 0) {
        key_Ph5T2T2.keys = _key_Ph5T2T2_allKeys[_key_Ph5T2T2_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T2.rt = _key_Ph5T2T2_allKeys[_key_Ph5T2T2_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T2.keys == '0') {
            key_Ph5T2T2.corr = 1;
        } else {
            key_Ph5T2T2.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T2* updates
    if (t >= 0.0 && text_Ph5T2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T2.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T2.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T2.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T2* updates
    if (t >= 0.0 && phases_Ph5T2T2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T2.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T2.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T2RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T2'-------
    Phase5T2T2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththm_thm2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T2.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T2T2.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T2.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T2.keys', key_Ph5T2T2.keys);
    psychoJS.experiment.addData('key_Ph5T2T2.corr', key_Ph5T2T2.corr);
    if (typeof key_Ph5T2T2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T2.rt', key_Ph5T2T2.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T2.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T3_allKeys;
var Phase5T2T3Components;
function Phase5T2T3RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T3'-------
    t = 0;
    Phase5T2T3Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_ththab_shab2.secs=5;
    sound_ththab_shab2.setVolume(1);
    key_Ph5T2T3.keys = undefined;
    key_Ph5T2T3.rt = undefined;
    _key_Ph5T2T3_allKeys = [];
    // keep track of which components have finished
    Phase5T2T3Components = [];
    Phase5T2T3Components.push(sound_ththab_shab2);
    Phase5T2T3Components.push(key_Ph5T2T3);
    Phase5T2T3Components.push(text_Ph5T2T3);
    Phase5T2T3Components.push(phases_Ph5T2T3);
    
    Phase5T2T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T3RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththab_shab2
    if (t >= 0.2 && sound_ththab_shab2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththab_shab2.tStart = t;  // (not accounting for frame time here)
      sound_ththab_shab2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththab_shab2.play(); });  // screen flip
      sound_ththab_shab2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththab_shab2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_ththab_shab2.stop();  // stop the sound (if longer than duration)
        sound_ththab_shab2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T3* updates
    if (t >= 4.2 && key_Ph5T2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T3.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T3.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T3.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T3.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T3.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T3.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T3.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T3.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T3_allKeys = _key_Ph5T2T3_allKeys.concat(theseKeys);
      if (_key_Ph5T2T3_allKeys.length > 0) {
        key_Ph5T2T3.keys = _key_Ph5T2T3_allKeys[_key_Ph5T2T3_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T3.rt = _key_Ph5T2T3_allKeys[_key_Ph5T2T3_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T3.keys == '0') {
            key_Ph5T2T3.corr = 1;
        } else {
            key_Ph5T2T3.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T3* updates
    if (t >= 0.0 && text_Ph5T2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T3.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T3.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T3.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T3* updates
    if (t >= 0.0 && phases_Ph5T2T3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T3.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T3.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T3.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T3.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T3RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T3'-------
    Phase5T2T3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththab_shab2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T3.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T2T3.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T3.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T3.keys', key_Ph5T2T3.keys);
    psychoJS.experiment.addData('key_Ph5T2T3.corr', key_Ph5T2T3.corr);
    if (typeof key_Ph5T2T3.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T3.rt', key_Ph5T2T3.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T3.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T4_allKeys;
var Phase5T2T4Components;
function Phase5T2T4RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T4'-------
    t = 0;
    Phase5T2T4Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_ththna_ththna2.secs=5;
    sound_ththna_ththna2.setVolume(1);
    key_Ph5T2T4.keys = undefined;
    key_Ph5T2T4.rt = undefined;
    _key_Ph5T2T4_allKeys = [];
    // keep track of which components have finished
    Phase5T2T4Components = [];
    Phase5T2T4Components.push(sound_ththna_ththna2);
    Phase5T2T4Components.push(key_Ph5T2T4);
    Phase5T2T4Components.push(text_Ph5T2T4);
    Phase5T2T4Components.push(phases_Ph5T2T4);
    
    Phase5T2T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T4RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_ththna_ththna2
    if (t >= 0.2 && sound_ththna_ththna2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_ththna_ththna2.tStart = t;  // (not accounting for frame time here)
      sound_ththna_ththna2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_ththna_ththna2.play(); });  // screen flip
      sound_ththna_ththna2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_ththna_ththna2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_ththna_ththna2.stop();  // stop the sound (if longer than duration)
        sound_ththna_ththna2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T4* updates
    if (t >= 4.2 && key_Ph5T2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T4.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T4.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T4.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T4.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T4_allKeys = _key_Ph5T2T4_allKeys.concat(theseKeys);
      if (_key_Ph5T2T4_allKeys.length > 0) {
        key_Ph5T2T4.keys = _key_Ph5T2T4_allKeys[_key_Ph5T2T4_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T4.rt = _key_Ph5T2T4_allKeys[_key_Ph5T2T4_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T4.keys == '1') {
            key_Ph5T2T4.corr = 1;
        } else {
            key_Ph5T2T4.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T4* updates
    if (t >= 0.0 && text_Ph5T2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T4.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T4.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T4.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T4* updates
    if (t >= 0.0 && phases_Ph5T2T4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T4.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T4.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T4.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T4RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T4'-------
    Phase5T2T4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_ththna_ththna2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T4.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T2T4.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T4.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T4.keys', key_Ph5T2T4.keys);
    psychoJS.experiment.addData('key_Ph5T2T4.corr', key_Ph5T2T4.corr);
    if (typeof key_Ph5T2T4.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T4.rt', key_Ph5T2T4.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T4.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T5_allKeys;
var Phase5T2T5Components;
function Phase5T2T5RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T5'-------
    t = 0;
    Phase5T2T5Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_thra_ththra2.secs=5;
    sound_thra_ththra2.setVolume(1);
    key_Ph5T2T5.keys = undefined;
    key_Ph5T2T5.rt = undefined;
    _key_Ph5T2T5_allKeys = [];
    // keep track of which components have finished
    Phase5T2T5Components = [];
    Phase5T2T5Components.push(sound_thra_ththra2);
    Phase5T2T5Components.push(key_Ph5T2T5);
    Phase5T2T5Components.push(text_Ph5T2T5);
    Phase5T2T5Components.push(phases_Ph5T2T5);
    
    Phase5T2T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T5RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T5'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thra_ththra2
    if (t >= 0.2 && sound_thra_ththra2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thra_ththra2.tStart = t;  // (not accounting for frame time here)
      sound_thra_ththra2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thra_ththra2.play(); });  // screen flip
      sound_thra_ththra2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thra_ththra2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thra_ththra2.stop();  // stop the sound (if longer than duration)
        sound_thra_ththra2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T5* updates
    if (t >= 4.2 && key_Ph5T2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T5.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T5.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T5.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T5.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T5_allKeys = _key_Ph5T2T5_allKeys.concat(theseKeys);
      if (_key_Ph5T2T5_allKeys.length > 0) {
        key_Ph5T2T5.keys = _key_Ph5T2T5_allKeys[_key_Ph5T2T5_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T5.rt = _key_Ph5T2T5_allKeys[_key_Ph5T2T5_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T5.keys == '0') {
            key_Ph5T2T5.corr = 1;
        } else {
            key_Ph5T2T5.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T5* updates
    if (t >= 0.0 && text_Ph5T2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T5.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T5.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T5.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T5* updates
    if (t >= 0.0 && phases_Ph5T2T5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T5.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T5.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T5RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T5'-------
    Phase5T2T5Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thra_ththra2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T5.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T2T5.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T5.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T5.keys', key_Ph5T2T5.keys);
    psychoJS.experiment.addData('key_Ph5T2T5.corr', key_Ph5T2T5.corr);
    if (typeof key_Ph5T2T5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T5.rt', key_Ph5T2T5.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T5.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T6_allKeys;
var Phase5T2T6Components;
function Phase5T2T6RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T6'-------
    t = 0;
    Phase5T2T6Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_thb7_shb72.secs=5;
    sound_thb7_shb72.setVolume(1);
    key_Ph5T2T6.keys = undefined;
    key_Ph5T2T6.rt = undefined;
    _key_Ph5T2T6_allKeys = [];
    // keep track of which components have finished
    Phase5T2T6Components = [];
    Phase5T2T6Components.push(sound_thb7_shb72);
    Phase5T2T6Components.push(key_Ph5T2T6);
    Phase5T2T6Components.push(text_Ph5T2T6);
    Phase5T2T6Components.push(phases_Ph5T2T6);
    
    Phase5T2T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T6RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T6'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thb7_shb72
    if (t >= 0.2 && sound_thb7_shb72.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thb7_shb72.tStart = t;  // (not accounting for frame time here)
      sound_thb7_shb72.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thb7_shb72.play(); });  // screen flip
      sound_thb7_shb72.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thb7_shb72.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thb7_shb72.stop();  // stop the sound (if longer than duration)
        sound_thb7_shb72.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T6* updates
    if (t >= 4.2 && key_Ph5T2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T6.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T6.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T6.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T6.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T6.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T6.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T6.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T6.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T6_allKeys = _key_Ph5T2T6_allKeys.concat(theseKeys);
      if (_key_Ph5T2T6_allKeys.length > 0) {
        key_Ph5T2T6.keys = _key_Ph5T2T6_allKeys[_key_Ph5T2T6_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T6.rt = _key_Ph5T2T6_allKeys[_key_Ph5T2T6_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T6.keys == '0') {
            key_Ph5T2T6.corr = 1;
        } else {
            key_Ph5T2T6.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T6* updates
    if (t >= 0.0 && text_Ph5T2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T6.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T6.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T6.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T6* updates
    if (t >= 0.0 && phases_Ph5T2T6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T6.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T6.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T6.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T6RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T6'-------
    Phase5T2T6Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thb7_shb72.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T6.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T2T6.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T6.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T6.keys', key_Ph5T2T6.keys);
    psychoJS.experiment.addData('key_Ph5T2T6.corr', key_Ph5T2T6.corr);
    if (typeof key_Ph5T2T6.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T6.rt', key_Ph5T2T6.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T6.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T7_allKeys;
var Phase5T2T7Components;
function Phase5T2T7RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T7'-------
    t = 0;
    Phase5T2T7Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_thwq_thwq2.secs=5;
    sound_thwq_thwq2.setVolume(1);
    key_Ph5T2T7.keys = undefined;
    key_Ph5T2T7.rt = undefined;
    _key_Ph5T2T7_allKeys = [];
    // keep track of which components have finished
    Phase5T2T7Components = [];
    Phase5T2T7Components.push(sound_thwq_thwq2);
    Phase5T2T7Components.push(key_Ph5T2T7);
    Phase5T2T7Components.push(text_Ph5T2T7);
    Phase5T2T7Components.push(phases_Ph5T2T7);
    
    Phase5T2T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T7RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T7'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thwq_thwq2
    if (t >= 0.2 && sound_thwq_thwq2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thwq_thwq2.tStart = t;  // (not accounting for frame time here)
      sound_thwq_thwq2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thwq_thwq2.play(); });  // screen flip
      sound_thwq_thwq2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thwq_thwq2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thwq_thwq2.stop();  // stop the sound (if longer than duration)
        sound_thwq_thwq2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T7* updates
    if (t >= 4.2 && key_Ph5T2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T7.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T7.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T7.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T7.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T7.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T7.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T7.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T7.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T7_allKeys = _key_Ph5T2T7_allKeys.concat(theseKeys);
      if (_key_Ph5T2T7_allKeys.length > 0) {
        key_Ph5T2T7.keys = _key_Ph5T2T7_allKeys[_key_Ph5T2T7_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T7.rt = _key_Ph5T2T7_allKeys[_key_Ph5T2T7_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T7.keys == '1') {
            key_Ph5T2T7.corr = 1;
        } else {
            key_Ph5T2T7.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T7* updates
    if (t >= 0.0 && text_Ph5T2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T7.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T7.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T7.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T7* updates
    if (t >= 0.0 && phases_Ph5T2T7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T7.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T7.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T7.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T7.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T7RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T7'-------
    Phase5T2T7Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thwq_thwq2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T7.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T2T7.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T7.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T7.keys', key_Ph5T2T7.keys);
    psychoJS.experiment.addData('key_Ph5T2T7.corr', key_Ph5T2T7.corr);
    if (typeof key_Ph5T2T7.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T7.rt', key_Ph5T2T7.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T7.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T8_allKeys;
var Phase5T2T8Components;
function Phase5T2T8RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T8'-------
    t = 0;
    Phase5T2T8Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_thail_thail2.secs=5;
    sound_thail_thail2.setVolume(1);
    key_Ph5T2T8.keys = undefined;
    key_Ph5T2T8.rt = undefined;
    _key_Ph5T2T8_allKeys = [];
    // keep track of which components have finished
    Phase5T2T8Components = [];
    Phase5T2T8Components.push(sound_thail_thail2);
    Phase5T2T8Components.push(key_Ph5T2T8);
    Phase5T2T8Components.push(text_Ph5T2T8);
    Phase5T2T8Components.push(phases_Ph5T2T8);
    
    Phase5T2T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T8RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T8'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T8Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_thail_thail2
    if (t >= 0.2 && sound_thail_thail2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_thail_thail2.tStart = t;  // (not accounting for frame time here)
      sound_thail_thail2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_thail_thail2.play(); });  // screen flip
      sound_thail_thail2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_thail_thail2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_thail_thail2.stop();  // stop the sound (if longer than duration)
        sound_thail_thail2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T8* updates
    if (t >= 4.2 && key_Ph5T2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T8.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T8.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T8.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T8.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T8.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T8.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T8.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T8.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T8_allKeys = _key_Ph5T2T8_allKeys.concat(theseKeys);
      if (_key_Ph5T2T8_allKeys.length > 0) {
        key_Ph5T2T8.keys = _key_Ph5T2T8_allKeys[_key_Ph5T2T8_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T8.rt = _key_Ph5T2T8_allKeys[_key_Ph5T2T8_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T8.keys == '1') {
            key_Ph5T2T8.corr = 1;
        } else {
            key_Ph5T2T8.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T8* updates
    if (t >= 0.0 && text_Ph5T2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T8.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T8.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T8.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T8* updates
    if (t >= 0.0 && phases_Ph5T2T8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T8.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T8.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T8.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T8Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T8RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T8'-------
    Phase5T2T8Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_thail_thail2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T8.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T2T8.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T8.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T8.keys', key_Ph5T2T8.keys);
    psychoJS.experiment.addData('key_Ph5T2T8.corr', key_Ph5T2T8.corr);
    if (typeof key_Ph5T2T8.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T8.rt', key_Ph5T2T8.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T8.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T9_allKeys;
var Phase5T2T9Components;
function Phase5T2T9RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T9'-------
    t = 0;
    Phase5T2T9Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_shrf_thrf2.secs=5;
    sound_shrf_thrf2.setVolume(1);
    key_Ph5T2T9.keys = undefined;
    key_Ph5T2T9.rt = undefined;
    _key_Ph5T2T9_allKeys = [];
    // keep track of which components have finished
    Phase5T2T9Components = [];
    Phase5T2T9Components.push(sound_shrf_thrf2);
    Phase5T2T9Components.push(key_Ph5T2T9);
    Phase5T2T9Components.push(text_Ph5T2T9);
    Phase5T2T9Components.push(phases_Ph5T2T9);
    
    Phase5T2T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T9RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T9'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T9Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_shrf_thrf2
    if (t >= 0.2 && sound_shrf_thrf2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_shrf_thrf2.tStart = t;  // (not accounting for frame time here)
      sound_shrf_thrf2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_shrf_thrf2.play(); });  // screen flip
      sound_shrf_thrf2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_shrf_thrf2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_shrf_thrf2.stop();  // stop the sound (if longer than duration)
        sound_shrf_thrf2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T9* updates
    if (t >= 4.2 && key_Ph5T2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T9.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T9.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T9.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T9.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T9_allKeys = _key_Ph5T2T9_allKeys.concat(theseKeys);
      if (_key_Ph5T2T9_allKeys.length > 0) {
        key_Ph5T2T9.keys = _key_Ph5T2T9_allKeys[_key_Ph5T2T9_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T9.rt = _key_Ph5T2T9_allKeys[_key_Ph5T2T9_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T9.keys == '0') {
            key_Ph5T2T9.corr = 1;
        } else {
            key_Ph5T2T9.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T9* updates
    if (t >= 0.0 && text_Ph5T2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T9.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T9.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T9.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T9* updates
    if (t >= 0.0 && phases_Ph5T2T9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T9.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T9.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T9.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T9Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T9RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T9'-------
    Phase5T2T9Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_shrf_thrf2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T9.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T2T9.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T9.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T9.keys', key_Ph5T2T9.keys);
    psychoJS.experiment.addData('key_Ph5T2T9.corr', key_Ph5T2T9.corr);
    if (typeof key_Ph5T2T9.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T9.rt', key_Ph5T2T9.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T9.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T10_allKeys;
var Phase5T2T10Components;
function Phase5T2T10RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T10'-------
    t = 0;
    Phase5T2T10Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_sh7m_sh7m2.secs=5;
    sound_sh7m_sh7m2.setVolume(1);
    key_Ph5T2T10.keys = undefined;
    key_Ph5T2T10.rt = undefined;
    _key_Ph5T2T10_allKeys = [];
    // keep track of which components have finished
    Phase5T2T10Components = [];
    Phase5T2T10Components.push(sound_sh7m_sh7m2);
    Phase5T2T10Components.push(key_Ph5T2T10);
    Phase5T2T10Components.push(text_Ph5T2T10);
    Phase5T2T10Components.push(phases_Ph5T2T10);
    
    Phase5T2T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T10RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T10'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T10Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_sh7m_sh7m2
    if (t >= 0.2 && sound_sh7m_sh7m2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_sh7m_sh7m2.tStart = t;  // (not accounting for frame time here)
      sound_sh7m_sh7m2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_sh7m_sh7m2.play(); });  // screen flip
      sound_sh7m_sh7m2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_sh7m_sh7m2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_sh7m_sh7m2.stop();  // stop the sound (if longer than duration)
        sound_sh7m_sh7m2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T10* updates
    if (t >= 4.2 && key_Ph5T2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T10.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T10.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T10.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T10.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T10_allKeys = _key_Ph5T2T10_allKeys.concat(theseKeys);
      if (_key_Ph5T2T10_allKeys.length > 0) {
        key_Ph5T2T10.keys = _key_Ph5T2T10_allKeys[_key_Ph5T2T10_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T10.rt = _key_Ph5T2T10_allKeys[_key_Ph5T2T10_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T10.keys == '1') {
            key_Ph5T2T10.corr = 1;
        } else {
            key_Ph5T2T10.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T10* updates
    if (t >= 0.0 && text_Ph5T2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T10.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T10.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T10.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T10* updates
    if (t >= 0.0 && phases_Ph5T2T10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T10.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T10.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T10.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T10.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T10Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T10RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T10'-------
    Phase5T2T10Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_sh7m_sh7m2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T10.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T2T10.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T10.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T10.keys', key_Ph5T2T10.keys);
    psychoJS.experiment.addData('key_Ph5T2T10.corr', key_Ph5T2T10.corr);
    if (typeof key_Ph5T2T10.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T10.rt', key_Ph5T2T10.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T10.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T11_allKeys;
var Phase5T2T11Components;
function Phase5T2T11RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T11'-------
    t = 0;
    Phase5T2T11Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_shra_ththra2.secs=5;
    sound_shra_ththra2.setVolume(1);
    key_Ph5T2T11.keys = undefined;
    key_Ph5T2T11.rt = undefined;
    _key_Ph5T2T11_allKeys = [];
    // keep track of which components have finished
    Phase5T2T11Components = [];
    Phase5T2T11Components.push(sound_shra_ththra2);
    Phase5T2T11Components.push(key_Ph5T2T11);
    Phase5T2T11Components.push(text_Ph5T2T11);
    Phase5T2T11Components.push(phases_Ph5T2T11);
    
    Phase5T2T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T11RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T11'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T11Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_shra_ththra2
    if (t >= 0.2 && sound_shra_ththra2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_shra_ththra2.tStart = t;  // (not accounting for frame time here)
      sound_shra_ththra2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_shra_ththra2.play(); });  // screen flip
      sound_shra_ththra2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_shra_ththra2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_shra_ththra2.stop();  // stop the sound (if longer than duration)
        sound_shra_ththra2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T11* updates
    if (t >= 4.2 && key_Ph5T2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T11.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T11.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T11.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T11.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T11_allKeys = _key_Ph5T2T11_allKeys.concat(theseKeys);
      if (_key_Ph5T2T11_allKeys.length > 0) {
        key_Ph5T2T11.keys = _key_Ph5T2T11_allKeys[_key_Ph5T2T11_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T11.rt = _key_Ph5T2T11_allKeys[_key_Ph5T2T11_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T11.keys == '0') {
            key_Ph5T2T11.corr = 1;
        } else {
            key_Ph5T2T11.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T11* updates
    if (t >= 0.0 && text_Ph5T2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T11.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T11.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T11.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T11* updates
    if (t >= 0.0 && phases_Ph5T2T11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T11.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T11.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T11.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T11RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T11'-------
    Phase5T2T11Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_shra_ththra2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T11.keys === undefined) {
      if (['None','none',undefined].includes('0')) {
         key_Ph5T2T11.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T11.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T11.keys', key_Ph5T2T11.keys);
    psychoJS.experiment.addData('key_Ph5T2T11.corr', key_Ph5T2T11.corr);
    if (typeof key_Ph5T2T11.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T11.rt', key_Ph5T2T11.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T11.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_Ph5T2T12_allKeys;
var Phase5T2T12Components;
function Phase5T2T12RoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'Phase5T2T12'-------
    t = 0;
    Phase5T2T12Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.200000);
    // update component parameters for each repeat
    sound_shfa_shfa2.secs=5;
    sound_shfa_shfa2.setVolume(1);
    key_Ph5T2T12.keys = undefined;
    key_Ph5T2T12.rt = undefined;
    _key_Ph5T2T12_allKeys = [];
    // keep track of which components have finished
    Phase5T2T12Components = [];
    Phase5T2T12Components.push(sound_shfa_shfa2);
    Phase5T2T12Components.push(key_Ph5T2T12);
    Phase5T2T12Components.push(text_Ph5T2T12);
    Phase5T2T12Components.push(phases_Ph5T2T12);
    
    Phase5T2T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function Phase5T2T12RoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'Phase5T2T12'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Phase5T2T12Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_shfa_shfa2
    if (t >= 0.2 && sound_shfa_shfa2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_shfa_shfa2.tStart = t;  // (not accounting for frame time here)
      sound_shfa_shfa2.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_shfa_shfa2.play(); });  // screen flip
      sound_shfa_shfa2.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 0.2 + 5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_shfa_shfa2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (5 > 0.5) {  sound_shfa_shfa2.stop();  // stop the sound (if longer than duration)
        sound_shfa_shfa2.status = PsychoJS.Status.FINISHED;
      }
    }
    
    // *key_Ph5T2T12* updates
    if (t >= 4.2 && key_Ph5T2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_Ph5T2T12.tStart = t;  // (not accounting for frame time here)
      key_Ph5T2T12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_Ph5T2T12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_Ph5T2T12.clearEvents(); });
    }

    frameRemains = 4.2 + 6 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_Ph5T2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_Ph5T2T12.status = PsychoJS.Status.FINISHED;
  }

    if (key_Ph5T2T12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_Ph5T2T12.getKeys({keyList: ['1', '0'], waitRelease: false});
      _key_Ph5T2T12_allKeys = _key_Ph5T2T12_allKeys.concat(theseKeys);
      if (_key_Ph5T2T12_allKeys.length > 0) {
        key_Ph5T2T12.keys = _key_Ph5T2T12_allKeys[_key_Ph5T2T12_allKeys.length - 1].name;  // just the last key pressed
        key_Ph5T2T12.rt = _key_Ph5T2T12_allKeys[_key_Ph5T2T12_allKeys.length - 1].rt;
        // was this correct?
        if (key_Ph5T2T12.keys == '1') {
            key_Ph5T2T12.corr = 1;
        } else {
            key_Ph5T2T12.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_Ph5T2T12* updates
    if (t >= 0.0 && text_Ph5T2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_Ph5T2T12.tStart = t;  // (not accounting for frame time here)
      text_Ph5T2T12.frameNStart = frameN;  // exact frame index
      
      text_Ph5T2T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_Ph5T2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_Ph5T2T12.setAutoDraw(false);
    }
    
    // *phases_Ph5T2T12* updates
    if (t >= 0.0 && phases_Ph5T2T12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_Ph5T2T12.tStart = t;  // (not accounting for frame time here)
      phases_Ph5T2T12.frameNStart = frameN;  // exact frame index
      
      phases_Ph5T2T12.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10.2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (phases_Ph5T2T12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      phases_Ph5T2T12.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Phase5T2T12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Phase5T2T12RoutineEnd(trials) {
  return function () {
    //------Ending Routine 'Phase5T2T12'-------
    Phase5T2T12Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_shfa_shfa2.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_Ph5T2T12.keys === undefined) {
      if (['None','none',undefined].includes('1')) {
         key_Ph5T2T12.corr = 1;  // correct non-response
      } else {
         key_Ph5T2T12.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_Ph5T2T12.keys', key_Ph5T2T12.keys);
    psychoJS.experiment.addData('key_Ph5T2T12.corr', key_Ph5T2T12.corr);
    if (typeof key_Ph5T2T12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_Ph5T2T12.rt', key_Ph5T2T12.rt);
        routineTimer.reset();
        }
    
    key_Ph5T2T12.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_EndExperiment_allKeys;
var EndExperimentComponents;
function EndExperimentRoutineBegin(trials) {
  return function () {
    //------Prepare to start Routine 'EndExperiment'-------
    t = 0;
    EndExperimentClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_EndExperiment.keys = undefined;
    key_EndExperiment.rt = undefined;
    _key_EndExperiment_allKeys = [];
    // keep track of which components have finished
    EndExperimentComponents = [];
    EndExperimentComponents.push(text_EndExperiment);
    EndExperimentComponents.push(key_EndExperiment);
    EndExperimentComponents.push(phases_end);
    
    EndExperimentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    
    return Scheduler.Event.NEXT;
  };
}


function EndExperimentRoutineEachFrame(trials) {
  return function () {
    //------Loop for each frame of Routine 'EndExperiment'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = EndExperimentClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_EndExperiment* updates
    if (t >= 0.0 && text_EndExperiment.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_EndExperiment.tStart = t;  // (not accounting for frame time here)
      text_EndExperiment.frameNStart = frameN;  // exact frame index
      
      text_EndExperiment.setAutoDraw(true);
    }

    
    // *key_EndExperiment* updates
    if (t >= 0.0 && key_EndExperiment.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_EndExperiment.tStart = t;  // (not accounting for frame time here)
      key_EndExperiment.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_EndExperiment.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_EndExperiment.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_EndExperiment.clearEvents(); });
    }

    if (key_EndExperiment.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_EndExperiment.getKeys({keyList: ['space'], waitRelease: false});
      _key_EndExperiment_allKeys = _key_EndExperiment_allKeys.concat(theseKeys);
      if (_key_EndExperiment_allKeys.length > 0) {
        key_EndExperiment.keys = _key_EndExperiment_allKeys[_key_EndExperiment_allKeys.length - 1].name;  // just the last key pressed
        key_EndExperiment.rt = _key_EndExperiment_allKeys[_key_EndExperiment_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *phases_end* updates
    if (t >= 0.0 && phases_end.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      phases_end.tStart = t;  // (not accounting for frame time here)
      phases_end.frameNStart = frameN;  // exact frame index
      
      phases_end.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    EndExperimentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function EndExperimentRoutineEnd(trials) {
  return function () {
    //------Ending Routine 'EndExperiment'-------
    EndExperimentComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_EndExperiment.keys', key_EndExperiment.keys);
    if (typeof key_EndExperiment.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_EndExperiment.rt', key_EndExperiment.rt);
        routineTimer.reset();
        }
    
    key_EndExperiment.stop();
    // the Routine "EndExperiment" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


function endLoopIteration(thisScheduler, loop) {
  // ------Prepare for next entry------
  return function () {
    if (typeof loop !== 'undefined') {
      // ------Check if user ended loop early------
      if (loop.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(loop);
        }
      thisScheduler.stop();
      } else {
        const thisTrial = loop.getCurrentTrial();
        if (typeof thisTrial === 'undefined' || !('isTrials' in thisTrial) || thisTrial.isTrials) {
          psychoJS.experiment.nextEntry(loop);
        }
      }
    return Scheduler.Event.NEXT;
    }
  };
}


function importConditions(trials) {
  return function () {
    psychoJS.importAttributes(trials.getCurrentTrial());
    return Scheduler.Event.NEXT;
    };
}


function quitPsychoJS(message, isCompleted) {
  // Check for and save orphaned data
  if (psychoJS.experiment.isEntryEmpty()) {
    psychoJS.experiment.nextEntry();
  }
  psychoJS.window.close();
  psychoJS.quit({message: message, isCompleted: isCompleted});
  
  return Scheduler.Event.QUIT;
}
