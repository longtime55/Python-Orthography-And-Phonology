#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v2020.1.2),
    on Tue Aug  4 23:07:31 2020
If you publish work using this script the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""

from __future__ import absolute_import, division

from psychopy import locale_setup
from psychopy import prefs
from psychopy import sound, gui, visual, core, data, event, logging, clock
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle
import os  # handy system and path functions
import sys  # to get file system encoding

from psychopy.hardware import keyboard



# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
os.chdir(_thisDir)

# Store info about the experiment session
psychopyVersion = '2020.1.2'
expName = 'identical session Arabic'  # from the Builder filename that created this script
expInfo = {'participant': '', 'session': '', 'group': ''}
dlg = gui.DlgFromDict(dictionary=expInfo, sortKeys=False, title=expName)
if dlg.OK == False:
    core.quit()  # user pressed cancel
expInfo['date'] = data.getDateStr()  # add a simple timestamp
expInfo['expName'] = expName
expInfo['psychopyVersion'] = psychopyVersion

# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
filename = _thisDir + os.sep + u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])

# An ExperimentHandler isn't essential but helps with data saving
thisExp = data.ExperimentHandler(name=expName, version='',
    extraInfo=expInfo, runtimeInfo=None,
    originPath='/Users/hayfaalhomaid/Dropbox/Higher Education/PhD/Second year/Instrument/Experiment/Arabic script gp/identical session Ar./identical session Arabic_lastrun.py',
    savePickle=True, saveWideText=True,
    dataFileName=filename)
# save a log file for detail verbose info
logFile = logging.LogFile(filename+'.log', level=logging.EXP)
logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file

endExpNow = False  # flag for 'escape' or other condition => quit the exp
frameTolerance = 0.001  # how close to onset before 'same' frame

# Start Code - component code to be run before the window creation

# Setup the Window
win = visual.Window(
    size=[1440, 900], fullscr=False, screen=0, 
    winType='pyglet', allowGUI=True, allowStencil=False,
    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',
    blendMode='avg', useFBO=True, 
    units='height')
# store frame rate of monitor if we can measure it
expInfo['frameRate'] = win.getActualFrameRate()
if expInfo['frameRate'] != None:
    frameDur = 1.0 / round(expInfo['frameRate'])
else:
    frameDur = 1.0 / 60.0  # could not measure, so guess

# create a default keyboard (e.g. to check for escape)
defaultKeyboard = keyboard.Keyboard()

# Initialize components for Routine "WelcomeScreen"
WelcomeScreenClock = core.Clock()
textWelcome = visual.TextStim(win=win, name='textWelcome',
    text='Welcome to our experiment\n\nPlease go through the instructions within each phase\n\nPress "Space" to continue',
    font='Times New Romans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_welcome = keyboard.Keyboard()

# Initialize components for Routine "GeneralInstruction"
GeneralInstructionClock = core.Clock()
text_gen_inst = visual.TextStim(win=win, name='text_gen_inst',
    text='In this experiment you will have three sessions\n\nThis session includes five phases\n\nPress "Space" to continue',
    font='Times New Romans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_Gen_inst = keyboard.Keyboard()

# Initialize components for Routine "Phase1instructions"
Phase1instructionsClock = core.Clock()
Phase1_inst = visual.TextStim(win=win, name='Phase1_inst',
    text='Phase 1: Sound Recognition phase (pre)\nYou will have 2 tasks\n\nIn task 1: You will hear 2 sounds. Your task is to decide whether these sounds are same or different\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task',
    font='Times New Romans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_Phase1_inst = keyboard.Keyboard()

# Initialize components for Routine "SoundRecognitionT1T1"
SoundRecognitionT1T1Clock = core.Clock()
sound_thth = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth')
sound_thth.setVolume(1)
sound_th = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th')
sound_th.setVolume(1)
key_SRT1T1 = keyboard.Keyboard()
text_SRT1T1 = visual.TextStim(win=win, name='text_SRT1T1',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T1 = visual.TextStim(win=win, name='phases_SRT1T1',
    text='Phase 1:   0%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0,-0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T2"
SoundRecognitionT1T2Clock = core.Clock()
sound_thth2 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth2')
sound_thth2.setVolume(1)
sound_thth3 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=False,
    name='sound_thth3')
sound_thth3.setVolume(1)
key_SRT1T2 = keyboard.Keyboard()
text_SRT1T2 = visual.TextStim(win=win, name='text_SRT1T2',
    text='Do they sound the same? \n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T2 = visual.TextStim(win=win, name='phases_SRT1T2',
    text='Phase 1:   4%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T3"
SoundRecognitionT1T3Clock = core.Clock()
sound_thth4 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth4')
sound_thth4.setVolume(1)
sound_sh = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh')
sound_sh.setVolume(1)
key_SRT1T3 = keyboard.Keyboard()
text_SRT1T3 = visual.TextStim(win=win, name='text_SRT1T3',
    text='Do they sound the same? \n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T3 = visual.TextStim(win=win, name='phases_SRT1T3',
    text='Phase 1:   8%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T4"
SoundRecognitionT1T4Clock = core.Clock()
sound_thth5 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth5')
sound_thth5.setVolume(1)
sound_thth6 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth6')
sound_thth6.setVolume(1)
key_SRT1T4 = keyboard.Keyboard()
text_SRT1T4 = visual.TextStim(win=win, name='text_SRT1T4',
    text='Do they sound the same? \n\n1= Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T4 = visual.TextStim(win=win, name='phases_SRT1T4',
    text='Phase 1:  12%   Phase 2:   0%   Phase 3:   0%   Phase 4:  0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T5"
SoundRecognitionT1T5Clock = core.Clock()
sound_th2 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th2')
sound_th2.setVolume(1)
sound_thth7 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth7')
sound_thth7.setVolume(1)
key_SRT1T5 = keyboard.Keyboard()
text_SRT1T5 = visual.TextStim(win=win, name='text_SRT1T5',
    text='Do they sound the same? \n\n1= Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T5 = visual.TextStim(win=win, name='phases_SRT1T5',
    text='Phase 1:  16%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T6"
SoundRecognitionT1T6Clock = core.Clock()
sound_th4 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th4')
sound_th4.setVolume(1)
sound_th3 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th3')
sound_th3.setVolume(1)
key_SRT1T6 = keyboard.Keyboard()
text_SRT1T6 = visual.TextStim(win=win, name='text_SRT1T6',
    text='Do they sound the same? \n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T6 = visual.TextStim(win=win, name='phases_SRT1T6',
    text='Phase 1:  20%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T7"
SoundRecognitionT1T7Clock = core.Clock()
sound_th5 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th5')
sound_th5.setVolume(1)
sound_sh8 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh8')
sound_sh8.setVolume(1)
key_SRT1T7 = keyboard.Keyboard()
text_SRT1T7 = visual.TextStim(win=win, name='text_SRT1T7',
    text='Do they sound the same? \n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T7 = visual.TextStim(win=win, name='phases_SRT1T7',
    text='Phase 1:  25%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T8"
SoundRecognitionT1T8Clock = core.Clock()
sound_th7 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th7')
sound_th7.setVolume(1)
sound_th8 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th8')
sound_th8.setVolume(1)
key_SRT1T8 = keyboard.Keyboard()
text_SRT1T8 = visual.TextStim(win=win, name='text_SRT1T8',
    text='Do they sound the same? \n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T8 = visual.TextStim(win=win, name='phases_SRT1T8',
    text='Phase 1:  29%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T9"
SoundRecognitionT1T9Clock = core.Clock()
sound_sh2 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh2')
sound_sh2.setVolume(1)
sound_thth8 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth8')
sound_thth8.setVolume(1)
key_SRT1T9 = keyboard.Keyboard()
text_SRT1T9 = visual.TextStim(win=win, name='text_SRT1T9',
    text='Do they sound the same? \n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T9 = visual.TextStim(win=win, name='phases_SRT1T9',
    text='Phase 1:  33%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T10"
SoundRecognitionT1T10Clock = core.Clock()
sound_sh3 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh3')
sound_sh3.setVolume(1)
sound_th9 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th9')
sound_th9.setVolume(1)
key_SRT1T10 = keyboard.Keyboard()
text_SRT1T10 = visual.TextStim(win=win, name='text_SRT1T10',
    text='Do they sound the same? \n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T10 = visual.TextStim(win=win, name='phases_SRT1T10',
    text='Phase 1:  37%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T11"
SoundRecognitionT1T11Clock = core.Clock()
sound_sh4 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh4')
sound_sh4.setVolume(1)
sound_sh5 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh5')
sound_sh5.setVolume(1)
key_SRT1T11 = keyboard.Keyboard()
text_SRT1T11 = visual.TextStim(win=win, name='text_SRT1T11',
    text='Do they sound the same? \n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T11 = visual.TextStim(win=win, name='phases_SRT1T11',
    text='Phase 1:  41%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT1T12"
SoundRecognitionT1T12Clock = core.Clock()
sound_sh6 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh6')
sound_sh6.setVolume(1)
sound_sh7 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh7')
sound_sh7.setVolume(1)
key_SRT1T12 = keyboard.Keyboard()
text_SRT1T12 = visual.TextStim(win=win, name='text_SRT1T12',
    text='Do they sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_SRT1T12 = visual.TextStim(win=win, name='phases_SRT1T12',
    text='Phase 1:  45%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase1instructions2"
Phase1instructions2Clock = core.Clock()
text_phase1_inst2 = visual.TextStim(win=win, name='text_phase1_inst2',
    text='\nIn task 2: You will hear 2 Arabic words that may sound the same or may differ only in the initial sound (minimal pairs). Your task is to decide whether the two words are the same or differ only in the initial sounds. \n\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task',
    font='Times New Romans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_phase1_inst2 = keyboard.Keyboard()

# Initialize components for Routine "SoundRecognitionT2T1"
SoundRecognitionT2T1Clock = core.Clock()
sound_thrwa_thrwa = sound.Sound('Sounds/thrwa-thrwa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thrwa_thrwa')
sound_thrwa_thrwa.setVolume(1)
key_SRT2T1 = keyboard.Keyboard()
text_SRT2T1 = visual.TextStim(win=win, name='text_SRT2T1',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T1 = visual.TextStim(win=win, name='phases_SRT2T1',
    text='Phase 1:  50%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T2"
SoundRecognitionT2T2Clock = core.Clock()
sound_ththm_thm = sound.Sound('Sounds/ththm-thm.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththm_thm')
sound_ththm_thm.setVolume(1)
key_SRT2T2 = keyboard.Keyboard()
text_SRT2T2 = visual.TextStim(win=win, name='text_SRT2T2',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T2 = visual.TextStim(win=win, name='phases_SRT2T2',
    text='Phase 1:  54%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T3"
SoundRecognitionT2T3Clock = core.Clock()
sound_ththab_shab = sound.Sound('Sounds/ththab-shab.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththab_shab')
sound_ththab_shab.setVolume(1)
key_SRT2T3 = keyboard.Keyboard()
text_SRT2T3 = visual.TextStim(win=win, name='text_SRT2T3',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T3 = visual.TextStim(win=win, name='phases_SRT2T3',
    text='Phase 1:  58%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T4"
SoundRecognitionT2T4Clock = core.Clock()
sound_ththna_ththna = sound.Sound('Sounds/ththna-ththna.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththna_ththna')
sound_ththna_ththna.setVolume(1)
key_SRT2T4 = keyboard.Keyboard()
text_SRT2T4 = visual.TextStim(win=win, name='text_SRT2T4',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T4 = visual.TextStim(win=win, name='phases_SRT2T4',
    text='Phase 1:  62%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T5"
SoundRecognitionT2T5Clock = core.Clock()
sound_thra_ththra = sound.Sound('Sounds/thra-ththra.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thra_ththra')
sound_thra_ththra.setVolume(1)
key_SRT2T5 = keyboard.Keyboard()
text_SRT2T5 = visual.TextStim(win=win, name='text_SRT2T5',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T5 = visual.TextStim(win=win, name='phases_SRT2T5',
    text='Phase 1:  66%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T6"
SoundRecognitionT2T6Clock = core.Clock()
sound_thb7_shb7 = sound.Sound('Sounds/thb7-shb7.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thb7_shb7')
sound_thb7_shb7.setVolume(1)
key_SRT2T6 = keyboard.Keyboard()
text_SRT2T6 = visual.TextStim(win=win, name='text_SRT2T6',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T6 = visual.TextStim(win=win, name='phases_SRT2T6',
    text='Phase 1:  70%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T7"
SoundRecognitionT2T7Clock = core.Clock()
sound_thwq_thwq = sound.Sound('Sounds/thwq-thwq.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thwq_thwq')
sound_thwq_thwq.setVolume(1)
key_SRT2T7 = keyboard.Keyboard()
text_SRT2T7 = visual.TextStim(win=win, name='text_SRT2T7',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T7 = visual.TextStim(win=win, name='phases_SRT2T7',
    text='Phase 1:  75%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T8"
SoundRecognitionT2T8Clock = core.Clock()
sound_thail_thail = sound.Sound('Sounds/thail-thail.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thail_thail')
sound_thail_thail.setVolume(1)
key_SRT2T8 = keyboard.Keyboard()
text_SRT2T8 = visual.TextStim(win=win, name='text_SRT2T8',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T8 = visual.TextStim(win=win, name='phases_SRT2T8',
    text='Phase 1:  79%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T9"
SoundRecognitionT2T9Clock = core.Clock()
sound_shrf_thrf = sound.Sound('Sounds/shrf-thrf.wav', secs=-1, stereo=True, hamming=True,
    name='sound_shrf_thrf')
sound_shrf_thrf.setVolume(1)
key_SRT2T9 = keyboard.Keyboard()
text_SRT2T9 = visual.TextStim(win=win, name='text_SRT2T9',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T9 = visual.TextStim(win=win, name='phases_SRT2T9',
    text='Phase 1:  83%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T10"
SoundRecognitionT2T10Clock = core.Clock()
sound_sh7m_sh7m = sound.Sound('Sounds/sh7m-sh7m.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh7m_sh7m')
sound_sh7m_sh7m.setVolume(1)
key_SRT2T10 = keyboard.Keyboard()
text_SRT2T10 = visual.TextStim(win=win, name='text_SRT2T10',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T10 = visual.TextStim(win=win, name='phases_SRT2T10',
    text='Phase 1:  87%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T11"
SoundRecognitionT2T11Clock = core.Clock()
sound_shra_ththra = sound.Sound('Sounds/shra-ththra.wav', secs=-1, stereo=True, hamming=True,
    name='sound_shra_ththra')
sound_shra_ththra.setVolume(1)
key_SRT2T11 = keyboard.Keyboard()
text_SRT2T11 = visual.TextStim(win=win, name='text_SRT2T11',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T11 = visual.TextStim(win=win, name='phases_SRT2T11',
    text='Phase 1:  91%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "SoundRecognitionT2T12"
SoundRecognitionT2T12Clock = core.Clock()
sound_shfa_shfa = sound.Sound('Sounds/shfa-shfa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_shfa_shfa')
sound_shfa_shfa.setVolume(1)
key_SRT2T12 = keyboard.Keyboard()
text_SRT2T12 = visual.TextStim(win=win, name='text_SRT2T12',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_SRT2T12 = visual.TextStim(win=win, name='phases_SRT2T12',
    text='Phase 1:  95%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "EndSoundRecognition"
EndSoundRecognitionClock = core.Clock()
text_EndSR = visual.TextStim(win=win, name='text_EndSR',
    text="This is the end of the first phase. \n\nPlease press 'Space' to move to the second phase whenever you are ready",
    font='Arial',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_EndSR = keyboard.Keyboard()
phases_endSR = visual.TextStim(win=win, name='phases_endSR',
    text='Phase 1: 100%   Phase 2:   0%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);

# Initialize components for Routine "Phase2instructions"
Phase2instructionsClock = core.Clock()
text = visual.TextStim(win=win, name='text',
    text='Phase 2: Word learning phase\n\nYou will learn new Arabic non-words. You will hear how they are pronounced and see the corresponding pictures with their Arabic written forms. \n\nArabic language is written from the right to the left\n\nThese non-words will be repeated many times. \n\nYou are not required to do anything in this phase, just learn\n\nPress "Space" to continue.\n',
    font='Times New Roman',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_WLinst = keyboard.Keyboard()

# Initialize components for Routine "WordLearningT1"
WordLearningT1Clock = core.Clock()
sound_ththami = sound.Sound('Sounds/ththami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththami')
sound_ththami.setVolume(1)
image_ththami = visual.ImageStim(
    win=win,
    name='image_ththami', 
    image='Images/ththami.jpg', mask=None,
    ori=0, pos=(-0.5, 0), size=(0.5, 0.5),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
sound_thami = sound.Sound('Sounds/thami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thami')
sound_thami.setVolume(1)
image_thami = visual.ImageStim(
    win=win,
    name='image_thami', 
    image='Images/thami.jpg', mask=None,
    ori=0, pos=(0.5, 0), size=(0.5, 0.5),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-3.0)

# Initialize components for Routine "WordLearningT2"
WordLearningT2Clock = core.Clock()
sound_ththuri = sound.Sound('Sounds/ththuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththuri')
sound_ththuri.setVolume(1)
image_ththuri = visual.ImageStim(
    win=win,
    name='image_ththuri', 
    image='Images/ththuri.jpg', mask=None,
    ori=0, pos=(-0.5, 0), size=(0.5, 0.5),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
sound_thuri = sound.Sound('Sounds/thuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thuri')
sound_thuri.setVolume(1)
image_thuri = visual.ImageStim(
    win=win,
    name='image_thuri', 
    image='Images/thuri.jpg', mask=None,
    ori=0, pos=(0.5, 0), size=(0.5, 0.5),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-3.0)

# Initialize components for Routine "WordLearningT3"
WordLearningT3Clock = core.Clock()
sound_ththano = sound.Sound('Sounds/ththano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththano')
sound_ththano.setVolume(1)
image_ththano = visual.ImageStim(
    win=win,
    name='image_ththano', 
    image='Images/ththano.jpg', mask=None,
    ori=0, pos=(-0.5, 0), size=(0.5, 0.5),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
sound_thano = sound.Sound('Sounds/thano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thano')
sound_thano.setVolume(1)
image_thano = visual.ImageStim(
    win=win,
    name='image_thano', 
    image='Images/thano.jpg', mask=None,
    ori=0, pos=(0.5, 0), size=(0.5, 0.5),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-3.0)

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "EndWordLearning"
EndWordLearningClock = core.Clock()
text_EndWL = visual.TextStim(win=win, name='text_EndWL',
    text="This is the end of the second phase. \n\nPlease press 'Space' to move to the third phase whenever you are ready",
    font='Arial',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_EndWL = keyboard.Keyboard()
phases_endWL = visual.TextStim(win=win, name='phases_endWL',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);

# Initialize components for Routine "Phase3Instructions1"
Phase3Instructions1Clock = core.Clock()
text_CTInstructionsT1 = visual.TextStim(win=win, name='text_CTInstructionsT1',
    text='Phase 3: Criterion test phase\n\nYou will have two tasks. \n\nIn Task 1: You will hear a word and see a picture, your task is to decide whether this picture represents the word you just heard. \n\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task\n',
    font='Arial',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_CTinstructionsT1 = keyboard.Keyboard()

# Initialize components for Routine "CriterionTestT1T1"
CriterionTestT1T1Clock = core.Clock()
sound_thuri2 = sound.Sound('Sounds/thuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thuri2')
sound_thuri2.setVolume(1)
image_thuri2 = visual.ImageStim(
    win=win,
    name='image_thuri2', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
Text_CT_T1T1 = visual.TextStim(win=win, name='Text_CT_T1T1',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T1 = keyboard.Keyboard()
phases_CT_T1T1 = visual.TextStim(win=win, name='phases_CT_T1T1',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:   0%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CriterionTestT1T2"
CriterionTestT1T2Clock = core.Clock()
sound_thano2 = sound.Sound('Sounds/thano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thano2')
sound_thano2.setVolume(1)
image_ththami2 = visual.ImageStim(
    win=win,
    name='image_ththami2', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T2 = visual.TextStim(win=win, name='text_CT_T1T2',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T2 = keyboard.Keyboard()
phases_CT_T1T2 = visual.TextStim(win=win, name='phases_CT_T1T2',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:   4%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CriterionTestT1T3"
CriterionTestT1T3Clock = core.Clock()
sound_ththuri3 = sound.Sound('Sounds/ththuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththuri3')
sound_ththuri3.setVolume(1)
image_ththuri3 = visual.ImageStim(
    win=win,
    name='image_ththuri3', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T3 = visual.TextStim(win=win, name='text_CT_T1T3',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T3 = keyboard.Keyboard()
phases_CT_T1T3 = visual.TextStim(win=win, name='phases_CT_T1T3',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:   8%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CriterionTestT1T4"
CriterionTestT1T4Clock = core.Clock()
sound_thami3 = sound.Sound('Sounds/thami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thami3')
sound_thami3.setVolume(1)
image_thami3 = visual.ImageStim(
    win=win,
    name='image_thami3', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T4 = visual.TextStim(win=win, name='text_CT_T1T4',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T4 = keyboard.Keyboard()
phases_CT_T1T4 = visual.TextStim(win=win, name='phases_CT_T1T4',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  12%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CriteterionTestT1T5"
CriteterionTestT1T5Clock = core.Clock()
sound_ththano2 = sound.Sound('Sounds/ththano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththano2')
sound_ththano2.setVolume(1)
image_thuri3 = visual.ImageStim(
    win=win,
    name='image_thuri3', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T5 = visual.TextStim(win=win, name='text_CT_T1T5',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T5 = keyboard.Keyboard()
phases_CT_T1T5 = visual.TextStim(win=win, name='phases_CT_T1T5',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  16%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CriterionTestT1T6"
CriterionTestT1T6Clock = core.Clock()
sound_ththami3 = sound.Sound('Sounds/ththami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththami3')
sound_ththami3.setVolume(1)
image_ththami3 = visual.ImageStim(
    win=win,
    name='image_ththami3', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T6 = visual.TextStim(win=win, name='text_CT_T1T6',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T6 = keyboard.Keyboard()
phases_CT_T1T6 = visual.TextStim(win=win, name='phases_CT_T1T6',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  20%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CritertionTestT1T7"
CritertionTestT1T7Clock = core.Clock()
sound_thuri3 = sound.Sound('Sounds/thuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thuri3')
sound_thuri3.setVolume(1)
image_ththano2 = visual.ImageStim(
    win=win,
    name='image_ththano2', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T7 = visual.TextStim(win=win, name='text_CT_T1T7',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T7 = keyboard.Keyboard()
phases_CT_T1T7 = visual.TextStim(win=win, name='phases_CT_T1T7',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  25%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CriterionTestT1T8"
CriterionTestT1T8Clock = core.Clock()
sound_ththuri2 = sound.Sound('Sounds/ththuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththuri2')
sound_ththuri2.setVolume(1)
image_thami2 = visual.ImageStim(
    win=win,
    name='image_thami2', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T8 = visual.TextStim(win=win, name='text_CT_T1T8',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T8 = keyboard.Keyboard()
phases_CT_T1T8 = visual.TextStim(win=win, name='phases_CT_T1T8',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  29%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CriterionTestT1T9"
CriterionTestT1T9Clock = core.Clock()
sound_thano3 = sound.Sound('Sounds/thano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thano3')
sound_thano3.setVolume(1)
image_thano3 = visual.ImageStim(
    win=win,
    name='image_thano3', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T9 = visual.TextStim(win=win, name='text_CT_T1T9',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T9 = keyboard.Keyboard()
phases_CT_T1T9 = visual.TextStim(win=win, name='phases_CT_T1T9',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  33%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CritertionTestT1T10"
CritertionTestT1T10Clock = core.Clock()
sound_ththami2 = sound.Sound('Sounds/ththami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththami2')
sound_ththami2.setVolume(1)
image_thano2 = visual.ImageStim(
    win=win,
    name='image_thano2', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T10 = visual.TextStim(win=win, name='text_CT_T1T10',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T10 = keyboard.Keyboard()
phases_CT_T1T10 = visual.TextStim(win=win, name='phases_CT_T1T10',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  37%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CriterionTestT1T11"
CriterionTestT1T11Clock = core.Clock()
sound_ththano3 = sound.Sound('Sounds/ththano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththano3')
sound_ththano3.setVolume(1)
image_ththano3 = visual.ImageStim(
    win=win,
    name='image_ththano3', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T11 = visual.TextStim(win=win, name='text_CT_T1T11',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T11 = keyboard.Keyboard()
phases_CT_T1T11 = visual.TextStim(win=win, name='phases_CT_T1T11',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  41%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "CriterionTestT1T12"
CriterionTestT1T12Clock = core.Clock()
sound_thami2 = sound.Sound('Sounds/thami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thami2')
sound_thami2.setVolume(1)
image_ththuri2 = visual.ImageStim(
    win=win,
    name='image_ththuri2', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T1T12 = visual.TextStim(win=win, name='text_CT_T1T12',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_CT_T1T12 = keyboard.Keyboard()
phases_CT_T1T12 = visual.TextStim(win=win, name='phases_CT_T1T12',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  45%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Phase3instructions2_2"
Phase3instructions2_2Clock = core.Clock()
text_CTinstructions2 = visual.TextStim(win=win, name='text_CTinstructions2',
    text="In task 2: you will have two pictures and you will hear a word.\n\nYour task is to choose the correct picture that represents the word. \n\nChoose either '1' or '0' \n\nReady? Press 'Space' to start the task. ",
    font='Arial',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_CTinstructions2 = keyboard.Keyboard()

# Initialize components for Routine "CriterionTestT2T1"
CriterionTestT2T1Clock = core.Clock()
image_ththuri4 = visual.ImageStim(
    win=win,
    name='image_ththuri4', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thano4 = visual.ImageStim(
    win=win,
    name='image_thano4', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T1_1 = visual.TextStim(win=win, name='text_CT_T2T1_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T1_0 = visual.TextStim(win=win, name='text_CT_T2T1_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththuri4 = sound.Sound('Sounds/ththuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththuri4')
sound_ththuri4.setVolume(1)
text_CT_T2T1 = visual.TextStim(win=win, name='text_CT_T2T1',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T1 = keyboard.Keyboard()
phases_CT_T2T1 = visual.TextStim(win=win, name='phases_CT_T2T1',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  50%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT2T2"
CriterionTestT2T2Clock = core.Clock()
image_thuri4 = visual.ImageStim(
    win=win,
    name='image_thuri4', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_ththami4 = visual.ImageStim(
    win=win,
    name='image_ththami4', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T2_1 = visual.TextStim(win=win, name='text_CT_T2T2_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T2_0 = visual.TextStim(win=win, name='text_CT_T2T2_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththami4 = sound.Sound('Sounds/ththami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththami4')
sound_ththami4.setVolume(1)
text_CT_T2T2 = visual.TextStim(win=win, name='text_CT_T2T2',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T2 = keyboard.Keyboard()
CT_T2T2 = visual.TextStim(win=win, name='CT_T2T2',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  54%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT2T3"
CriterionTestT2T3Clock = core.Clock()
image_ththano4 = visual.ImageStim(
    win=win,
    name='image_ththano4', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thami4 = visual.ImageStim(
    win=win,
    name='image_thami4', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T3_1 = visual.TextStim(win=win, name='text_CT_T2T3_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T3_0 = visual.TextStim(win=win, name='text_CT_T2T3_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththano4 = sound.Sound('Sounds/ththano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththano4')
sound_ththano4.setVolume(1)
text_CT_T2T3 = visual.TextStim(win=win, name='text_CT_T2T3',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T3 = keyboard.Keyboard()
phases_CT_T2T3 = visual.TextStim(win=win, name='phases_CT_T2T3',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  58%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT3T4"
CriterionTestT3T4Clock = core.Clock()
image_ththami5 = visual.ImageStim(
    win=win,
    name='image_ththami5', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thano5 = visual.ImageStim(
    win=win,
    name='image_thano5', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T4_1 = visual.TextStim(win=win, name='text_CT_T2T4_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T4_0 = visual.TextStim(win=win, name='text_CT_T2T4_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththami5 = sound.Sound('Sounds/ththami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththami5')
sound_ththami5.setVolume(1)
text_CT_T2T4 = visual.TextStim(win=win, name='text_CT_T2T4',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T4 = keyboard.Keyboard()
phases_CT_T2T4 = visual.TextStim(win=win, name='phases_CT_T2T4',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  62%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT2T5"
CriterionTestT2T5Clock = core.Clock()
image_thami5 = visual.ImageStim(
    win=win,
    name='image_thami5', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_ththuri5 = visual.ImageStim(
    win=win,
    name='image_ththuri5', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T5_1 = visual.TextStim(win=win, name='text_CT_T2T5_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T5_0 = visual.TextStim(win=win, name='text_CT_T2T5_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththuri5 = sound.Sound('Sounds/ththuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththuri5')
sound_ththuri5.setVolume(1)
text_CT_T2T5 = visual.TextStim(win=win, name='text_CT_T2T5',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T5 = keyboard.Keyboard()
phases_CT_T2T5 = visual.TextStim(win=win, name='phases_CT_T2T5',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  66%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT2T6"
CriterionTestT2T6Clock = core.Clock()
image_ththano5 = visual.ImageStim(
    win=win,
    name='image_ththano5', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thuri5 = visual.ImageStim(
    win=win,
    name='image_thuri5', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T6_1 = visual.TextStim(win=win, name='text_CT_T2T6_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T6_0 = visual.TextStim(win=win, name='text_CT_T2T6_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththano5 = sound.Sound('Sounds/ththano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththano5')
sound_ththano5.setVolume(1)
text_CT_T2T6 = visual.TextStim(win=win, name='text_CT_T2T6',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T6 = keyboard.Keyboard()
phases_CT_T2T6 = visual.TextStim(win=win, name='phases_CT_T2T6',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  70%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT2T7"
CriterionTestT2T7Clock = core.Clock()
image_ththami6 = visual.ImageStim(
    win=win,
    name='image_ththami6', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thuri6 = visual.ImageStim(
    win=win,
    name='image_thuri6', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T7_1 = visual.TextStim(win=win, name='text_CT_T2T7_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T7_0 = visual.TextStim(win=win, name='text_CT_T2T7_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thuri5 = sound.Sound('Sounds/thuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thuri5')
sound_thuri5.setVolume(1)
text_CT_T2T7 = visual.TextStim(win=win, name='text_CT_T2T7',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T7 = keyboard.Keyboard()
phases_CT_T2T7 = visual.TextStim(win=win, name='phases_CT_T2T7',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  75%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT2T8"
CriterionTestT2T8Clock = core.Clock()
image_ththano6 = visual.ImageStim(
    win=win,
    name='image_ththano6', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thami6 = visual.ImageStim(
    win=win,
    name='image_thami6', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T8_1 = visual.TextStim(win=win, name='text_CT_T2T8_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T8_0 = visual.TextStim(win=win, name='text_CT_T2T8_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thami4 = sound.Sound('Sounds/thami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thami4')
sound_thami4.setVolume(1)
text_CT_T2T8 = visual.TextStim(win=win, name='text_CT_T2T8',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T8 = keyboard.Keyboard()
phases_CT_T2T8 = visual.TextStim(win=win, name='phases_CT_T2T8',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  79%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT2T9"
CriterionTestT2T9Clock = core.Clock()
image_ththuri6 = visual.ImageStim(
    win=win,
    name='image_ththuri6', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thano6 = visual.ImageStim(
    win=win,
    name='image_thano6', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T9_1 = visual.TextStim(win=win, name='text_CT_T2T9_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T9_0 = visual.TextStim(win=win, name='text_CT_T2T9_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thano4 = sound.Sound('Sounds/thano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thano4')
sound_thano4.setVolume(1)
text_CT_T2T9 = visual.TextStim(win=win, name='text_CT_T2T9',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T9 = keyboard.Keyboard()
phases_CT_T2T9 = visual.TextStim(win=win, name='phases_CT_T2T9',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  83%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT2T10"
CriterionTestT2T10Clock = core.Clock()
image_thuri7 = visual.ImageStim(
    win=win,
    name='image_thuri7', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_ththano7 = visual.ImageStim(
    win=win,
    name='image_ththano7', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T10_1 = visual.TextStim(win=win, name='text_CT_T2T10_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T10_0 = visual.TextStim(win=win, name='text_CT_T2T10_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thuri4 = sound.Sound('Sounds/thuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thuri4')
sound_thuri4.setVolume(1)
text_CT_T2T10 = visual.TextStim(win=win, name='text_CT_T2T10',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T10 = keyboard.Keyboard()
phases_CT_T2T10 = visual.TextStim(win=win, name='phases_CT_T2T10',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  87%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT2T11"
CriterionTestT2T11Clock = core.Clock()
image_ththami7 = visual.ImageStim(
    win=win,
    name='image_ththami7', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thano7 = visual.ImageStim(
    win=win,
    name='image_thano7', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T11_1 = visual.TextStim(win=win, name='text_CT_T2T11_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T11_0 = visual.TextStim(win=win, name='text_CT_T2T11_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thano5 = sound.Sound('Sounds/thano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thano5')
sound_thano5.setVolume(1)
text_CT_T2T11 = visual.TextStim(win=win, name='text_CT_T2T11',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T11 = keyboard.Keyboard()
phases_CT_T2T11 = visual.TextStim(win=win, name='phases_CT_T2T11',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  91%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "CriterionTestT2T12"
CriterionTestT2T12Clock = core.Clock()
image_thami7 = visual.ImageStim(
    win=win,
    name='image_thami7', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_ththuri7 = visual.ImageStim(
    win=win,
    name='image_ththuri7', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_CT_T2T12_1 = visual.TextStim(win=win, name='text_CT_T2T12_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_CT_T2T12_0 = visual.TextStim(win=win, name='text_CT_T2T12_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thami5 = sound.Sound('Sounds/thami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thami5')
sound_thami5.setVolume(1)
text_CT_T2T12 = visual.TextStim(win=win, name='text_CT_T2T12',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_CT_T2T12 = keyboard.Keyboard()
phases_CT_T2T12 = visual.TextStim(win=win, name='phases_CT_T2T12',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3:  95%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "EndCriterionTest"
EndCriterionTestClock = core.Clock()
text_EndCT = visual.TextStim(win=win, name='text_EndCT',
    text="This is the end of the third phase. \n\nPlease press 'Space' to move to the fourth phase whenever you are ready",
    font='Arial',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_EndCT = keyboard.Keyboard()
phases_endCT = visual.TextStim(win=win, name='phases_endCT',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);

# Initialize components for Routine "Phase4Instructions1"
Phase4Instructions1Clock = core.Clock()
text_FTinstructions1 = visual.TextStim(win=win, name='text_FTinstructions1',
    text='Phase 4: Final test phase\n\nYou will have two tasks very similar to those in Phase 3. \n\nIn Task 1: You will hear a word and see a picture, your task is to decide whether this picture represents the word you just heard. \n\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task\n',
    font='Arial',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_FTinstructions1 = keyboard.Keyboard()

# Initialize components for Routine "FinalTestT1T1"
FinalTestT1T1Clock = core.Clock()
sound_ththuri6 = sound.Sound('Sounds/ththuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththuri6')
sound_ththuri6.setVolume(1)
image_thuri8 = visual.ImageStim(
    win=win,
    name='image_thuri8', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T1 = visual.TextStim(win=win, name='text_FT_T1T1',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T1 = keyboard.Keyboard()
phases_FT_T1T1 = visual.TextStim(win=win, name='phases_FT_T1T1',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:   0%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T2"
FinalTestT1T2Clock = core.Clock()
sound_thami6 = sound.Sound('Sounds/thami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thami6')
sound_thami6.setVolume(1)
image_ththami8 = visual.ImageStim(
    win=win,
    name='image_ththami8', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T2 = visual.TextStim(win=win, name='text_FT_T1T2',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T2 = keyboard.Keyboard()
phases_FT_T1T2 = visual.TextStim(win=win, name='phases_FT_T1T2',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:   4%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T3"
FinalTestT1T3Clock = core.Clock()
sound_thuri6 = sound.Sound('Sounds/thuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thuri6')
sound_thuri6.setVolume(1)
image_thuri9 = visual.ImageStim(
    win=win,
    name='image_thuri9', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T3 = visual.TextStim(win=win, name='text_FT_T1T3',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T3 = keyboard.Keyboard()
phases_FT_T1T3 = visual.TextStim(win=win, name='phases_FT_T1T3',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:   8%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T4"
FinalTestT1T4Clock = core.Clock()
sound_ththami6 = sound.Sound('Sounds/ththami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththami6')
sound_ththami6.setVolume(1)
image_thami8 = visual.ImageStim(
    win=win,
    name='image_thami8', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T4 = visual.TextStim(win=win, name='text_FT_T1T4',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T4 = keyboard.Keyboard()
phases_FT_T1T4 = visual.TextStim(win=win, name='phases_FT_T1T4',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  12%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T5"
FinalTestT1T5Clock = core.Clock()
sound_thano6 = sound.Sound('Sounds/thano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thano6')
sound_thano6.setVolume(1)
image_thano8 = visual.ImageStim(
    win=win,
    name='image_thano8', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T5 = visual.TextStim(win=win, name='text_FT_T1T5',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T5 = keyboard.Keyboard()
phases_FT_T1T5 = visual.TextStim(win=win, name='phases_FT_T1T5',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  16%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T6"
FinalTestT1T6Clock = core.Clock()
sound_ththami7 = sound.Sound('Sounds/ththami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththami7')
sound_ththami7.setVolume(1)
image_ththami9 = visual.ImageStim(
    win=win,
    name='image_ththami9', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T6 = visual.TextStim(win=win, name='text_FT_T1T6',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T6 = keyboard.Keyboard()
phases_FT_T1T6 = visual.TextStim(win=win, name='phases_FT_T1T6',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  20%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T7"
FinalTestT1T7Clock = core.Clock()
sound_thami7 = sound.Sound('Sounds/thami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thami7')
sound_thami7.setVolume(1)
image_thami9 = visual.ImageStim(
    win=win,
    name='image_thami9', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T7 = visual.TextStim(win=win, name='text_FT_T1T7',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T7 = keyboard.Keyboard()
phases_FT_T1T7 = visual.TextStim(win=win, name='phases_FT_T1T7',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  25%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T8"
FinalTestT1T8Clock = core.Clock()
sound_ththano6 = sound.Sound('Sounds/ththano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththano6')
sound_ththano6.setVolume(1)
image_thano9 = visual.ImageStim(
    win=win,
    name='image_thano9', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T8 = visual.TextStim(win=win, name='text_FT_T1T8',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T8 = keyboard.Keyboard()
phases_FT_T1T8 = visual.TextStim(win=win, name='phases_FT_T1T8',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  29%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T9"
FinalTestT1T9Clock = core.Clock()
sound_ththuri7 = sound.Sound('Sounds/ththuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththuri7')
sound_ththuri7.setVolume(1)
image_ththuri8 = visual.ImageStim(
    win=win,
    name='image_ththuri8', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T9 = visual.TextStim(win=win, name='text_FT_T1T9',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T9 = keyboard.Keyboard()
phases_FT_T1T9 = visual.TextStim(win=win, name='phases_FT_T1T9',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  33%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T10"
FinalTestT1T10Clock = core.Clock()
sound_thano7 = sound.Sound('Sounds/thano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thano7')
sound_thano7.setVolume(1)
image_ththano8 = visual.ImageStim(
    win=win,
    name='image_ththano8', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T10 = visual.TextStim(win=win, name='text_FT_T1T10',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T10 = keyboard.Keyboard()
phases_FT_T1T10 = visual.TextStim(win=win, name='phases_FT_T1T10',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  37%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T11"
FinalTestT1T11Clock = core.Clock()
sound_thuri7 = sound.Sound('Sounds/thuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thuri7')
sound_thuri7.setVolume(1)
image_ththuri9 = visual.ImageStim(
    win=win,
    name='image_ththuri9', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T11 = visual.TextStim(win=win, name='text_FT_T1T11',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T11 = keyboard.Keyboard()
phases_FT_T1T11 = visual.TextStim(win=win, name='phases_FT_T1T11',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  41%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "FinalTestT1T12"
FinalTestT1T12Clock = core.Clock()
sound_ththano7 = sound.Sound('Sounds/ththano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththano7')
sound_ththano7.setVolume(1)
image_ththano9 = visual.ImageStim(
    win=win,
    name='image_ththano9', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(0, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T1T12 = visual.TextStim(win=win, name='text_FT_T1T12',
    text='Does the picture represent the word you heard?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0.25), height=0.07, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
key_FT_T1T12 = keyboard.Keyboard()
phases_FT_T1T12 = visual.TextStim(win=win, name='phases_FT_T1T12',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  45%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Phase4Instructions2"
Phase4Instructions2Clock = core.Clock()
text_FTinstructiosn2 = visual.TextStim(win=win, name='text_FTinstructiosn2',
    text="In task 2: you will have two pictures and you will hear a word.\n\nYour task is to choose the correct picture that represents the word. \n\nChoose either '1' or '0' \n\nReady? Press 'Space' to start the task. ",
    font='Arial',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_FTinstructions2 = keyboard.Keyboard()

# Initialize components for Routine "FinalTestT2T1"
FinalTestT2T1Clock = core.Clock()
image_ththami10 = visual.ImageStim(
    win=win,
    name='image_ththami10', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thami10 = visual.ImageStim(
    win=win,
    name='image_thami10', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T1_1 = visual.TextStim(win=win, name='text_FT_T2T1_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T1_0 = visual.TextStim(win=win, name='text_FT_T2T1_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththami8 = sound.Sound('Sounds/ththami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththami8')
sound_ththami8.setVolume(1)
text_FT_T2T1 = visual.TextStim(win=win, name='text_FT_T2T1',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T1 = keyboard.Keyboard()
phases_FT_T2T1 = visual.TextStim(win=win, name='phases_FT_T2T1',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  50%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T2"
FinalTestT2T2Clock = core.Clock()
image_thano10 = visual.ImageStim(
    win=win,
    name='image_thano10', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_ththano10 = visual.ImageStim(
    win=win,
    name='image_ththano10', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T2_1 = visual.TextStim(win=win, name='text_FT_T2T2_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T2_0 = visual.TextStim(win=win, name='text_FT_T2T2_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thano8 = sound.Sound('Sounds/thano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thano8')
sound_thano8.setVolume(1)
text_FT_T2T2 = visual.TextStim(win=win, name='text_FT_T2T2',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T2 = keyboard.Keyboard()
phases_FT_T2T2 = visual.TextStim(win=win, name='phases_FT_T2T2',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  54%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T3"
FinalTestT2T3Clock = core.Clock()
image_ththuri10 = visual.ImageStim(
    win=win,
    name='image_ththuri10', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thuri10 = visual.ImageStim(
    win=win,
    name='image_thuri10', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T3_1 = visual.TextStim(win=win, name='text_FT_T2T3_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T3_0 = visual.TextStim(win=win, name='text_FT_T2T3_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thuri8 = sound.Sound('Sounds/thuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thuri8')
sound_thuri8.setVolume(1)
text_FT_T2T3 = visual.TextStim(win=win, name='text_FT_T2T3',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T3 = keyboard.Keyboard()
phases_FT_T2T3 = visual.TextStim(win=win, name='phases_FT_T2T3',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  58%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T4"
FinalTestT2T4Clock = core.Clock()
image_thami11 = visual.ImageStim(
    win=win,
    name='image_thami11', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_ththami11 = visual.ImageStim(
    win=win,
    name='image_ththami11', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T4_1 = visual.TextStim(win=win, name='text_FT_T2T4_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T4_0 = visual.TextStim(win=win, name='text_FT_T2T4_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thami8 = sound.Sound('Sounds/thami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thami8')
sound_thami8.setVolume(1)
text_FT_T2T4 = visual.TextStim(win=win, name='text_FT_T2T4',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T4 = keyboard.Keyboard()
phases_FT_T2T4 = visual.TextStim(win=win, name='phases_FT_T2T4',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  62%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T5"
FinalTestT2T5Clock = core.Clock()
image_ththano11 = visual.ImageStim(
    win=win,
    name='image_ththano11', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thano11 = visual.ImageStim(
    win=win,
    name='image_thano11', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T5_1 = visual.TextStim(win=win, name='text_FT_T2T5_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T5_0 = visual.TextStim(win=win, name='text_FT_T2T5_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thano9 = sound.Sound('Sounds/thano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thano9')
sound_thano9.setVolume(0)
text_FT_T2T5 = visual.TextStim(win=win, name='text_FT_T2T5',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T5 = keyboard.Keyboard()
phases_FT_T2T5 = visual.TextStim(win=win, name='phases_FT_T2T5',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  66%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T6"
FinalTestT2T6Clock = core.Clock()
image_thuri11 = visual.ImageStim(
    win=win,
    name='image_thuri11', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_ththuri11 = visual.ImageStim(
    win=win,
    name='image_ththuri11', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T6_1 = visual.TextStim(win=win, name='text_FT_T2T6_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T6_0 = visual.TextStim(win=win, name='text_FT_T2T6_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththuri8 = sound.Sound('Sounds/ththuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththuri8')
sound_ththuri8.setVolume(0)
text_FT_T2T6 = visual.TextStim(win=win, name='text_FT_T2T6',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T6 = keyboard.Keyboard()
phases_FT_T2T6 = visual.TextStim(win=win, name='phases_FT_T2T6',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  70%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T7"
FinalTestT2T7Clock = core.Clock()
image_ththano12 = visual.ImageStim(
    win=win,
    name='image_ththano12', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thano12 = visual.ImageStim(
    win=win,
    name='image_thano12', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T7_1 = visual.TextStim(win=win, name='text_FT_T2T7_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T7_0 = visual.TextStim(win=win, name='text_FT_T2T7_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththano9 = sound.Sound('Sounds/ththano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththano9')
sound_ththano9.setVolume(1)
text_FT_T2T7 = visual.TextStim(win=win, name='text_FT_T2T7',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T7 = keyboard.Keyboard()
phases_FT_T2T7 = visual.TextStim(win=win, name='phases_FT_T2T7',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  75%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T8"
FinalTestT2T8Clock = core.Clock()
image_ththami12 = visual.ImageStim(
    win=win,
    name='image_ththami12', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thami12 = visual.ImageStim(
    win=win,
    name='image_thami12', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T8_1 = visual.TextStim(win=win, name='text_FT_T2T8_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T8_0 = visual.TextStim(win=win, name='text_FT_T2T8_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thami9 = sound.Sound('Sounds/thami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thami9')
sound_thami9.setVolume(1)
text_FT_T2T8 = visual.TextStim(win=win, name='text_FT_T2T8',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T8 = keyboard.Keyboard()
phases_FT_T2T8 = visual.TextStim(win=win, name='phases_FT_T2T8',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  79%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T9"
FinalTestT2T9Clock = core.Clock()
image_thuri12 = visual.ImageStim(
    win=win,
    name='image_thuri12', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_ththuri12 = visual.ImageStim(
    win=win,
    name='image_ththuri12', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T9_1 = visual.TextStim(win=win, name='text_FT_T2T9_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T9_0 = visual.TextStim(win=win, name='text_FT_T2T9_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_thuri9 = sound.Sound('Sounds/thuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thuri9')
sound_thuri9.setVolume(1)
text_FT_T2T9 = visual.TextStim(win=win, name='text_FT_T2T9',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T9 = keyboard.Keyboard()
phases_FT_T2T9 = visual.TextStim(win=win, name='phases_FT_T2T9',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  83%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T10"
FinalTestT2T10Clock = core.Clock()
image_thami13 = visual.ImageStim(
    win=win,
    name='image_thami13', 
    image='Images/thami2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_ththami13 = visual.ImageStim(
    win=win,
    name='image_ththami13', 
    image='Images/ththami2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T10_1 = visual.TextStim(win=win, name='text_FT_T2T10_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T10_0 = visual.TextStim(win=win, name='text_FT_T2T10_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththami9 = sound.Sound('Sounds/ththami.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththami9')
sound_ththami9.setVolume(1)
text_FT_T2T10 = visual.TextStim(win=win, name='text_FT_T2T10',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T10 = keyboard.Keyboard()
phases_FT_T2T10 = visual.TextStim(win=win, name='phases_FT_T2T10',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  87%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T11"
FinalTestT2T11Clock = core.Clock()
image_thano13 = visual.ImageStim(
    win=win,
    name='image_thano13', 
    image='Images/thano2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_ththano13 = visual.ImageStim(
    win=win,
    name='image_ththano13', 
    image='Images/ththano2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T11_1 = visual.TextStim(win=win, name='text_FT_T2T11_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T11_0 = visual.TextStim(win=win, name='text_FT_T2T11_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththano10 = sound.Sound('Sounds/ththano.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththano10')
sound_ththano10.setVolume(1)
text_FT_T2T11 = visual.TextStim(win=win, name='text_FT_T2T11',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T11 = keyboard.Keyboard()
phases_FT_T2T11 = visual.TextStim(win=win, name='phases_FT_T2T11',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  91%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "FinalTestT2T12"
FinalTestT2T12Clock = core.Clock()
image_ththuri13 = visual.ImageStim(
    win=win,
    name='image_ththuri13', 
    image='Images/ththuri2.jpg', mask=None,
    ori=0, pos=(-0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)
image_thuri13 = visual.ImageStim(
    win=win,
    name='image_thuri13', 
    image='Images/thuri2.jpg', mask=None,
    ori=0, pos=(0.5, -0.15), size=(0.45, 0.45),
    color=[1,1,1], colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=-1.0)
text_FT_T2T12_1 = visual.TextStim(win=win, name='text_FT_T2T12_1',
    text='1',
    font='Arial',
    pos=(-0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
text_FT_T2T12_0 = visual.TextStim(win=win, name='text_FT_T2T12_0',
    text='0',
    font='Arial',
    pos=(0.5, 0.2), height=0.15, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
sound_ththuri9 = sound.Sound('Sounds/ththuri.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththuri9')
sound_ththuri9.setVolume(1)
text_FT_T2T12 = visual.TextStim(win=win, name='text_FT_T2T12',
    text='Choose 1 or 0',
    font='Arial',
    pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-5.0);
key_FT_T2T12 = keyboard.Keyboard()
phases_FT_T2T12 = visual.TextStim(win=win, name='phases_FT_T2T12',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4:  95%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "EndPhase4"
EndPhase4Clock = core.Clock()
text_EndFT = visual.TextStim(win=win, name='text_EndFT',
    text="This is the end of the fourth phase. \n\nPlease press 'Space' to move to the final phase whenever you are ready",
    font='Arial',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_FTEng = keyboard.Keyboard()
phases_endFT = visual.TextStim(win=win, name='phases_endFT',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);

# Initialize components for Routine "Phase5Instructions1"
Phase5Instructions1Clock = core.Clock()
text_SRpos_tinstructions1 = visual.TextStim(win=win, name='text_SRpos_tinstructions1',
    text='Phase 5: Sound Recognition phase (post)\nThis phase is identical to the first phase\n\nYou will have 2 tasks\n\nIn task 1: You will hear 2 sounds. Your task is to decide whether these sounds are same or different\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task',
    font='Arial',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_SRpos_instructions = keyboard.Keyboard()

# Initialize components for Routine "Phase5T1T1"
Phase5T1T1Clock = core.Clock()
sound_thth9 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth9')
sound_thth9.setVolume(1)
sound_th6 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th6')
sound_th6.setVolume(1)
key_Ph5T1T1 = keyboard.Keyboard()
text_Ph5T1T1 = visual.TextStim(win=win, name='text_Ph5T1T1',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T1 = visual.TextStim(win=win, name='phases_Ph5T1T1',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:   0%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T2"
Phase5T1T2Clock = core.Clock()
sound_thth10 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth10')
sound_thth10.setVolume(1)
sound_thth11 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth11')
sound_thth11.setVolume(1)
key_Ph5T1T2 = keyboard.Keyboard()
text_Ph5T1T2 = visual.TextStim(win=win, name='text_Ph5T1T2',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T2 = visual.TextStim(win=win, name='phases_Ph5T1T2',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:   4%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T3"
Phase5T1T3Clock = core.Clock()
sound_thth12 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth12')
sound_thth12.setVolume(1)
sound_sh9 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh9')
sound_sh9.setVolume(1)
key_Ph5T1T3 = keyboard.Keyboard()
text_Ph5T1T3 = visual.TextStim(win=win, name='text_Ph5T1T3',
    text='Do they sound the same?\n\n1=Yes  0=No\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T3 = visual.TextStim(win=win, name='phases_Ph5T1T3',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:   8%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T4"
Phase5T1T4Clock = core.Clock()
sound_thth13 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth13')
sound_thth13.setVolume(1)
sound_thth14 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth14')
sound_thth14.setVolume(1)
key_Ph5T1T4 = keyboard.Keyboard()
text_Ph5T1T4 = visual.TextStim(win=win, name='text_Ph5T1T4',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T4 = visual.TextStim(win=win, name='phases_Ph5T1T4',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  12%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T5"
Phase5T1T5Clock = core.Clock()
sound_th10 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th10')
sound_th10.setVolume(1)
sound_thth15 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth15')
sound_thth15.setVolume(1)
key_Ph5T1T5 = keyboard.Keyboard()
text_Ph5T1T5 = visual.TextStim(win=win, name='text_Ph5T1T5',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T5 = visual.TextStim(win=win, name='phases_Ph5T1T5',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  16%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T6"
Phase5T1T6Clock = core.Clock()
sound_th11 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th11')
sound_th11.setVolume(1)
sound_th12 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th12')
sound_th12.setVolume(1)
key_Ph5T1T6 = keyboard.Keyboard()
text_Ph5T1T6 = visual.TextStim(win=win, name='text_Ph5T1T6',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T6 = visual.TextStim(win=win, name='phases_Ph5T1T6',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  20%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T7"
Phase5T1T7Clock = core.Clock()
sound_th13 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th13')
sound_th13.setVolume(1)
sound_sh10 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh10')
sound_sh10.setVolume(1)
key_Ph5T1T7 = keyboard.Keyboard()
text_Ph5T1T7 = visual.TextStim(win=win, name='text_Ph5T1T7',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T7 = visual.TextStim(win=win, name='phases_Ph5T1T7',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  25%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T8"
Phase5T1T8Clock = core.Clock()
sound_th14 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th14')
sound_th14.setVolume(1)
sound_th15 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th15')
sound_th15.setVolume(1)
key_Ph5T1T8 = keyboard.Keyboard()
text_Ph5T1T8 = visual.TextStim(win=win, name='text_Ph5T1T8',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T8 = visual.TextStim(win=win, name='phases_Ph5T1T8',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  29%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T9"
Phase5T1T9Clock = core.Clock()
sound_sh11 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh11')
sound_sh11.setVolume(1)
sound_thth16 = sound.Sound('Sounds/thth.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thth16')
sound_thth16.setVolume(1)
key_Ph5T1T9 = keyboard.Keyboard()
text_Ph5T1T9 = visual.TextStim(win=win, name='text_Ph5T1T9',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T9 = visual.TextStim(win=win, name='phases_Ph5T1T9',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  33%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T10"
Phase5T1T10Clock = core.Clock()
sound_sh12 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh12')
sound_sh12.setVolume(1)
sound_th16 = sound.Sound('Sounds/th.wav', secs=-1, stereo=True, hamming=True,
    name='sound_th16')
sound_th16.setVolume(1)
key_Ph5T1T10 = keyboard.Keyboard()
text_Ph5T1T10 = visual.TextStim(win=win, name='text_Ph5T1T10',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T10 = visual.TextStim(win=win, name='phases_Ph5T1T10',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  37%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T11"
Phase5T1T11Clock = core.Clock()
sound_sh13 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh13')
sound_sh13.setVolume(1)
sound_sh14 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh14')
sound_sh14.setVolume(1)
key_Ph5T1T11 = keyboard.Keyboard()
text_Ph5T1T11 = visual.TextStim(win=win, name='text_Ph5T1T11',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T11 = visual.TextStim(win=win, name='phases_Ph5T1T11',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  41%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T1T12"
Phase5T1T12Clock = core.Clock()
sound_sh15 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh15')
sound_sh15.setVolume(1)
sound_sh16 = sound.Sound('Sounds/sh.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh16')
sound_sh16.setVolume(1)
key_Ph5T1T12 = keyboard.Keyboard()
text_Ph5T1T12 = visual.TextStim(win=win, name='text_Ph5T1T12',
    text='Do they sound the same?\n\n1=Yes  0=No\n\n',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);
phases_Ph5T1T12 = visual.TextStim(win=win, name='phases_Ph5T1T12',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  45%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-4.0);

# Initialize components for Routine "Phase1instructions2"
Phase1instructions2Clock = core.Clock()
text_phase1_inst2 = visual.TextStim(win=win, name='text_phase1_inst2',
    text='\nIn task 2: You will hear 2 Arabic words that may sound the same or may differ only in the initial sound (minimal pairs). Your task is to decide whether the two words are the same or differ only in the initial sounds. \n\nPress 1 for Yes and 0 for No\n\nReady? press "Space" to start the task',
    font='Times New Romans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_phase1_inst2 = keyboard.Keyboard()

# Initialize components for Routine "Phase5T2T1"
Phase5T2T1Clock = core.Clock()
sound_thrwa_thrwa2 = sound.Sound('Sounds/thrwa-thrwa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thrwa_thrwa2')
sound_thrwa_thrwa2.setVolume(1)
key_Ph5T2T1 = keyboard.Keyboard()
text_2 = visual.TextStim(win=win, name='text_2',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T1 = visual.TextStim(win=win, name='phases_Ph5T2T1',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  50%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T2"
Phase5T2T2Clock = core.Clock()
sound_ththm_thm2 = sound.Sound('Sounds/ththm-thm.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththm_thm2')
sound_ththm_thm2.setVolume(1)
key_Ph5T2T2 = keyboard.Keyboard()
text_Ph5T2T2 = visual.TextStim(win=win, name='text_Ph5T2T2',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T2 = visual.TextStim(win=win, name='phases_Ph5T2T2',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  54%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T3"
Phase5T2T3Clock = core.Clock()
sound_ththab_shab2 = sound.Sound('Sounds/ththab-shab.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththab_shab2')
sound_ththab_shab2.setVolume(1)
key_Ph5T2T3 = keyboard.Keyboard()
text_Ph5T2T3 = visual.TextStim(win=win, name='text_Ph5T2T3',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T3 = visual.TextStim(win=win, name='phases_Ph5T2T3',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  58%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T4"
Phase5T2T4Clock = core.Clock()
sound_ththna_ththna2 = sound.Sound('Sounds/ththna-ththna.wav', secs=-1, stereo=True, hamming=True,
    name='sound_ththna_ththna2')
sound_ththna_ththna2.setVolume(1)
key_Ph5T2T4 = keyboard.Keyboard()
text_Ph5T2T4 = visual.TextStim(win=win, name='text_Ph5T2T4',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T4 = visual.TextStim(win=win, name='phases_Ph5T2T4',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  62%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T5"
Phase5T2T5Clock = core.Clock()
sound_thra_ththra2 = sound.Sound('Sounds/thra-ththra.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thra_ththra2')
sound_thra_ththra2.setVolume(1)
key_Ph5T2T5 = keyboard.Keyboard()
text_Ph5T2T5 = visual.TextStim(win=win, name='text_Ph5T2T5',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T5 = visual.TextStim(win=win, name='phases_Ph5T2T5',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  66%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T6"
Phase5T2T6Clock = core.Clock()
sound_thb7_shb72 = sound.Sound('Sounds/thb7-shb7.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thb7_shb72')
sound_thb7_shb72.setVolume(1)
key_Ph5T2T6 = keyboard.Keyboard()
text_Ph5T2T6 = visual.TextStim(win=win, name='text_Ph5T2T6',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T6 = visual.TextStim(win=win, name='phases_Ph5T2T6',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  70%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T7"
Phase5T2T7Clock = core.Clock()
sound_thwq_thwq2 = sound.Sound('Sounds/thwq-thwq.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thwq_thwq2')
sound_thwq_thwq2.setVolume(1)
key_Ph5T2T7 = keyboard.Keyboard()
text_Ph5T2T7 = visual.TextStim(win=win, name='text_Ph5T2T7',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T7 = visual.TextStim(win=win, name='phases_Ph5T2T7',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  75%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T8"
Phase5T2T8Clock = core.Clock()
sound_thail_thail2 = sound.Sound('Sounds/thail-thail.wav', secs=-1, stereo=True, hamming=True,
    name='sound_thail_thail2')
sound_thail_thail2.setVolume(1)
key_Ph5T2T8 = keyboard.Keyboard()
text_Ph5T2T8 = visual.TextStim(win=win, name='text_Ph5T2T8',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T8 = visual.TextStim(win=win, name='phases_Ph5T2T8',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  79%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T9"
Phase5T2T9Clock = core.Clock()
sound_shrf_thrf2 = sound.Sound('Sounds/shrf-thrf.wav', secs=-1, stereo=True, hamming=True,
    name='sound_shrf_thrf2')
sound_shrf_thrf2.setVolume(1)
key_Ph5T2T9 = keyboard.Keyboard()
text_Ph5T2T9 = visual.TextStim(win=win, name='text_Ph5T2T9',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T9 = visual.TextStim(win=win, name='phases_Ph5T2T9',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  83%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T10"
Phase5T2T10Clock = core.Clock()
sound_sh7m_sh7m2 = sound.Sound('Sounds/sh7m-sh7m.wav', secs=-1, stereo=True, hamming=True,
    name='sound_sh7m_sh7m2')
sound_sh7m_sh7m2.setVolume(1)
key_Ph5T2T10 = keyboard.Keyboard()
text_Ph5T2T10 = visual.TextStim(win=win, name='text_Ph5T2T10',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T10 = visual.TextStim(win=win, name='phases_Ph5T2T10',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  87%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T11"
Phase5T2T11Clock = core.Clock()
sound_shra_ththra2 = sound.Sound('Sounds/shra-ththra.wav', secs=-1, stereo=True, hamming=True,
    name='sound_shra_ththra2')
sound_shra_ththra2.setVolume(1)
key_Ph5T2T11 = keyboard.Keyboard()
text_Ph5T2T11 = visual.TextStim(win=win, name='text_Ph5T2T11',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T11 = visual.TextStim(win=win, name='phases_Ph5T2T11',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  91%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "Blank"
BlankClock = core.Clock()
text_blank = visual.TextStim(win=win, name='text_blank',
    text=None,
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Phase5T2T12"
Phase5T2T12Clock = core.Clock()
sound_shfa_shfa2 = sound.Sound('Sounds/shfa-shfa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_shfa_shfa2')
sound_shfa_shfa2.setVolume(1)
key_Ph5T2T12 = keyboard.Keyboard()
text_Ph5T2T12 = visual.TextStim(win=win, name='text_Ph5T2T12',
    text='Do the two words initially sound the same?\n\n1=Yes   0=No',
    font='Arial',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);
phases_Ph5T2T12 = visual.TextStim(win=win, name='phases_Ph5T2T12',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5:  95%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "EndExperiment"
EndExperimentClock = core.Clock()
text_EndExperiment = visual.TextStim(win=win, name='text_EndExperiment',
    text='This is the end of this session. \n\nThank you for your precious time\n\nPlease contact the researcher\n\nPress "Space" to exit',
    font='Arial',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_EndExperiment = keyboard.Keyboard()
phases_end = visual.TextStim(win=win, name='phases_end',
    text='Phase 1: 100%   Phase 2: 100%   Phase 3: 100%   Phase 4: 100%   Phase 5: 100%',
    font='Arial',
    pos=(0, -0.4), height=0.02, wrapWidth=None, ori=0, 
    color='red', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=-2.0);

# Create some handy timers
globalClock = core.Clock()  # to track the time since experiment started
routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 

# ------Prepare to start Routine "WelcomeScreen"-------
continueRoutine = True
# update component parameters for each repeat
key_welcome.keys = []
key_welcome.rt = []
_key_welcome_allKeys = []
# keep track of which components have finished
WelcomeScreenComponents = [textWelcome, key_welcome]
for thisComponent in WelcomeScreenComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
WelcomeScreenClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "WelcomeScreen"-------
while continueRoutine:
    # get current time
    t = WelcomeScreenClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=WelcomeScreenClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *textWelcome* updates
    if textWelcome.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        textWelcome.frameNStart = frameN  # exact frame index
        textWelcome.tStart = t  # local t and not account for scr refresh
        textWelcome.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(textWelcome, 'tStartRefresh')  # time at next scr refresh
        textWelcome.setAutoDraw(True)
    
    # *key_welcome* updates
    waitOnFlip = False
    if key_welcome.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_welcome.frameNStart = frameN  # exact frame index
        key_welcome.tStart = t  # local t and not account for scr refresh
        key_welcome.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_welcome, 'tStartRefresh')  # time at next scr refresh
        key_welcome.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_welcome.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_welcome.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_welcome.status == STARTED and not waitOnFlip:
        theseKeys = key_welcome.getKeys(keyList=['space'], waitRelease=False)
        _key_welcome_allKeys.extend(theseKeys)
        if len(_key_welcome_allKeys):
            key_welcome.keys = _key_welcome_allKeys[-1].name  # just the last key pressed
            key_welcome.rt = _key_welcome_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in WelcomeScreenComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "WelcomeScreen"-------
for thisComponent in WelcomeScreenComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('textWelcome.started', textWelcome.tStartRefresh)
thisExp.addData('textWelcome.stopped', textWelcome.tStopRefresh)
# check responses
if key_welcome.keys in ['', [], None]:  # No response was made
    key_welcome.keys = None
thisExp.addData('key_welcome.keys',key_welcome.keys)
if key_welcome.keys != None:  # we had a response
    thisExp.addData('key_welcome.rt', key_welcome.rt)
thisExp.addData('key_welcome.started', key_welcome.tStartRefresh)
thisExp.addData('key_welcome.stopped', key_welcome.tStopRefresh)
thisExp.nextEntry()
# the Routine "WelcomeScreen" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "GeneralInstruction"-------
continueRoutine = True
# update component parameters for each repeat
key_Gen_inst.keys = []
key_Gen_inst.rt = []
_key_Gen_inst_allKeys = []
# keep track of which components have finished
GeneralInstructionComponents = [text_gen_inst, key_Gen_inst]
for thisComponent in GeneralInstructionComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
GeneralInstructionClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "GeneralInstruction"-------
while continueRoutine:
    # get current time
    t = GeneralInstructionClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=GeneralInstructionClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_gen_inst* updates
    if text_gen_inst.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_gen_inst.frameNStart = frameN  # exact frame index
        text_gen_inst.tStart = t  # local t and not account for scr refresh
        text_gen_inst.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_gen_inst, 'tStartRefresh')  # time at next scr refresh
        text_gen_inst.setAutoDraw(True)
    
    # *key_Gen_inst* updates
    waitOnFlip = False
    if key_Gen_inst.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_Gen_inst.frameNStart = frameN  # exact frame index
        key_Gen_inst.tStart = t  # local t and not account for scr refresh
        key_Gen_inst.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Gen_inst, 'tStartRefresh')  # time at next scr refresh
        key_Gen_inst.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Gen_inst.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Gen_inst.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Gen_inst.status == STARTED and not waitOnFlip:
        theseKeys = key_Gen_inst.getKeys(keyList=['space'], waitRelease=False)
        _key_Gen_inst_allKeys.extend(theseKeys)
        if len(_key_Gen_inst_allKeys):
            key_Gen_inst.keys = _key_Gen_inst_allKeys[-1].name  # just the last key pressed
            key_Gen_inst.rt = _key_Gen_inst_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in GeneralInstructionComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "GeneralInstruction"-------
for thisComponent in GeneralInstructionComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_gen_inst.started', text_gen_inst.tStartRefresh)
thisExp.addData('text_gen_inst.stopped', text_gen_inst.tStopRefresh)
# check responses
if key_Gen_inst.keys in ['', [], None]:  # No response was made
    key_Gen_inst.keys = None
thisExp.addData('key_Gen_inst.keys',key_Gen_inst.keys)
if key_Gen_inst.keys != None:  # we had a response
    thisExp.addData('key_Gen_inst.rt', key_Gen_inst.rt)
thisExp.addData('key_Gen_inst.started', key_Gen_inst.tStartRefresh)
thisExp.addData('key_Gen_inst.stopped', key_Gen_inst.tStopRefresh)
thisExp.nextEntry()
# the Routine "GeneralInstruction" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Phase1instructions"-------
continueRoutine = True
# update component parameters for each repeat
key_Phase1_inst.keys = []
key_Phase1_inst.rt = []
_key_Phase1_inst_allKeys = []
# keep track of which components have finished
Phase1instructionsComponents = [Phase1_inst, key_Phase1_inst]
for thisComponent in Phase1instructionsComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase1instructionsClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase1instructions"-------
while continueRoutine:
    # get current time
    t = Phase1instructionsClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase1instructionsClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *Phase1_inst* updates
    if Phase1_inst.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        Phase1_inst.frameNStart = frameN  # exact frame index
        Phase1_inst.tStart = t  # local t and not account for scr refresh
        Phase1_inst.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(Phase1_inst, 'tStartRefresh')  # time at next scr refresh
        Phase1_inst.setAutoDraw(True)
    
    # *key_Phase1_inst* updates
    waitOnFlip = False
    if key_Phase1_inst.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_Phase1_inst.frameNStart = frameN  # exact frame index
        key_Phase1_inst.tStart = t  # local t and not account for scr refresh
        key_Phase1_inst.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Phase1_inst, 'tStartRefresh')  # time at next scr refresh
        key_Phase1_inst.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Phase1_inst.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Phase1_inst.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Phase1_inst.status == STARTED and not waitOnFlip:
        theseKeys = key_Phase1_inst.getKeys(keyList=['space'], waitRelease=False)
        _key_Phase1_inst_allKeys.extend(theseKeys)
        if len(_key_Phase1_inst_allKeys):
            key_Phase1_inst.keys = _key_Phase1_inst_allKeys[-1].name  # just the last key pressed
            key_Phase1_inst.rt = _key_Phase1_inst_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase1instructionsComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase1instructions"-------
for thisComponent in Phase1instructionsComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('Phase1_inst.started', Phase1_inst.tStartRefresh)
thisExp.addData('Phase1_inst.stopped', Phase1_inst.tStopRefresh)
# check responses
if key_Phase1_inst.keys in ['', [], None]:  # No response was made
    key_Phase1_inst.keys = None
thisExp.addData('key_Phase1_inst.keys',key_Phase1_inst.keys)
if key_Phase1_inst.keys != None:  # we had a response
    thisExp.addData('key_Phase1_inst.rt', key_Phase1_inst.rt)
thisExp.addData('key_Phase1_inst.started', key_Phase1_inst.tStartRefresh)
thisExp.addData('key_Phase1_inst.stopped', key_Phase1_inst.tStopRefresh)
thisExp.nextEntry()
# the Routine "Phase1instructions" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "SoundRecognitionT1T1"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_thth.setSound('Sounds/thth.wav', hamming=True)
sound_thth.setVolume(1, log=False)
sound_th.setSound('Sounds/th.wav', hamming=True)
sound_th.setVolume(1, log=False)
key_SRT1T1.keys = []
key_SRT1T1.rt = []
_key_SRT1T1_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T1Components = [sound_thth, sound_th, key_SRT1T1, text_SRT1T1, phases_SRT1T1]
for thisComponent in SoundRecognitionT1T1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T1"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thth
    if sound_thth.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thth.frameNStart = frameN  # exact frame index
        sound_thth.tStart = t  # local t and not account for scr refresh
        sound_thth.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth.play(when=win)  # sync with win flip
    if sound_thth.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth.tStop = t  # not accounting for scr refresh
            sound_thth.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth, 'tStopRefresh')  # time at next scr refresh
            sound_thth.stop()
    # start/stop sound_th
    if sound_th.status == NOT_STARTED and t >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_th.frameNStart = frameN  # exact frame index
        sound_th.tStart = t  # local t and not account for scr refresh
        sound_th.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th.play()  # start the sound (it finishes automatically)
    if sound_th.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th.tStop = t  # not accounting for scr refresh
            sound_th.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th, 'tStopRefresh')  # time at next scr refresh
            sound_th.stop()
    
    # *key_SRT1T1* updates
    waitOnFlip = False
    if key_SRT1T1.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T1.frameNStart = frameN  # exact frame index
        key_SRT1T1.tStart = t  # local t and not account for scr refresh
        key_SRT1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T1, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T1.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T1.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T1.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T1.tStop = t  # not accounting for scr refresh
            key_SRT1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T1, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T1.status = FINISHED
    if key_SRT1T1.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T1.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T1_allKeys.extend(theseKeys)
        if len(_key_SRT1T1_allKeys):
            key_SRT1T1.keys = _key_SRT1T1_allKeys[-1].name  # just the last key pressed
            key_SRT1T1.rt = _key_SRT1T1_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T1.keys == str('0')) or (key_SRT1T1.keys == '0'):
                key_SRT1T1.corr = 1
            else:
                key_SRT1T1.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T1* updates
    if text_SRT1T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T1.frameNStart = frameN  # exact frame index
        text_SRT1T1.tStart = t  # local t and not account for scr refresh
        text_SRT1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T1, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T1.setAutoDraw(True)
    if text_SRT1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T1.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T1.tStop = t  # not accounting for scr refresh
            text_SRT1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T1, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T1.setAutoDraw(False)
    
    # *phases_SRT1T1* updates
    if phases_SRT1T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T1.frameNStart = frameN  # exact frame index
        phases_SRT1T1.tStart = t  # local t and not account for scr refresh
        phases_SRT1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T1, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T1.setAutoDraw(True)
    if phases_SRT1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T1.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T1.tStop = t  # not accounting for scr refresh
            phases_SRT1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T1, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T1.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T1"-------
for thisComponent in SoundRecognitionT1T1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thth.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth.started', sound_thth.tStartRefresh)
thisExp.addData('sound_thth.stopped', sound_thth.tStopRefresh)
sound_th.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th.started', sound_th.tStart)
thisExp.addData('sound_th.stopped', sound_th.tStop)
# check responses
if key_SRT1T1.keys in ['', [], None]:  # No response was made
    key_SRT1T1.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT1T1.corr = 1;  # correct non-response
    else:
       key_SRT1T1.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T1.keys',key_SRT1T1.keys)
thisExp.addData('key_SRT1T1.corr', key_SRT1T1.corr)
if key_SRT1T1.keys != None:  # we had a response
    thisExp.addData('key_SRT1T1.rt', key_SRT1T1.rt)
thisExp.addData('key_SRT1T1.started', key_SRT1T1.tStartRefresh)
thisExp.addData('key_SRT1T1.stopped', key_SRT1T1.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T1.started', text_SRT1T1.tStartRefresh)
thisExp.addData('text_SRT1T1.stopped', text_SRT1T1.tStopRefresh)
thisExp.addData('phases_SRT1T1.started', phases_SRT1T1.tStartRefresh)
thisExp.addData('phases_SRT1T1.stopped', phases_SRT1T1.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T2"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_thth2.setSound('Sounds/thth.wav', hamming=True)
sound_thth2.setVolume(1, log=False)
sound_thth3.setSound('Sounds/thth.wav', hamming=False)
sound_thth3.setVolume(1, log=False)
key_SRT1T2.keys = []
key_SRT1T2.rt = []
_key_SRT1T2_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T2Components = [sound_thth2, sound_thth3, key_SRT1T2, text_SRT1T2, phases_SRT1T2]
for thisComponent in SoundRecognitionT1T2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T2"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thth2
    if sound_thth2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thth2.frameNStart = frameN  # exact frame index
        sound_thth2.tStart = t  # local t and not account for scr refresh
        sound_thth2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth2.play(when=win)  # sync with win flip
    if sound_thth2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth2.tStop = t  # not accounting for scr refresh
            sound_thth2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth2, 'tStopRefresh')  # time at next scr refresh
            sound_thth2.stop()
    # start/stop sound_thth3
    if sound_thth3.status == NOT_STARTED and t >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_thth3.frameNStart = frameN  # exact frame index
        sound_thth3.tStart = t  # local t and not account for scr refresh
        sound_thth3.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth3.play()  # start the sound (it finishes automatically)
    if sound_thth3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth3.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth3.tStop = t  # not accounting for scr refresh
            sound_thth3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth3, 'tStopRefresh')  # time at next scr refresh
            sound_thth3.stop()
    
    # *key_SRT1T2* updates
    waitOnFlip = False
    if key_SRT1T2.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T2.frameNStart = frameN  # exact frame index
        key_SRT1T2.tStart = t  # local t and not account for scr refresh
        key_SRT1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T2, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T2.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T2.tStop = t  # not accounting for scr refresh
            key_SRT1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T2, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T2.status = FINISHED
    if key_SRT1T2.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T2.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T2_allKeys.extend(theseKeys)
        if len(_key_SRT1T2_allKeys):
            key_SRT1T2.keys = _key_SRT1T2_allKeys[-1].name  # just the last key pressed
            key_SRT1T2.rt = _key_SRT1T2_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T2.keys == str('1')) or (key_SRT1T2.keys == '1'):
                key_SRT1T2.corr = 1
            else:
                key_SRT1T2.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T2* updates
    if text_SRT1T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T2.frameNStart = frameN  # exact frame index
        text_SRT1T2.tStart = t  # local t and not account for scr refresh
        text_SRT1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T2, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T2.setAutoDraw(True)
    if text_SRT1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T2.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T2.tStop = t  # not accounting for scr refresh
            text_SRT1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T2, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T2.setAutoDraw(False)
    
    # *phases_SRT1T2* updates
    if phases_SRT1T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T2.frameNStart = frameN  # exact frame index
        phases_SRT1T2.tStart = t  # local t and not account for scr refresh
        phases_SRT1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T2, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T2.setAutoDraw(True)
    if phases_SRT1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T2.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T2.tStop = t  # not accounting for scr refresh
            phases_SRT1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T2, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T2.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T2"-------
for thisComponent in SoundRecognitionT1T2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thth2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth2.started', sound_thth2.tStartRefresh)
thisExp.addData('sound_thth2.stopped', sound_thth2.tStopRefresh)
sound_thth3.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth3.started', sound_thth3.tStart)
thisExp.addData('sound_thth3.stopped', sound_thth3.tStop)
# check responses
if key_SRT1T2.keys in ['', [], None]:  # No response was made
    key_SRT1T2.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT1T2.corr = 1;  # correct non-response
    else:
       key_SRT1T2.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T2.keys',key_SRT1T2.keys)
thisExp.addData('key_SRT1T2.corr', key_SRT1T2.corr)
if key_SRT1T2.keys != None:  # we had a response
    thisExp.addData('key_SRT1T2.rt', key_SRT1T2.rt)
thisExp.addData('key_SRT1T2.started', key_SRT1T2.tStartRefresh)
thisExp.addData('key_SRT1T2.stopped', key_SRT1T2.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T2.started', text_SRT1T2.tStartRefresh)
thisExp.addData('text_SRT1T2.stopped', text_SRT1T2.tStopRefresh)
thisExp.addData('phases_SRT1T2.started', phases_SRT1T2.tStartRefresh)
thisExp.addData('phases_SRT1T2.stopped', phases_SRT1T2.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T3"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_thth4.setSound('Sounds/thth.wav', hamming=True)
sound_thth4.setVolume(1, log=False)
sound_sh.setSound('Sounds/sh.wav', hamming=True)
sound_sh.setVolume(1, log=False)
key_SRT1T3.keys = []
key_SRT1T3.rt = []
_key_SRT1T3_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T3Components = [sound_thth4, sound_sh, key_SRT1T3, text_SRT1T3, phases_SRT1T3]
for thisComponent in SoundRecognitionT1T3Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T3"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T3Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T3Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thth4
    if sound_thth4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thth4.frameNStart = frameN  # exact frame index
        sound_thth4.tStart = t  # local t and not account for scr refresh
        sound_thth4.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth4.play(when=win)  # sync with win flip
    if sound_thth4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth4.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth4.tStop = t  # not accounting for scr refresh
            sound_thth4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth4, 'tStopRefresh')  # time at next scr refresh
            sound_thth4.stop()
    # start/stop sound_sh
    if sound_sh.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_sh.frameNStart = frameN  # exact frame index
        sound_sh.tStart = t  # local t and not account for scr refresh
        sound_sh.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh.play(when=win)  # sync with win flip
    if sound_sh.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh.tStop = t  # not accounting for scr refresh
            sound_sh.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh, 'tStopRefresh')  # time at next scr refresh
            sound_sh.stop()
    
    # *key_SRT1T3* updates
    waitOnFlip = False
    if key_SRT1T3.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T3.frameNStart = frameN  # exact frame index
        key_SRT1T3.tStart = t  # local t and not account for scr refresh
        key_SRT1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T3, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T3.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T3.tStop = t  # not accounting for scr refresh
            key_SRT1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T3, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T3.status = FINISHED
    if key_SRT1T3.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T3.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T3_allKeys.extend(theseKeys)
        if len(_key_SRT1T3_allKeys):
            key_SRT1T3.keys = _key_SRT1T3_allKeys[-1].name  # just the last key pressed
            key_SRT1T3.rt = _key_SRT1T3_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T3.keys == str('0')) or (key_SRT1T3.keys == '0'):
                key_SRT1T3.corr = 1
            else:
                key_SRT1T3.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T3* updates
    if text_SRT1T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T3.frameNStart = frameN  # exact frame index
        text_SRT1T3.tStart = t  # local t and not account for scr refresh
        text_SRT1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T3, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T3.setAutoDraw(True)
    if text_SRT1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T3.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T3.tStop = t  # not accounting for scr refresh
            text_SRT1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T3, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T3.setAutoDraw(False)
    
    # *phases_SRT1T3* updates
    if phases_SRT1T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T3.frameNStart = frameN  # exact frame index
        phases_SRT1T3.tStart = t  # local t and not account for scr refresh
        phases_SRT1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T3, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T3.setAutoDraw(True)
    if phases_SRT1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T3.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T3.tStop = t  # not accounting for scr refresh
            phases_SRT1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T3, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T3.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T3Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T3"-------
for thisComponent in SoundRecognitionT1T3Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thth4.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth4.started', sound_thth4.tStartRefresh)
thisExp.addData('sound_thth4.stopped', sound_thth4.tStopRefresh)
sound_sh.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh.started', sound_sh.tStartRefresh)
thisExp.addData('sound_sh.stopped', sound_sh.tStopRefresh)
# check responses
if key_SRT1T3.keys in ['', [], None]:  # No response was made
    key_SRT1T3.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT1T3.corr = 1;  # correct non-response
    else:
       key_SRT1T3.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T3.keys',key_SRT1T3.keys)
thisExp.addData('key_SRT1T3.corr', key_SRT1T3.corr)
if key_SRT1T3.keys != None:  # we had a response
    thisExp.addData('key_SRT1T3.rt', key_SRT1T3.rt)
thisExp.addData('key_SRT1T3.started', key_SRT1T3.tStartRefresh)
thisExp.addData('key_SRT1T3.stopped', key_SRT1T3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T3.started', text_SRT1T3.tStartRefresh)
thisExp.addData('text_SRT1T3.stopped', text_SRT1T3.tStopRefresh)
thisExp.addData('phases_SRT1T3.started', phases_SRT1T3.tStartRefresh)
thisExp.addData('phases_SRT1T3.stopped', phases_SRT1T3.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T4"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_thth5.setSound('Sounds/thth.wav', hamming=True)
sound_thth5.setVolume(1, log=False)
sound_thth6.setSound('Sounds/thth.wav', hamming=True)
sound_thth6.setVolume(1, log=False)
key_SRT1T4.keys = []
key_SRT1T4.rt = []
_key_SRT1T4_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T4Components = [sound_thth5, sound_thth6, key_SRT1T4, text_SRT1T4, phases_SRT1T4]
for thisComponent in SoundRecognitionT1T4Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T4"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T4Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T4Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thth5
    if sound_thth5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thth5.frameNStart = frameN  # exact frame index
        sound_thth5.tStart = t  # local t and not account for scr refresh
        sound_thth5.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth5.play(when=win)  # sync with win flip
    if sound_thth5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth5.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth5.tStop = t  # not accounting for scr refresh
            sound_thth5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth5, 'tStopRefresh')  # time at next scr refresh
            sound_thth5.stop()
    # start/stop sound_thth6
    if sound_thth6.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_thth6.frameNStart = frameN  # exact frame index
        sound_thth6.tStart = t  # local t and not account for scr refresh
        sound_thth6.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth6.play(when=win)  # sync with win flip
    if sound_thth6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth6.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth6.tStop = t  # not accounting for scr refresh
            sound_thth6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth6, 'tStopRefresh')  # time at next scr refresh
            sound_thth6.stop()
    
    # *key_SRT1T4* updates
    waitOnFlip = False
    if key_SRT1T4.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T4.frameNStart = frameN  # exact frame index
        key_SRT1T4.tStart = t  # local t and not account for scr refresh
        key_SRT1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T4, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T4.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T4.tStop = t  # not accounting for scr refresh
            key_SRT1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T4, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T4.status = FINISHED
    if key_SRT1T4.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T4.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T4_allKeys.extend(theseKeys)
        if len(_key_SRT1T4_allKeys):
            key_SRT1T4.keys = _key_SRT1T4_allKeys[-1].name  # just the last key pressed
            key_SRT1T4.rt = _key_SRT1T4_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T4.keys == str('1')) or (key_SRT1T4.keys == '1'):
                key_SRT1T4.corr = 1
            else:
                key_SRT1T4.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T4* updates
    if text_SRT1T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T4.frameNStart = frameN  # exact frame index
        text_SRT1T4.tStart = t  # local t and not account for scr refresh
        text_SRT1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T4, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T4.setAutoDraw(True)
    if text_SRT1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T4.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T4.tStop = t  # not accounting for scr refresh
            text_SRT1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T4, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T4.setAutoDraw(False)
    
    # *phases_SRT1T4* updates
    if phases_SRT1T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T4.frameNStart = frameN  # exact frame index
        phases_SRT1T4.tStart = t  # local t and not account for scr refresh
        phases_SRT1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T4, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T4.setAutoDraw(True)
    if phases_SRT1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T4.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T4.tStop = t  # not accounting for scr refresh
            phases_SRT1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T4, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T4.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T4Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T4"-------
for thisComponent in SoundRecognitionT1T4Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thth5.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth5.started', sound_thth5.tStartRefresh)
thisExp.addData('sound_thth5.stopped', sound_thth5.tStopRefresh)
sound_thth6.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth6.started', sound_thth6.tStartRefresh)
thisExp.addData('sound_thth6.stopped', sound_thth6.tStopRefresh)
# check responses
if key_SRT1T4.keys in ['', [], None]:  # No response was made
    key_SRT1T4.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT1T4.corr = 1;  # correct non-response
    else:
       key_SRT1T4.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T4.keys',key_SRT1T4.keys)
thisExp.addData('key_SRT1T4.corr', key_SRT1T4.corr)
if key_SRT1T4.keys != None:  # we had a response
    thisExp.addData('key_SRT1T4.rt', key_SRT1T4.rt)
thisExp.addData('key_SRT1T4.started', key_SRT1T4.tStartRefresh)
thisExp.addData('key_SRT1T4.stopped', key_SRT1T4.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T4.started', text_SRT1T4.tStartRefresh)
thisExp.addData('text_SRT1T4.stopped', text_SRT1T4.tStopRefresh)
thisExp.addData('phases_SRT1T4.started', phases_SRT1T4.tStartRefresh)
thisExp.addData('phases_SRT1T4.stopped', phases_SRT1T4.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T5"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_th2.setSound('Sounds/th.wav', hamming=True)
sound_th2.setVolume(1, log=False)
sound_thth7.setSound('Sounds/thth.wav', hamming=True)
sound_thth7.setVolume(1, log=False)
key_SRT1T5.keys = []
key_SRT1T5.rt = []
_key_SRT1T5_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T5Components = [sound_th2, sound_thth7, key_SRT1T5, text_SRT1T5, phases_SRT1T5]
for thisComponent in SoundRecognitionT1T5Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T5"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T5Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T5Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_th2
    if sound_th2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_th2.frameNStart = frameN  # exact frame index
        sound_th2.tStart = t  # local t and not account for scr refresh
        sound_th2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th2.play(when=win)  # sync with win flip
    if sound_th2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th2.tStop = t  # not accounting for scr refresh
            sound_th2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th2, 'tStopRefresh')  # time at next scr refresh
            sound_th2.stop()
    # start/stop sound_thth7
    if sound_thth7.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_thth7.frameNStart = frameN  # exact frame index
        sound_thth7.tStart = t  # local t and not account for scr refresh
        sound_thth7.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth7.play(when=win)  # sync with win flip
    if sound_thth7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth7.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth7.tStop = t  # not accounting for scr refresh
            sound_thth7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth7, 'tStopRefresh')  # time at next scr refresh
            sound_thth7.stop()
    
    # *key_SRT1T5* updates
    waitOnFlip = False
    if key_SRT1T5.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T5.frameNStart = frameN  # exact frame index
        key_SRT1T5.tStart = t  # local t and not account for scr refresh
        key_SRT1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T5, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T5.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T5.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T5.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T5.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T5.tStop = t  # not accounting for scr refresh
            key_SRT1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T5, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T5.status = FINISHED
    if key_SRT1T5.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T5.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T5_allKeys.extend(theseKeys)
        if len(_key_SRT1T5_allKeys):
            key_SRT1T5.keys = _key_SRT1T5_allKeys[-1].name  # just the last key pressed
            key_SRT1T5.rt = _key_SRT1T5_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T5.keys == str('0')) or (key_SRT1T5.keys == '0'):
                key_SRT1T5.corr = 1
            else:
                key_SRT1T5.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T5* updates
    if text_SRT1T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T5.frameNStart = frameN  # exact frame index
        text_SRT1T5.tStart = t  # local t and not account for scr refresh
        text_SRT1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T5, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T5.setAutoDraw(True)
    if text_SRT1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T5.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T5.tStop = t  # not accounting for scr refresh
            text_SRT1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T5, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T5.setAutoDraw(False)
    
    # *phases_SRT1T5* updates
    if phases_SRT1T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T5.frameNStart = frameN  # exact frame index
        phases_SRT1T5.tStart = t  # local t and not account for scr refresh
        phases_SRT1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T5, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T5.setAutoDraw(True)
    if phases_SRT1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T5.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T5.tStop = t  # not accounting for scr refresh
            phases_SRT1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T5, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T5.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T5Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T5"-------
for thisComponent in SoundRecognitionT1T5Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_th2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th2.started', sound_th2.tStartRefresh)
thisExp.addData('sound_th2.stopped', sound_th2.tStopRefresh)
sound_thth7.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth7.started', sound_thth7.tStartRefresh)
thisExp.addData('sound_thth7.stopped', sound_thth7.tStopRefresh)
# check responses
if key_SRT1T5.keys in ['', [], None]:  # No response was made
    key_SRT1T5.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT1T5.corr = 1;  # correct non-response
    else:
       key_SRT1T5.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T5.keys',key_SRT1T5.keys)
thisExp.addData('key_SRT1T5.corr', key_SRT1T5.corr)
if key_SRT1T5.keys != None:  # we had a response
    thisExp.addData('key_SRT1T5.rt', key_SRT1T5.rt)
thisExp.addData('key_SRT1T5.started', key_SRT1T5.tStartRefresh)
thisExp.addData('key_SRT1T5.stopped', key_SRT1T5.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T5.started', text_SRT1T5.tStartRefresh)
thisExp.addData('text_SRT1T5.stopped', text_SRT1T5.tStopRefresh)
thisExp.addData('phases_SRT1T5.started', phases_SRT1T5.tStartRefresh)
thisExp.addData('phases_SRT1T5.stopped', phases_SRT1T5.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T6"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_th4.setSound('Sounds/th.wav', hamming=True)
sound_th4.setVolume(1, log=False)
sound_th3.setSound('Sounds/th.wav', hamming=True)
sound_th3.setVolume(1, log=False)
key_SRT1T6.keys = []
key_SRT1T6.rt = []
_key_SRT1T6_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T6Components = [sound_th4, sound_th3, key_SRT1T6, text_SRT1T6, phases_SRT1T6]
for thisComponent in SoundRecognitionT1T6Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T6"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T6Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T6Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_th4
    if sound_th4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_th4.frameNStart = frameN  # exact frame index
        sound_th4.tStart = t  # local t and not account for scr refresh
        sound_th4.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th4.play(when=win)  # sync with win flip
    if sound_th4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th4.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th4.tStop = t  # not accounting for scr refresh
            sound_th4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th4, 'tStopRefresh')  # time at next scr refresh
            sound_th4.stop()
    # start/stop sound_th3
    if sound_th3.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_th3.frameNStart = frameN  # exact frame index
        sound_th3.tStart = t  # local t and not account for scr refresh
        sound_th3.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th3.play(when=win)  # sync with win flip
    if sound_th3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th3.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th3.tStop = t  # not accounting for scr refresh
            sound_th3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th3, 'tStopRefresh')  # time at next scr refresh
            sound_th3.stop()
    
    # *key_SRT1T6* updates
    waitOnFlip = False
    if key_SRT1T6.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T6.frameNStart = frameN  # exact frame index
        key_SRT1T6.tStart = t  # local t and not account for scr refresh
        key_SRT1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T6, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T6.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T6.tStop = t  # not accounting for scr refresh
            key_SRT1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T6, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T6.status = FINISHED
    if key_SRT1T6.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T6.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T6_allKeys.extend(theseKeys)
        if len(_key_SRT1T6_allKeys):
            key_SRT1T6.keys = _key_SRT1T6_allKeys[-1].name  # just the last key pressed
            key_SRT1T6.rt = _key_SRT1T6_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T6.keys == str('1')) or (key_SRT1T6.keys == '1'):
                key_SRT1T6.corr = 1
            else:
                key_SRT1T6.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T6* updates
    if text_SRT1T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T6.frameNStart = frameN  # exact frame index
        text_SRT1T6.tStart = t  # local t and not account for scr refresh
        text_SRT1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T6, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T6.setAutoDraw(True)
    if text_SRT1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T6.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T6.tStop = t  # not accounting for scr refresh
            text_SRT1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T6, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T6.setAutoDraw(False)
    
    # *phases_SRT1T6* updates
    if phases_SRT1T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T6.frameNStart = frameN  # exact frame index
        phases_SRT1T6.tStart = t  # local t and not account for scr refresh
        phases_SRT1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T6, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T6.setAutoDraw(True)
    if phases_SRT1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T6.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T6.tStop = t  # not accounting for scr refresh
            phases_SRT1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T6, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T6.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T6Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T6"-------
for thisComponent in SoundRecognitionT1T6Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_th4.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th4.started', sound_th4.tStartRefresh)
thisExp.addData('sound_th4.stopped', sound_th4.tStopRefresh)
sound_th3.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th3.started', sound_th3.tStartRefresh)
thisExp.addData('sound_th3.stopped', sound_th3.tStopRefresh)
# check responses
if key_SRT1T6.keys in ['', [], None]:  # No response was made
    key_SRT1T6.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT1T6.corr = 1;  # correct non-response
    else:
       key_SRT1T6.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T6.keys',key_SRT1T6.keys)
thisExp.addData('key_SRT1T6.corr', key_SRT1T6.corr)
if key_SRT1T6.keys != None:  # we had a response
    thisExp.addData('key_SRT1T6.rt', key_SRT1T6.rt)
thisExp.addData('key_SRT1T6.started', key_SRT1T6.tStartRefresh)
thisExp.addData('key_SRT1T6.stopped', key_SRT1T6.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T6.started', text_SRT1T6.tStartRefresh)
thisExp.addData('text_SRT1T6.stopped', text_SRT1T6.tStopRefresh)
thisExp.addData('phases_SRT1T6.started', phases_SRT1T6.tStartRefresh)
thisExp.addData('phases_SRT1T6.stopped', phases_SRT1T6.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T7"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_th5.setSound('Sounds/th.wav', hamming=True)
sound_th5.setVolume(1, log=False)
sound_sh8.setSound('Sounds/sh.wav', hamming=True)
sound_sh8.setVolume(1, log=False)
key_SRT1T7.keys = []
key_SRT1T7.rt = []
_key_SRT1T7_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T7Components = [sound_th5, sound_sh8, key_SRT1T7, text_SRT1T7, phases_SRT1T7]
for thisComponent in SoundRecognitionT1T7Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T7"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T7Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T7Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_th5
    if sound_th5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_th5.frameNStart = frameN  # exact frame index
        sound_th5.tStart = t  # local t and not account for scr refresh
        sound_th5.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th5.play(when=win)  # sync with win flip
    if sound_th5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th5.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th5.tStop = t  # not accounting for scr refresh
            sound_th5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th5, 'tStopRefresh')  # time at next scr refresh
            sound_th5.stop()
    # start/stop sound_sh8
    if sound_sh8.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_sh8.frameNStart = frameN  # exact frame index
        sound_sh8.tStart = t  # local t and not account for scr refresh
        sound_sh8.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh8.play(when=win)  # sync with win flip
    if sound_sh8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh8.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh8.tStop = t  # not accounting for scr refresh
            sound_sh8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh8, 'tStopRefresh')  # time at next scr refresh
            sound_sh8.stop()
    
    # *key_SRT1T7* updates
    waitOnFlip = False
    if key_SRT1T7.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T7.frameNStart = frameN  # exact frame index
        key_SRT1T7.tStart = t  # local t and not account for scr refresh
        key_SRT1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T7, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T7.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T7.tStop = t  # not accounting for scr refresh
            key_SRT1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T7, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T7.status = FINISHED
    if key_SRT1T7.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T7.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T7_allKeys.extend(theseKeys)
        if len(_key_SRT1T7_allKeys):
            key_SRT1T7.keys = _key_SRT1T7_allKeys[-1].name  # just the last key pressed
            key_SRT1T7.rt = _key_SRT1T7_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T7.keys == str('1')) or (key_SRT1T7.keys == '1'):
                key_SRT1T7.corr = 1
            else:
                key_SRT1T7.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T7* updates
    if text_SRT1T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T7.frameNStart = frameN  # exact frame index
        text_SRT1T7.tStart = t  # local t and not account for scr refresh
        text_SRT1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T7, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T7.setAutoDraw(True)
    if text_SRT1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T7.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T7.tStop = t  # not accounting for scr refresh
            text_SRT1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T7, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T7.setAutoDraw(False)
    
    # *phases_SRT1T7* updates
    if phases_SRT1T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T7.frameNStart = frameN  # exact frame index
        phases_SRT1T7.tStart = t  # local t and not account for scr refresh
        phases_SRT1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T7, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T7.setAutoDraw(True)
    if phases_SRT1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T7.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T7.tStop = t  # not accounting for scr refresh
            phases_SRT1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T7, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T7.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T7Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T7"-------
for thisComponent in SoundRecognitionT1T7Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_th5.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th5.started', sound_th5.tStartRefresh)
thisExp.addData('sound_th5.stopped', sound_th5.tStopRefresh)
sound_sh8.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh8.started', sound_sh8.tStartRefresh)
thisExp.addData('sound_sh8.stopped', sound_sh8.tStopRefresh)
# check responses
if key_SRT1T7.keys in ['', [], None]:  # No response was made
    key_SRT1T7.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT1T7.corr = 1;  # correct non-response
    else:
       key_SRT1T7.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T7.keys',key_SRT1T7.keys)
thisExp.addData('key_SRT1T7.corr', key_SRT1T7.corr)
if key_SRT1T7.keys != None:  # we had a response
    thisExp.addData('key_SRT1T7.rt', key_SRT1T7.rt)
thisExp.addData('key_SRT1T7.started', key_SRT1T7.tStartRefresh)
thisExp.addData('key_SRT1T7.stopped', key_SRT1T7.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T7.started', text_SRT1T7.tStartRefresh)
thisExp.addData('text_SRT1T7.stopped', text_SRT1T7.tStopRefresh)
thisExp.addData('phases_SRT1T7.started', phases_SRT1T7.tStartRefresh)
thisExp.addData('phases_SRT1T7.stopped', phases_SRT1T7.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T8"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_th7.setSound('Sounds/th.wav', hamming=True)
sound_th7.setVolume(1, log=False)
sound_th8.setSound('Sounds/th.wav', hamming=True)
sound_th8.setVolume(1, log=False)
key_SRT1T8.keys = []
key_SRT1T8.rt = []
_key_SRT1T8_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T8Components = [sound_th7, sound_th8, key_SRT1T8, text_SRT1T8, phases_SRT1T8]
for thisComponent in SoundRecognitionT1T8Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T8"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T8Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T8Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_th7
    if sound_th7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_th7.frameNStart = frameN  # exact frame index
        sound_th7.tStart = t  # local t and not account for scr refresh
        sound_th7.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th7.play(when=win)  # sync with win flip
    if sound_th7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th7.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th7.tStop = t  # not accounting for scr refresh
            sound_th7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th7, 'tStopRefresh')  # time at next scr refresh
            sound_th7.stop()
    # start/stop sound_th8
    if sound_th8.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_th8.frameNStart = frameN  # exact frame index
        sound_th8.tStart = t  # local t and not account for scr refresh
        sound_th8.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th8.play(when=win)  # sync with win flip
    if sound_th8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th8.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th8.tStop = t  # not accounting for scr refresh
            sound_th8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th8, 'tStopRefresh')  # time at next scr refresh
            sound_th8.stop()
    
    # *key_SRT1T8* updates
    waitOnFlip = False
    if key_SRT1T8.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T8.frameNStart = frameN  # exact frame index
        key_SRT1T8.tStart = t  # local t and not account for scr refresh
        key_SRT1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T8, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T8.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T8.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T8.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T8.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T8.tStop = t  # not accounting for scr refresh
            key_SRT1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T8, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T8.status = FINISHED
    if key_SRT1T8.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T8.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T8_allKeys.extend(theseKeys)
        if len(_key_SRT1T8_allKeys):
            key_SRT1T8.keys = _key_SRT1T8_allKeys[-1].name  # just the last key pressed
            key_SRT1T8.rt = _key_SRT1T8_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T8.keys == str('1')) or (key_SRT1T8.keys == '1'):
                key_SRT1T8.corr = 1
            else:
                key_SRT1T8.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T8* updates
    if text_SRT1T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T8.frameNStart = frameN  # exact frame index
        text_SRT1T8.tStart = t  # local t and not account for scr refresh
        text_SRT1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T8, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T8.setAutoDraw(True)
    if text_SRT1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T8.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T8.tStop = t  # not accounting for scr refresh
            text_SRT1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T8, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T8.setAutoDraw(False)
    
    # *phases_SRT1T8* updates
    if phases_SRT1T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T8.frameNStart = frameN  # exact frame index
        phases_SRT1T8.tStart = t  # local t and not account for scr refresh
        phases_SRT1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T8, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T8.setAutoDraw(True)
    if phases_SRT1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T8.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T8.tStop = t  # not accounting for scr refresh
            phases_SRT1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T8, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T8.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T8Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T8"-------
for thisComponent in SoundRecognitionT1T8Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_th7.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th7.started', sound_th7.tStartRefresh)
thisExp.addData('sound_th7.stopped', sound_th7.tStopRefresh)
sound_th8.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th8.started', sound_th8.tStartRefresh)
thisExp.addData('sound_th8.stopped', sound_th8.tStopRefresh)
# check responses
if key_SRT1T8.keys in ['', [], None]:  # No response was made
    key_SRT1T8.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT1T8.corr = 1;  # correct non-response
    else:
       key_SRT1T8.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T8.keys',key_SRT1T8.keys)
thisExp.addData('key_SRT1T8.corr', key_SRT1T8.corr)
if key_SRT1T8.keys != None:  # we had a response
    thisExp.addData('key_SRT1T8.rt', key_SRT1T8.rt)
thisExp.addData('key_SRT1T8.started', key_SRT1T8.tStartRefresh)
thisExp.addData('key_SRT1T8.stopped', key_SRT1T8.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T8.started', text_SRT1T8.tStartRefresh)
thisExp.addData('text_SRT1T8.stopped', text_SRT1T8.tStopRefresh)
thisExp.addData('phases_SRT1T8.started', phases_SRT1T8.tStartRefresh)
thisExp.addData('phases_SRT1T8.stopped', phases_SRT1T8.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T9"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_sh2.setSound('Sounds/sh.wav', hamming=True)
sound_sh2.setVolume(1, log=False)
sound_thth8.setSound('Sounds/thth.wav', hamming=True)
sound_thth8.setVolume(1, log=False)
key_SRT1T9.keys = []
key_SRT1T9.rt = []
_key_SRT1T9_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T9Components = [sound_sh2, sound_thth8, key_SRT1T9, text_SRT1T9, phases_SRT1T9]
for thisComponent in SoundRecognitionT1T9Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T9"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T9Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T9Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_sh2
    if sound_sh2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_sh2.frameNStart = frameN  # exact frame index
        sound_sh2.tStart = t  # local t and not account for scr refresh
        sound_sh2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh2.play(when=win)  # sync with win flip
    if sound_sh2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh2.tStop = t  # not accounting for scr refresh
            sound_sh2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh2, 'tStopRefresh')  # time at next scr refresh
            sound_sh2.stop()
    # start/stop sound_thth8
    if sound_thth8.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_thth8.frameNStart = frameN  # exact frame index
        sound_thth8.tStart = t  # local t and not account for scr refresh
        sound_thth8.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth8.play(when=win)  # sync with win flip
    if sound_thth8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth8.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth8.tStop = t  # not accounting for scr refresh
            sound_thth8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth8, 'tStopRefresh')  # time at next scr refresh
            sound_thth8.stop()
    
    # *key_SRT1T9* updates
    waitOnFlip = False
    if key_SRT1T9.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T9.frameNStart = frameN  # exact frame index
        key_SRT1T9.tStart = t  # local t and not account for scr refresh
        key_SRT1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T9, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T9.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T9.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T9.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T9.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T9.tStop = t  # not accounting for scr refresh
            key_SRT1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T9, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T9.status = FINISHED
    if key_SRT1T9.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T9.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T9_allKeys.extend(theseKeys)
        if len(_key_SRT1T9_allKeys):
            key_SRT1T9.keys = _key_SRT1T9_allKeys[-1].name  # just the last key pressed
            key_SRT1T9.rt = _key_SRT1T9_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T9.keys == str('0')) or (key_SRT1T9.keys == '0'):
                key_SRT1T9.corr = 1
            else:
                key_SRT1T9.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T9* updates
    if text_SRT1T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T9.frameNStart = frameN  # exact frame index
        text_SRT1T9.tStart = t  # local t and not account for scr refresh
        text_SRT1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T9, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T9.setAutoDraw(True)
    if text_SRT1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T9.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T9.tStop = t  # not accounting for scr refresh
            text_SRT1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T9, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T9.setAutoDraw(False)
    
    # *phases_SRT1T9* updates
    if phases_SRT1T9.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T9.frameNStart = frameN  # exact frame index
        phases_SRT1T9.tStart = t  # local t and not account for scr refresh
        phases_SRT1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T9, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T9.setAutoDraw(True)
    if phases_SRT1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T9.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T9.tStop = t  # not accounting for scr refresh
            phases_SRT1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T9, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T9.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T9Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T9"-------
for thisComponent in SoundRecognitionT1T9Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_sh2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh2.started', sound_sh2.tStartRefresh)
thisExp.addData('sound_sh2.stopped', sound_sh2.tStopRefresh)
sound_thth8.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth8.started', sound_thth8.tStartRefresh)
thisExp.addData('sound_thth8.stopped', sound_thth8.tStopRefresh)
# check responses
if key_SRT1T9.keys in ['', [], None]:  # No response was made
    key_SRT1T9.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT1T9.corr = 1;  # correct non-response
    else:
       key_SRT1T9.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T9.keys',key_SRT1T9.keys)
thisExp.addData('key_SRT1T9.corr', key_SRT1T9.corr)
if key_SRT1T9.keys != None:  # we had a response
    thisExp.addData('key_SRT1T9.rt', key_SRT1T9.rt)
thisExp.addData('key_SRT1T9.started', key_SRT1T9.tStartRefresh)
thisExp.addData('key_SRT1T9.stopped', key_SRT1T9.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T9.started', text_SRT1T9.tStartRefresh)
thisExp.addData('text_SRT1T9.stopped', text_SRT1T9.tStopRefresh)
thisExp.addData('phases_SRT1T9.started', phases_SRT1T9.tStartRefresh)
thisExp.addData('phases_SRT1T9.stopped', phases_SRT1T9.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T10"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_sh3.setSound('Sounds/sh.wav', hamming=True)
sound_sh3.setVolume(1, log=False)
sound_th9.setSound('Sounds/th.wav', hamming=True)
sound_th9.setVolume(1, log=False)
key_SRT1T10.keys = []
key_SRT1T10.rt = []
_key_SRT1T10_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T10Components = [sound_sh3, sound_th9, key_SRT1T10, text_SRT1T10, phases_SRT1T10]
for thisComponent in SoundRecognitionT1T10Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T10"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T10Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T10Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_sh3
    if sound_sh3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_sh3.frameNStart = frameN  # exact frame index
        sound_sh3.tStart = t  # local t and not account for scr refresh
        sound_sh3.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh3.play(when=win)  # sync with win flip
    if sound_sh3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh3.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh3.tStop = t  # not accounting for scr refresh
            sound_sh3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh3, 'tStopRefresh')  # time at next scr refresh
            sound_sh3.stop()
    # start/stop sound_th9
    if sound_th9.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_th9.frameNStart = frameN  # exact frame index
        sound_th9.tStart = t  # local t and not account for scr refresh
        sound_th9.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th9.play(when=win)  # sync with win flip
    if sound_th9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th9.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th9.tStop = t  # not accounting for scr refresh
            sound_th9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th9, 'tStopRefresh')  # time at next scr refresh
            sound_th9.stop()
    
    # *key_SRT1T10* updates
    waitOnFlip = False
    if key_SRT1T10.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T10.frameNStart = frameN  # exact frame index
        key_SRT1T10.tStart = t  # local t and not account for scr refresh
        key_SRT1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T10, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T10.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T10.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T10.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T10.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T10.tStop = t  # not accounting for scr refresh
            key_SRT1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T10, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T10.status = FINISHED
    if key_SRT1T10.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T10.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T10_allKeys.extend(theseKeys)
        if len(_key_SRT1T10_allKeys):
            key_SRT1T10.keys = _key_SRT1T10_allKeys[-1].name  # just the last key pressed
            key_SRT1T10.rt = _key_SRT1T10_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T10.keys == str('0')) or (key_SRT1T10.keys == '0'):
                key_SRT1T10.corr = 1
            else:
                key_SRT1T10.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T10* updates
    if text_SRT1T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T10.frameNStart = frameN  # exact frame index
        text_SRT1T10.tStart = t  # local t and not account for scr refresh
        text_SRT1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T10, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T10.setAutoDraw(True)
    if text_SRT1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T10.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T10.tStop = t  # not accounting for scr refresh
            text_SRT1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T10, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T10.setAutoDraw(False)
    
    # *phases_SRT1T10* updates
    if phases_SRT1T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T10.frameNStart = frameN  # exact frame index
        phases_SRT1T10.tStart = t  # local t and not account for scr refresh
        phases_SRT1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T10, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T10.setAutoDraw(True)
    if phases_SRT1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T10.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T10.tStop = t  # not accounting for scr refresh
            phases_SRT1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T10, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T10.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T10Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T10"-------
for thisComponent in SoundRecognitionT1T10Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_sh3.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh3.started', sound_sh3.tStartRefresh)
thisExp.addData('sound_sh3.stopped', sound_sh3.tStopRefresh)
sound_th9.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th9.started', sound_th9.tStartRefresh)
thisExp.addData('sound_th9.stopped', sound_th9.tStopRefresh)
# check responses
if key_SRT1T10.keys in ['', [], None]:  # No response was made
    key_SRT1T10.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT1T10.corr = 1;  # correct non-response
    else:
       key_SRT1T10.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T10.keys',key_SRT1T10.keys)
thisExp.addData('key_SRT1T10.corr', key_SRT1T10.corr)
if key_SRT1T10.keys != None:  # we had a response
    thisExp.addData('key_SRT1T10.rt', key_SRT1T10.rt)
thisExp.addData('key_SRT1T10.started', key_SRT1T10.tStartRefresh)
thisExp.addData('key_SRT1T10.stopped', key_SRT1T10.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T10.started', text_SRT1T10.tStartRefresh)
thisExp.addData('text_SRT1T10.stopped', text_SRT1T10.tStopRefresh)
thisExp.addData('phases_SRT1T10.started', phases_SRT1T10.tStartRefresh)
thisExp.addData('phases_SRT1T10.stopped', phases_SRT1T10.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T11"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_sh4.setSound('Sounds/sh.wav', hamming=True)
sound_sh4.setVolume(1, log=False)
sound_sh5.setSound('Sounds/sh.wav', hamming=True)
sound_sh5.setVolume(1, log=False)
key_SRT1T11.keys = []
key_SRT1T11.rt = []
_key_SRT1T11_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T11Components = [sound_sh4, sound_sh5, key_SRT1T11, text_SRT1T11, phases_SRT1T11]
for thisComponent in SoundRecognitionT1T11Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T11"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T11Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T11Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_sh4
    if sound_sh4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_sh4.frameNStart = frameN  # exact frame index
        sound_sh4.tStart = t  # local t and not account for scr refresh
        sound_sh4.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh4.play(when=win)  # sync with win flip
    if sound_sh4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh4.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh4.tStop = t  # not accounting for scr refresh
            sound_sh4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh4, 'tStopRefresh')  # time at next scr refresh
            sound_sh4.stop()
    # start/stop sound_sh5
    if sound_sh5.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_sh5.frameNStart = frameN  # exact frame index
        sound_sh5.tStart = t  # local t and not account for scr refresh
        sound_sh5.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh5.play(when=win)  # sync with win flip
    if sound_sh5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh5.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh5.tStop = t  # not accounting for scr refresh
            sound_sh5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh5, 'tStopRefresh')  # time at next scr refresh
            sound_sh5.stop()
    
    # *key_SRT1T11* updates
    waitOnFlip = False
    if key_SRT1T11.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T11.frameNStart = frameN  # exact frame index
        key_SRT1T11.tStart = t  # local t and not account for scr refresh
        key_SRT1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T11, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T11.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T11.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T11.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T11.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T11.tStop = t  # not accounting for scr refresh
            key_SRT1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T11, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T11.status = FINISHED
    if key_SRT1T11.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T11.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T11_allKeys.extend(theseKeys)
        if len(_key_SRT1T11_allKeys):
            key_SRT1T11.keys = _key_SRT1T11_allKeys[-1].name  # just the last key pressed
            key_SRT1T11.rt = _key_SRT1T11_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T11.keys == str('1')) or (key_SRT1T11.keys == '1'):
                key_SRT1T11.corr = 1
            else:
                key_SRT1T11.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T11* updates
    if text_SRT1T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T11.frameNStart = frameN  # exact frame index
        text_SRT1T11.tStart = t  # local t and not account for scr refresh
        text_SRT1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T11, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T11.setAutoDraw(True)
    if text_SRT1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T11.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T11.tStop = t  # not accounting for scr refresh
            text_SRT1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T11, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T11.setAutoDraw(False)
    
    # *phases_SRT1T11* updates
    if phases_SRT1T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T11.frameNStart = frameN  # exact frame index
        phases_SRT1T11.tStart = t  # local t and not account for scr refresh
        phases_SRT1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T11, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T11.setAutoDraw(True)
    if phases_SRT1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T11.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T11.tStop = t  # not accounting for scr refresh
            phases_SRT1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T11, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T11.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T11Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T11"-------
for thisComponent in SoundRecognitionT1T11Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_sh4.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh4.started', sound_sh4.tStartRefresh)
thisExp.addData('sound_sh4.stopped', sound_sh4.tStopRefresh)
sound_sh5.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh5.started', sound_sh5.tStartRefresh)
thisExp.addData('sound_sh5.stopped', sound_sh5.tStopRefresh)
# check responses
if key_SRT1T11.keys in ['', [], None]:  # No response was made
    key_SRT1T11.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT1T11.corr = 1;  # correct non-response
    else:
       key_SRT1T11.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T11.keys',key_SRT1T11.keys)
thisExp.addData('key_SRT1T11.corr', key_SRT1T11.corr)
if key_SRT1T11.keys != None:  # we had a response
    thisExp.addData('key_SRT1T11.rt', key_SRT1T11.rt)
thisExp.addData('key_SRT1T11.started', key_SRT1T11.tStartRefresh)
thisExp.addData('key_SRT1T11.stopped', key_SRT1T11.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T11.started', text_SRT1T11.tStartRefresh)
thisExp.addData('text_SRT1T11.stopped', text_SRT1T11.tStopRefresh)
thisExp.addData('phases_SRT1T11.started', phases_SRT1T11.tStartRefresh)
thisExp.addData('phases_SRT1T11.stopped', phases_SRT1T11.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT1T12"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_sh6.setSound('Sounds/sh.wav', hamming=True)
sound_sh6.setVolume(1, log=False)
sound_sh7.setSound('Sounds/sh.wav', hamming=True)
sound_sh7.setVolume(1, log=False)
key_SRT1T12.keys = []
key_SRT1T12.rt = []
_key_SRT1T12_allKeys = []
# keep track of which components have finished
SoundRecognitionT1T12Components = [sound_sh6, sound_sh7, key_SRT1T12, text_SRT1T12, phases_SRT1T12]
for thisComponent in SoundRecognitionT1T12Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT1T12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT1T12"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT1T12Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT1T12Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_sh6
    if sound_sh6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_sh6.frameNStart = frameN  # exact frame index
        sound_sh6.tStart = t  # local t and not account for scr refresh
        sound_sh6.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh6.play(when=win)  # sync with win flip
    if sound_sh6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh6.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh6.tStop = t  # not accounting for scr refresh
            sound_sh6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh6, 'tStopRefresh')  # time at next scr refresh
            sound_sh6.stop()
    # start/stop sound_sh7
    if sound_sh7.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_sh7.frameNStart = frameN  # exact frame index
        sound_sh7.tStart = t  # local t and not account for scr refresh
        sound_sh7.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh7.play(when=win)  # sync with win flip
    if sound_sh7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh7.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh7.tStop = t  # not accounting for scr refresh
            sound_sh7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh7, 'tStopRefresh')  # time at next scr refresh
            sound_sh7.stop()
    
    # *key_SRT1T12* updates
    waitOnFlip = False
    if key_SRT1T12.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_SRT1T12.frameNStart = frameN  # exact frame index
        key_SRT1T12.tStart = t  # local t and not account for scr refresh
        key_SRT1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT1T12, 'tStartRefresh')  # time at next scr refresh
        key_SRT1T12.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT1T12.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT1T12.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT1T12.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT1T12.tStop = t  # not accounting for scr refresh
            key_SRT1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT1T12, 'tStopRefresh')  # time at next scr refresh
            key_SRT1T12.status = FINISHED
    if key_SRT1T12.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT1T12.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT1T12_allKeys.extend(theseKeys)
        if len(_key_SRT1T12_allKeys):
            key_SRT1T12.keys = _key_SRT1T12_allKeys[-1].name  # just the last key pressed
            key_SRT1T12.rt = _key_SRT1T12_allKeys[-1].rt
            # was this correct?
            if (key_SRT1T12.keys == str('1')) or (key_SRT1T12.keys == '1'):
                key_SRT1T12.corr = 1
            else:
                key_SRT1T12.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT1T12* updates
    if text_SRT1T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT1T12.frameNStart = frameN  # exact frame index
        text_SRT1T12.tStart = t  # local t and not account for scr refresh
        text_SRT1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT1T12, 'tStartRefresh')  # time at next scr refresh
        text_SRT1T12.setAutoDraw(True)
    if text_SRT1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT1T12.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT1T12.tStop = t  # not accounting for scr refresh
            text_SRT1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT1T12, 'tStopRefresh')  # time at next scr refresh
            text_SRT1T12.setAutoDraw(False)
    
    # *phases_SRT1T12* updates
    if phases_SRT1T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT1T12.frameNStart = frameN  # exact frame index
        phases_SRT1T12.tStart = t  # local t and not account for scr refresh
        phases_SRT1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT1T12, 'tStartRefresh')  # time at next scr refresh
        phases_SRT1T12.setAutoDraw(True)
    if phases_SRT1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT1T12.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT1T12.tStop = t  # not accounting for scr refresh
            phases_SRT1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT1T12, 'tStopRefresh')  # time at next scr refresh
            phases_SRT1T12.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT1T12Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT1T12"-------
for thisComponent in SoundRecognitionT1T12Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_sh6.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh6.started', sound_sh6.tStartRefresh)
thisExp.addData('sound_sh6.stopped', sound_sh6.tStopRefresh)
sound_sh7.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh7.started', sound_sh7.tStartRefresh)
thisExp.addData('sound_sh7.stopped', sound_sh7.tStopRefresh)
# check responses
if key_SRT1T12.keys in ['', [], None]:  # No response was made
    key_SRT1T12.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT1T12.corr = 1;  # correct non-response
    else:
       key_SRT1T12.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT1T12.keys',key_SRT1T12.keys)
thisExp.addData('key_SRT1T12.corr', key_SRT1T12.corr)
if key_SRT1T12.keys != None:  # we had a response
    thisExp.addData('key_SRT1T12.rt', key_SRT1T12.rt)
thisExp.addData('key_SRT1T12.started', key_SRT1T12.tStartRefresh)
thisExp.addData('key_SRT1T12.stopped', key_SRT1T12.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT1T12.started', text_SRT1T12.tStartRefresh)
thisExp.addData('text_SRT1T12.stopped', text_SRT1T12.tStopRefresh)
thisExp.addData('phases_SRT1T12.started', phases_SRT1T12.tStartRefresh)
thisExp.addData('phases_SRT1T12.stopped', phases_SRT1T12.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase1instructions2"-------
continueRoutine = True
# update component parameters for each repeat
key_phase1_inst2.keys = []
key_phase1_inst2.rt = []
_key_phase1_inst2_allKeys = []
# keep track of which components have finished
Phase1instructions2Components = [text_phase1_inst2, key_phase1_inst2]
for thisComponent in Phase1instructions2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase1instructions2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase1instructions2"-------
while continueRoutine:
    # get current time
    t = Phase1instructions2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase1instructions2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_phase1_inst2* updates
    if text_phase1_inst2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_phase1_inst2.frameNStart = frameN  # exact frame index
        text_phase1_inst2.tStart = t  # local t and not account for scr refresh
        text_phase1_inst2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_phase1_inst2, 'tStartRefresh')  # time at next scr refresh
        text_phase1_inst2.setAutoDraw(True)
    
    # *key_phase1_inst2* updates
    waitOnFlip = False
    if key_phase1_inst2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_phase1_inst2.frameNStart = frameN  # exact frame index
        key_phase1_inst2.tStart = t  # local t and not account for scr refresh
        key_phase1_inst2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_phase1_inst2, 'tStartRefresh')  # time at next scr refresh
        key_phase1_inst2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_phase1_inst2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_phase1_inst2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_phase1_inst2.status == STARTED and not waitOnFlip:
        theseKeys = key_phase1_inst2.getKeys(keyList=['space'], waitRelease=False)
        _key_phase1_inst2_allKeys.extend(theseKeys)
        if len(_key_phase1_inst2_allKeys):
            key_phase1_inst2.keys = _key_phase1_inst2_allKeys[-1].name  # just the last key pressed
            key_phase1_inst2.rt = _key_phase1_inst2_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase1instructions2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase1instructions2"-------
for thisComponent in Phase1instructions2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_phase1_inst2.started', text_phase1_inst2.tStartRefresh)
thisExp.addData('text_phase1_inst2.stopped', text_phase1_inst2.tStopRefresh)
# check responses
if key_phase1_inst2.keys in ['', [], None]:  # No response was made
    key_phase1_inst2.keys = None
thisExp.addData('key_phase1_inst2.keys',key_phase1_inst2.keys)
if key_phase1_inst2.keys != None:  # we had a response
    thisExp.addData('key_phase1_inst2.rt', key_phase1_inst2.rt)
thisExp.addData('key_phase1_inst2.started', key_phase1_inst2.tStartRefresh)
thisExp.addData('key_phase1_inst2.stopped', key_phase1_inst2.tStopRefresh)
thisExp.nextEntry()
# the Routine "Phase1instructions2" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "SoundRecognitionT2T1"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_thrwa_thrwa.setSound('Sounds/thrwa-thrwa.wav', hamming=True)
sound_thrwa_thrwa.setVolume(1, log=False)
key_SRT2T1.keys = []
key_SRT2T1.rt = []
_key_SRT2T1_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T1Components = [sound_thrwa_thrwa, key_SRT2T1, text_SRT2T1, phases_SRT2T1]
for thisComponent in SoundRecognitionT2T1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T1"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thrwa_thrwa
    if sound_thrwa_thrwa.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thrwa_thrwa.frameNStart = frameN  # exact frame index
        sound_thrwa_thrwa.tStart = t  # local t and not account for scr refresh
        sound_thrwa_thrwa.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thrwa_thrwa.play(when=win)  # sync with win flip
    if sound_thrwa_thrwa.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thrwa_thrwa.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thrwa_thrwa.tStop = t  # not accounting for scr refresh
            sound_thrwa_thrwa.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thrwa_thrwa, 'tStopRefresh')  # time at next scr refresh
            sound_thrwa_thrwa.stop()
    
    # *key_SRT2T1* updates
    waitOnFlip = False
    if key_SRT2T1.status == NOT_STARTED and tThisFlip >= 04.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T1.frameNStart = frameN  # exact frame index
        key_SRT2T1.tStart = t  # local t and not account for scr refresh
        key_SRT2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T1, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T1.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T1.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T1.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T1.tStop = t  # not accounting for scr refresh
            key_SRT2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T1, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T1.status = FINISHED
    if key_SRT2T1.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T1.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T1_allKeys.extend(theseKeys)
        if len(_key_SRT2T1_allKeys):
            key_SRT2T1.keys = _key_SRT2T1_allKeys[-1].name  # just the last key pressed
            key_SRT2T1.rt = _key_SRT2T1_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T1.keys == str('1')) or (key_SRT2T1.keys == '1'):
                key_SRT2T1.corr = 1
            else:
                key_SRT2T1.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T1* updates
    if text_SRT2T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T1.frameNStart = frameN  # exact frame index
        text_SRT2T1.tStart = t  # local t and not account for scr refresh
        text_SRT2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T1, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T1.setAutoDraw(True)
    if text_SRT2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T1.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T1.tStop = t  # not accounting for scr refresh
            text_SRT2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T1, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T1.setAutoDraw(False)
    
    # *phases_SRT2T1* updates
    if phases_SRT2T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T1.frameNStart = frameN  # exact frame index
        phases_SRT2T1.tStart = t  # local t and not account for scr refresh
        phases_SRT2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T1, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T1.setAutoDraw(True)
    if phases_SRT2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T1.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T1.tStop = t  # not accounting for scr refresh
            phases_SRT2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T1, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T1.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T1"-------
for thisComponent in SoundRecognitionT2T1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thrwa_thrwa.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thrwa_thrwa.started', sound_thrwa_thrwa.tStartRefresh)
thisExp.addData('sound_thrwa_thrwa.stopped', sound_thrwa_thrwa.tStopRefresh)
# check responses
if key_SRT2T1.keys in ['', [], None]:  # No response was made
    key_SRT2T1.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT2T1.corr = 1;  # correct non-response
    else:
       key_SRT2T1.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T1.keys',key_SRT2T1.keys)
thisExp.addData('key_SRT2T1.corr', key_SRT2T1.corr)
if key_SRT2T1.keys != None:  # we had a response
    thisExp.addData('key_SRT2T1.rt', key_SRT2T1.rt)
thisExp.addData('key_SRT2T1.started', key_SRT2T1.tStartRefresh)
thisExp.addData('key_SRT2T1.stopped', key_SRT2T1.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T1.started', text_SRT2T1.tStartRefresh)
thisExp.addData('text_SRT2T1.stopped', text_SRT2T1.tStopRefresh)
thisExp.addData('phases_SRT2T1.started', phases_SRT2T1.tStartRefresh)
thisExp.addData('phases_SRT2T1.stopped', phases_SRT2T1.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T2"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_ththm_thm.setSound('Sounds/ththm-thm.wav', hamming=True)
sound_ththm_thm.setVolume(1, log=False)
key_SRT2T2.keys = []
key_SRT2T2.rt = []
_key_SRT2T2_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T2Components = [sound_ththm_thm, key_SRT2T2, text_SRT2T2, phases_SRT2T2]
for thisComponent in SoundRecognitionT2T2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T2"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththm_thm
    if sound_ththm_thm.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththm_thm.frameNStart = frameN  # exact frame index
        sound_ththm_thm.tStart = t  # local t and not account for scr refresh
        sound_ththm_thm.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththm_thm.play(when=win)  # sync with win flip
    if sound_ththm_thm.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththm_thm.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththm_thm.tStop = t  # not accounting for scr refresh
            sound_ththm_thm.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththm_thm, 'tStopRefresh')  # time at next scr refresh
            sound_ththm_thm.stop()
    
    # *key_SRT2T2* updates
    waitOnFlip = False
    if key_SRT2T2.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T2.frameNStart = frameN  # exact frame index
        key_SRT2T2.tStart = t  # local t and not account for scr refresh
        key_SRT2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T2, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T2.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T2.tStop = t  # not accounting for scr refresh
            key_SRT2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T2, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T2.status = FINISHED
    if key_SRT2T2.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T2.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T2_allKeys.extend(theseKeys)
        if len(_key_SRT2T2_allKeys):
            key_SRT2T2.keys = _key_SRT2T2_allKeys[-1].name  # just the last key pressed
            key_SRT2T2.rt = _key_SRT2T2_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T2.keys == str('0')) or (key_SRT2T2.keys == '0'):
                key_SRT2T2.corr = 1
            else:
                key_SRT2T2.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T2* updates
    if text_SRT2T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T2.frameNStart = frameN  # exact frame index
        text_SRT2T2.tStart = t  # local t and not account for scr refresh
        text_SRT2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T2, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T2.setAutoDraw(True)
    if text_SRT2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T2.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T2.tStop = t  # not accounting for scr refresh
            text_SRT2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T2, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T2.setAutoDraw(False)
    
    # *phases_SRT2T2* updates
    if phases_SRT2T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T2.frameNStart = frameN  # exact frame index
        phases_SRT2T2.tStart = t  # local t and not account for scr refresh
        phases_SRT2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T2, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T2.setAutoDraw(True)
    if phases_SRT2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T2.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T2.tStop = t  # not accounting for scr refresh
            phases_SRT2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T2, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T2.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T2"-------
for thisComponent in SoundRecognitionT2T2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththm_thm.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththm_thm.started', sound_ththm_thm.tStartRefresh)
thisExp.addData('sound_ththm_thm.stopped', sound_ththm_thm.tStopRefresh)
# check responses
if key_SRT2T2.keys in ['', [], None]:  # No response was made
    key_SRT2T2.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT2T2.corr = 1;  # correct non-response
    else:
       key_SRT2T2.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T2.keys',key_SRT2T2.keys)
thisExp.addData('key_SRT2T2.corr', key_SRT2T2.corr)
if key_SRT2T2.keys != None:  # we had a response
    thisExp.addData('key_SRT2T2.rt', key_SRT2T2.rt)
thisExp.addData('key_SRT2T2.started', key_SRT2T2.tStartRefresh)
thisExp.addData('key_SRT2T2.stopped', key_SRT2T2.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T2.started', text_SRT2T2.tStartRefresh)
thisExp.addData('text_SRT2T2.stopped', text_SRT2T2.tStopRefresh)
thisExp.addData('phases_SRT2T2.started', phases_SRT2T2.tStartRefresh)
thisExp.addData('phases_SRT2T2.stopped', phases_SRT2T2.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T3"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_ththab_shab.setSound('Sounds/ththab-shab.wav', hamming=True)
sound_ththab_shab.setVolume(1, log=False)
key_SRT2T3.keys = []
key_SRT2T3.rt = []
_key_SRT2T3_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T3Components = [sound_ththab_shab, key_SRT2T3, text_SRT2T3, phases_SRT2T3]
for thisComponent in SoundRecognitionT2T3Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T3"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T3Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T3Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththab_shab
    if sound_ththab_shab.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththab_shab.frameNStart = frameN  # exact frame index
        sound_ththab_shab.tStart = t  # local t and not account for scr refresh
        sound_ththab_shab.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththab_shab.play(when=win)  # sync with win flip
    if sound_ththab_shab.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththab_shab.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththab_shab.tStop = t  # not accounting for scr refresh
            sound_ththab_shab.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththab_shab, 'tStopRefresh')  # time at next scr refresh
            sound_ththab_shab.stop()
    
    # *key_SRT2T3* updates
    waitOnFlip = False
    if key_SRT2T3.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T3.frameNStart = frameN  # exact frame index
        key_SRT2T3.tStart = t  # local t and not account for scr refresh
        key_SRT2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T3, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T3.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T3.tStop = t  # not accounting for scr refresh
            key_SRT2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T3, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T3.status = FINISHED
    if key_SRT2T3.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T3.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T3_allKeys.extend(theseKeys)
        if len(_key_SRT2T3_allKeys):
            key_SRT2T3.keys = _key_SRT2T3_allKeys[-1].name  # just the last key pressed
            key_SRT2T3.rt = _key_SRT2T3_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T3.keys == str('0')) or (key_SRT2T3.keys == '0'):
                key_SRT2T3.corr = 1
            else:
                key_SRT2T3.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T3* updates
    if text_SRT2T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T3.frameNStart = frameN  # exact frame index
        text_SRT2T3.tStart = t  # local t and not account for scr refresh
        text_SRT2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T3, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T3.setAutoDraw(True)
    if text_SRT2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T3.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T3.tStop = t  # not accounting for scr refresh
            text_SRT2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T3, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T3.setAutoDraw(False)
    
    # *phases_SRT2T3* updates
    if phases_SRT2T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T3.frameNStart = frameN  # exact frame index
        phases_SRT2T3.tStart = t  # local t and not account for scr refresh
        phases_SRT2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T3, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T3.setAutoDraw(True)
    if phases_SRT2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T3.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T3.tStop = t  # not accounting for scr refresh
            phases_SRT2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T3, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T3.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T3Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T3"-------
for thisComponent in SoundRecognitionT2T3Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththab_shab.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththab_shab.started', sound_ththab_shab.tStartRefresh)
thisExp.addData('sound_ththab_shab.stopped', sound_ththab_shab.tStopRefresh)
# check responses
if key_SRT2T3.keys in ['', [], None]:  # No response was made
    key_SRT2T3.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT2T3.corr = 1;  # correct non-response
    else:
       key_SRT2T3.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T3.keys',key_SRT2T3.keys)
thisExp.addData('key_SRT2T3.corr', key_SRT2T3.corr)
if key_SRT2T3.keys != None:  # we had a response
    thisExp.addData('key_SRT2T3.rt', key_SRT2T3.rt)
thisExp.addData('key_SRT2T3.started', key_SRT2T3.tStartRefresh)
thisExp.addData('key_SRT2T3.stopped', key_SRT2T3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T3.started', text_SRT2T3.tStartRefresh)
thisExp.addData('text_SRT2T3.stopped', text_SRT2T3.tStopRefresh)
thisExp.addData('phases_SRT2T3.started', phases_SRT2T3.tStartRefresh)
thisExp.addData('phases_SRT2T3.stopped', phases_SRT2T3.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T4"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_ththna_ththna.setSound('Sounds/ththna-ththna.wav', hamming=True)
sound_ththna_ththna.setVolume(1, log=False)
key_SRT2T4.keys = []
key_SRT2T4.rt = []
_key_SRT2T4_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T4Components = [sound_ththna_ththna, key_SRT2T4, text_SRT2T4, phases_SRT2T4]
for thisComponent in SoundRecognitionT2T4Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T4"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T4Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T4Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththna_ththna
    if sound_ththna_ththna.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththna_ththna.frameNStart = frameN  # exact frame index
        sound_ththna_ththna.tStart = t  # local t and not account for scr refresh
        sound_ththna_ththna.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththna_ththna.play(when=win)  # sync with win flip
    if sound_ththna_ththna.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththna_ththna.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththna_ththna.tStop = t  # not accounting for scr refresh
            sound_ththna_ththna.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththna_ththna, 'tStopRefresh')  # time at next scr refresh
            sound_ththna_ththna.stop()
    
    # *key_SRT2T4* updates
    waitOnFlip = False
    if key_SRT2T4.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T4.frameNStart = frameN  # exact frame index
        key_SRT2T4.tStart = t  # local t and not account for scr refresh
        key_SRT2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T4, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T4.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T4.tStop = t  # not accounting for scr refresh
            key_SRT2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T4, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T4.status = FINISHED
    if key_SRT2T4.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T4.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T4_allKeys.extend(theseKeys)
        if len(_key_SRT2T4_allKeys):
            key_SRT2T4.keys = _key_SRT2T4_allKeys[-1].name  # just the last key pressed
            key_SRT2T4.rt = _key_SRT2T4_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T4.keys == str('1')) or (key_SRT2T4.keys == '1'):
                key_SRT2T4.corr = 1
            else:
                key_SRT2T4.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T4* updates
    if text_SRT2T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T4.frameNStart = frameN  # exact frame index
        text_SRT2T4.tStart = t  # local t and not account for scr refresh
        text_SRT2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T4, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T4.setAutoDraw(True)
    if text_SRT2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T4.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T4.tStop = t  # not accounting for scr refresh
            text_SRT2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T4, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T4.setAutoDraw(False)
    
    # *phases_SRT2T4* updates
    if phases_SRT2T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T4.frameNStart = frameN  # exact frame index
        phases_SRT2T4.tStart = t  # local t and not account for scr refresh
        phases_SRT2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T4, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T4.setAutoDraw(True)
    if phases_SRT2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T4.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T4.tStop = t  # not accounting for scr refresh
            phases_SRT2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T4, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T4.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T4Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T4"-------
for thisComponent in SoundRecognitionT2T4Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththna_ththna.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththna_ththna.started', sound_ththna_ththna.tStartRefresh)
thisExp.addData('sound_ththna_ththna.stopped', sound_ththna_ththna.tStopRefresh)
# check responses
if key_SRT2T4.keys in ['', [], None]:  # No response was made
    key_SRT2T4.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT2T4.corr = 1;  # correct non-response
    else:
       key_SRT2T4.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T4.keys',key_SRT2T4.keys)
thisExp.addData('key_SRT2T4.corr', key_SRT2T4.corr)
if key_SRT2T4.keys != None:  # we had a response
    thisExp.addData('key_SRT2T4.rt', key_SRT2T4.rt)
thisExp.addData('key_SRT2T4.started', key_SRT2T4.tStartRefresh)
thisExp.addData('key_SRT2T4.stopped', key_SRT2T4.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T4.started', text_SRT2T4.tStartRefresh)
thisExp.addData('text_SRT2T4.stopped', text_SRT2T4.tStopRefresh)
thisExp.addData('phases_SRT2T4.started', phases_SRT2T4.tStartRefresh)
thisExp.addData('phases_SRT2T4.stopped', phases_SRT2T4.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T5"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_thra_ththra.setSound('Sounds/thra-ththra.wav', hamming=True)
sound_thra_ththra.setVolume(1, log=False)
key_SRT2T5.keys = []
key_SRT2T5.rt = []
_key_SRT2T5_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T5Components = [sound_thra_ththra, key_SRT2T5, text_SRT2T5, phases_SRT2T5]
for thisComponent in SoundRecognitionT2T5Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T5"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T5Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T5Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thra_ththra
    if sound_thra_ththra.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thra_ththra.frameNStart = frameN  # exact frame index
        sound_thra_ththra.tStart = t  # local t and not account for scr refresh
        sound_thra_ththra.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thra_ththra.play(when=win)  # sync with win flip
    if sound_thra_ththra.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thra_ththra.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thra_ththra.tStop = t  # not accounting for scr refresh
            sound_thra_ththra.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thra_ththra, 'tStopRefresh')  # time at next scr refresh
            sound_thra_ththra.stop()
    
    # *key_SRT2T5* updates
    waitOnFlip = False
    if key_SRT2T5.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T5.frameNStart = frameN  # exact frame index
        key_SRT2T5.tStart = t  # local t and not account for scr refresh
        key_SRT2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T5, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T5.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T5.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T5.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T5.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T5.tStop = t  # not accounting for scr refresh
            key_SRT2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T5, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T5.status = FINISHED
    if key_SRT2T5.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T5.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T5_allKeys.extend(theseKeys)
        if len(_key_SRT2T5_allKeys):
            key_SRT2T5.keys = _key_SRT2T5_allKeys[-1].name  # just the last key pressed
            key_SRT2T5.rt = _key_SRT2T5_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T5.keys == str('0')) or (key_SRT2T5.keys == '0'):
                key_SRT2T5.corr = 1
            else:
                key_SRT2T5.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T5* updates
    if text_SRT2T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T5.frameNStart = frameN  # exact frame index
        text_SRT2T5.tStart = t  # local t and not account for scr refresh
        text_SRT2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T5, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T5.setAutoDraw(True)
    if text_SRT2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T5.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T5.tStop = t  # not accounting for scr refresh
            text_SRT2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T5, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T5.setAutoDraw(False)
    
    # *phases_SRT2T5* updates
    if phases_SRT2T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T5.frameNStart = frameN  # exact frame index
        phases_SRT2T5.tStart = t  # local t and not account for scr refresh
        phases_SRT2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T5, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T5.setAutoDraw(True)
    if phases_SRT2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T5.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T5.tStop = t  # not accounting for scr refresh
            phases_SRT2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T5, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T5.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T5Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T5"-------
for thisComponent in SoundRecognitionT2T5Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thra_ththra.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thra_ththra.started', sound_thra_ththra.tStartRefresh)
thisExp.addData('sound_thra_ththra.stopped', sound_thra_ththra.tStopRefresh)
# check responses
if key_SRT2T5.keys in ['', [], None]:  # No response was made
    key_SRT2T5.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT2T5.corr = 1;  # correct non-response
    else:
       key_SRT2T5.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T5.keys',key_SRT2T5.keys)
thisExp.addData('key_SRT2T5.corr', key_SRT2T5.corr)
if key_SRT2T5.keys != None:  # we had a response
    thisExp.addData('key_SRT2T5.rt', key_SRT2T5.rt)
thisExp.addData('key_SRT2T5.started', key_SRT2T5.tStartRefresh)
thisExp.addData('key_SRT2T5.stopped', key_SRT2T5.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T5.started', text_SRT2T5.tStartRefresh)
thisExp.addData('text_SRT2T5.stopped', text_SRT2T5.tStopRefresh)
thisExp.addData('phases_SRT2T5.started', phases_SRT2T5.tStartRefresh)
thisExp.addData('phases_SRT2T5.stopped', phases_SRT2T5.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T6"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_thb7_shb7.setSound('Sounds/thb7-shb7.wav', hamming=True)
sound_thb7_shb7.setVolume(1, log=False)
key_SRT2T6.keys = []
key_SRT2T6.rt = []
_key_SRT2T6_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T6Components = [sound_thb7_shb7, key_SRT2T6, text_SRT2T6, phases_SRT2T6]
for thisComponent in SoundRecognitionT2T6Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T6"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T6Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T6Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thb7_shb7
    if sound_thb7_shb7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thb7_shb7.frameNStart = frameN  # exact frame index
        sound_thb7_shb7.tStart = t  # local t and not account for scr refresh
        sound_thb7_shb7.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thb7_shb7.play(when=win)  # sync with win flip
    if sound_thb7_shb7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thb7_shb7.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thb7_shb7.tStop = t  # not accounting for scr refresh
            sound_thb7_shb7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thb7_shb7, 'tStopRefresh')  # time at next scr refresh
            sound_thb7_shb7.stop()
    
    # *key_SRT2T6* updates
    waitOnFlip = False
    if key_SRT2T6.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T6.frameNStart = frameN  # exact frame index
        key_SRT2T6.tStart = t  # local t and not account for scr refresh
        key_SRT2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T6, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T6.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T6.tStop = t  # not accounting for scr refresh
            key_SRT2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T6, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T6.status = FINISHED
    if key_SRT2T6.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T6.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T6_allKeys.extend(theseKeys)
        if len(_key_SRT2T6_allKeys):
            key_SRT2T6.keys = _key_SRT2T6_allKeys[-1].name  # just the last key pressed
            key_SRT2T6.rt = _key_SRT2T6_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T6.keys == str('0')) or (key_SRT2T6.keys == '0'):
                key_SRT2T6.corr = 1
            else:
                key_SRT2T6.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T6* updates
    if text_SRT2T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T6.frameNStart = frameN  # exact frame index
        text_SRT2T6.tStart = t  # local t and not account for scr refresh
        text_SRT2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T6, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T6.setAutoDraw(True)
    if text_SRT2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T6.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T6.tStop = t  # not accounting for scr refresh
            text_SRT2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T6, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T6.setAutoDraw(False)
    
    # *phases_SRT2T6* updates
    if phases_SRT2T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T6.frameNStart = frameN  # exact frame index
        phases_SRT2T6.tStart = t  # local t and not account for scr refresh
        phases_SRT2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T6, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T6.setAutoDraw(True)
    if phases_SRT2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T6.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T6.tStop = t  # not accounting for scr refresh
            phases_SRT2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T6, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T6.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T6Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T6"-------
for thisComponent in SoundRecognitionT2T6Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thb7_shb7.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thb7_shb7.started', sound_thb7_shb7.tStartRefresh)
thisExp.addData('sound_thb7_shb7.stopped', sound_thb7_shb7.tStopRefresh)
# check responses
if key_SRT2T6.keys in ['', [], None]:  # No response was made
    key_SRT2T6.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT2T6.corr = 1;  # correct non-response
    else:
       key_SRT2T6.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T6.keys',key_SRT2T6.keys)
thisExp.addData('key_SRT2T6.corr', key_SRT2T6.corr)
if key_SRT2T6.keys != None:  # we had a response
    thisExp.addData('key_SRT2T6.rt', key_SRT2T6.rt)
thisExp.addData('key_SRT2T6.started', key_SRT2T6.tStartRefresh)
thisExp.addData('key_SRT2T6.stopped', key_SRT2T6.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T6.started', text_SRT2T6.tStartRefresh)
thisExp.addData('text_SRT2T6.stopped', text_SRT2T6.tStopRefresh)
thisExp.addData('phases_SRT2T6.started', phases_SRT2T6.tStartRefresh)
thisExp.addData('phases_SRT2T6.stopped', phases_SRT2T6.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T7"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_thwq_thwq.setSound('Sounds/thwq-thwq.wav', hamming=True)
sound_thwq_thwq.setVolume(1, log=False)
key_SRT2T7.keys = []
key_SRT2T7.rt = []
_key_SRT2T7_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T7Components = [sound_thwq_thwq, key_SRT2T7, text_SRT2T7, phases_SRT2T7]
for thisComponent in SoundRecognitionT2T7Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T7"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T7Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T7Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thwq_thwq
    if sound_thwq_thwq.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thwq_thwq.frameNStart = frameN  # exact frame index
        sound_thwq_thwq.tStart = t  # local t and not account for scr refresh
        sound_thwq_thwq.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thwq_thwq.play(when=win)  # sync with win flip
    if sound_thwq_thwq.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thwq_thwq.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thwq_thwq.tStop = t  # not accounting for scr refresh
            sound_thwq_thwq.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thwq_thwq, 'tStopRefresh')  # time at next scr refresh
            sound_thwq_thwq.stop()
    
    # *key_SRT2T7* updates
    waitOnFlip = False
    if key_SRT2T7.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T7.frameNStart = frameN  # exact frame index
        key_SRT2T7.tStart = t  # local t and not account for scr refresh
        key_SRT2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T7, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T7.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T7.tStop = t  # not accounting for scr refresh
            key_SRT2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T7, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T7.status = FINISHED
    if key_SRT2T7.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T7.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T7_allKeys.extend(theseKeys)
        if len(_key_SRT2T7_allKeys):
            key_SRT2T7.keys = _key_SRT2T7_allKeys[-1].name  # just the last key pressed
            key_SRT2T7.rt = _key_SRT2T7_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T7.keys == str('1')) or (key_SRT2T7.keys == '1'):
                key_SRT2T7.corr = 1
            else:
                key_SRT2T7.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T7* updates
    if text_SRT2T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T7.frameNStart = frameN  # exact frame index
        text_SRT2T7.tStart = t  # local t and not account for scr refresh
        text_SRT2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T7, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T7.setAutoDraw(True)
    if text_SRT2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T7.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T7.tStop = t  # not accounting for scr refresh
            text_SRT2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T7, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T7.setAutoDraw(False)
    
    # *phases_SRT2T7* updates
    if phases_SRT2T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T7.frameNStart = frameN  # exact frame index
        phases_SRT2T7.tStart = t  # local t and not account for scr refresh
        phases_SRT2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T7, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T7.setAutoDraw(True)
    if phases_SRT2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T7.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T7.tStop = t  # not accounting for scr refresh
            phases_SRT2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T7, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T7.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T7Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T7"-------
for thisComponent in SoundRecognitionT2T7Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thwq_thwq.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thwq_thwq.started', sound_thwq_thwq.tStartRefresh)
thisExp.addData('sound_thwq_thwq.stopped', sound_thwq_thwq.tStopRefresh)
# check responses
if key_SRT2T7.keys in ['', [], None]:  # No response was made
    key_SRT2T7.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT2T7.corr = 1;  # correct non-response
    else:
       key_SRT2T7.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T7.keys',key_SRT2T7.keys)
thisExp.addData('key_SRT2T7.corr', key_SRT2T7.corr)
if key_SRT2T7.keys != None:  # we had a response
    thisExp.addData('key_SRT2T7.rt', key_SRT2T7.rt)
thisExp.addData('key_SRT2T7.started', key_SRT2T7.tStartRefresh)
thisExp.addData('key_SRT2T7.stopped', key_SRT2T7.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T7.started', text_SRT2T7.tStartRefresh)
thisExp.addData('text_SRT2T7.stopped', text_SRT2T7.tStopRefresh)
thisExp.addData('phases_SRT2T7.started', phases_SRT2T7.tStartRefresh)
thisExp.addData('phases_SRT2T7.stopped', phases_SRT2T7.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T8"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_thail_thail.setSound('Sounds/thail-thail.wav', hamming=True)
sound_thail_thail.setVolume(1, log=False)
key_SRT2T8.keys = []
key_SRT2T8.rt = []
_key_SRT2T8_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T8Components = [sound_thail_thail, key_SRT2T8, text_SRT2T8, phases_SRT2T8]
for thisComponent in SoundRecognitionT2T8Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T8"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T8Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T8Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thail_thail
    if sound_thail_thail.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thail_thail.frameNStart = frameN  # exact frame index
        sound_thail_thail.tStart = t  # local t and not account for scr refresh
        sound_thail_thail.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thail_thail.play(when=win)  # sync with win flip
    if sound_thail_thail.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thail_thail.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thail_thail.tStop = t  # not accounting for scr refresh
            sound_thail_thail.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thail_thail, 'tStopRefresh')  # time at next scr refresh
            sound_thail_thail.stop()
    
    # *key_SRT2T8* updates
    waitOnFlip = False
    if key_SRT2T8.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T8.frameNStart = frameN  # exact frame index
        key_SRT2T8.tStart = t  # local t and not account for scr refresh
        key_SRT2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T8, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T8.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T8.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T8.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T8.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T8.tStop = t  # not accounting for scr refresh
            key_SRT2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T8, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T8.status = FINISHED
    if key_SRT2T8.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T8.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T8_allKeys.extend(theseKeys)
        if len(_key_SRT2T8_allKeys):
            key_SRT2T8.keys = _key_SRT2T8_allKeys[-1].name  # just the last key pressed
            key_SRT2T8.rt = _key_SRT2T8_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T8.keys == str('1')) or (key_SRT2T8.keys == '1'):
                key_SRT2T8.corr = 1
            else:
                key_SRT2T8.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T8* updates
    if text_SRT2T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T8.frameNStart = frameN  # exact frame index
        text_SRT2T8.tStart = t  # local t and not account for scr refresh
        text_SRT2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T8, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T8.setAutoDraw(True)
    if text_SRT2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T8.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T8.tStop = t  # not accounting for scr refresh
            text_SRT2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T8, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T8.setAutoDraw(False)
    
    # *phases_SRT2T8* updates
    if phases_SRT2T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T8.frameNStart = frameN  # exact frame index
        phases_SRT2T8.tStart = t  # local t and not account for scr refresh
        phases_SRT2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T8, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T8.setAutoDraw(True)
    if phases_SRT2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T8.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T8.tStop = t  # not accounting for scr refresh
            phases_SRT2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T8, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T8.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T8Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T8"-------
for thisComponent in SoundRecognitionT2T8Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thail_thail.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thail_thail.started', sound_thail_thail.tStartRefresh)
thisExp.addData('sound_thail_thail.stopped', sound_thail_thail.tStopRefresh)
# check responses
if key_SRT2T8.keys in ['', [], None]:  # No response was made
    key_SRT2T8.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT2T8.corr = 1;  # correct non-response
    else:
       key_SRT2T8.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T8.keys',key_SRT2T8.keys)
thisExp.addData('key_SRT2T8.corr', key_SRT2T8.corr)
if key_SRT2T8.keys != None:  # we had a response
    thisExp.addData('key_SRT2T8.rt', key_SRT2T8.rt)
thisExp.addData('key_SRT2T8.started', key_SRT2T8.tStartRefresh)
thisExp.addData('key_SRT2T8.stopped', key_SRT2T8.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T8.started', text_SRT2T8.tStartRefresh)
thisExp.addData('text_SRT2T8.stopped', text_SRT2T8.tStopRefresh)
thisExp.addData('phases_SRT2T8.started', phases_SRT2T8.tStartRefresh)
thisExp.addData('phases_SRT2T8.stopped', phases_SRT2T8.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T9"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_shrf_thrf.setSound('Sounds/shrf-thrf.wav', hamming=True)
sound_shrf_thrf.setVolume(1, log=False)
key_SRT2T9.keys = []
key_SRT2T9.rt = []
_key_SRT2T9_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T9Components = [sound_shrf_thrf, key_SRT2T9, text_SRT2T9, phases_SRT2T9]
for thisComponent in SoundRecognitionT2T9Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T9"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T9Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T9Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_shrf_thrf
    if sound_shrf_thrf.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_shrf_thrf.frameNStart = frameN  # exact frame index
        sound_shrf_thrf.tStart = t  # local t and not account for scr refresh
        sound_shrf_thrf.tStartRefresh = tThisFlipGlobal  # on global time
        sound_shrf_thrf.play(when=win)  # sync with win flip
    if sound_shrf_thrf.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_shrf_thrf.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_shrf_thrf.tStop = t  # not accounting for scr refresh
            sound_shrf_thrf.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_shrf_thrf, 'tStopRefresh')  # time at next scr refresh
            sound_shrf_thrf.stop()
    
    # *key_SRT2T9* updates
    waitOnFlip = False
    if key_SRT2T9.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T9.frameNStart = frameN  # exact frame index
        key_SRT2T9.tStart = t  # local t and not account for scr refresh
        key_SRT2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T9, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T9.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T9.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T9.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T9.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T9.tStop = t  # not accounting for scr refresh
            key_SRT2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T9, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T9.status = FINISHED
    if key_SRT2T9.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T9.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T9_allKeys.extend(theseKeys)
        if len(_key_SRT2T9_allKeys):
            key_SRT2T9.keys = _key_SRT2T9_allKeys[-1].name  # just the last key pressed
            key_SRT2T9.rt = _key_SRT2T9_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T9.keys == str('0')) or (key_SRT2T9.keys == '0'):
                key_SRT2T9.corr = 1
            else:
                key_SRT2T9.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T9* updates
    if text_SRT2T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T9.frameNStart = frameN  # exact frame index
        text_SRT2T9.tStart = t  # local t and not account for scr refresh
        text_SRT2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T9, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T9.setAutoDraw(True)
    if text_SRT2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T9.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T9.tStop = t  # not accounting for scr refresh
            text_SRT2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T9, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T9.setAutoDraw(False)
    
    # *phases_SRT2T9* updates
    if phases_SRT2T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T9.frameNStart = frameN  # exact frame index
        phases_SRT2T9.tStart = t  # local t and not account for scr refresh
        phases_SRT2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T9, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T9.setAutoDraw(True)
    if phases_SRT2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T9.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T9.tStop = t  # not accounting for scr refresh
            phases_SRT2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T9, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T9.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T9Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T9"-------
for thisComponent in SoundRecognitionT2T9Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_shrf_thrf.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_shrf_thrf.started', sound_shrf_thrf.tStartRefresh)
thisExp.addData('sound_shrf_thrf.stopped', sound_shrf_thrf.tStopRefresh)
# check responses
if key_SRT2T9.keys in ['', [], None]:  # No response was made
    key_SRT2T9.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT2T9.corr = 1;  # correct non-response
    else:
       key_SRT2T9.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T9.keys',key_SRT2T9.keys)
thisExp.addData('key_SRT2T9.corr', key_SRT2T9.corr)
if key_SRT2T9.keys != None:  # we had a response
    thisExp.addData('key_SRT2T9.rt', key_SRT2T9.rt)
thisExp.addData('key_SRT2T9.started', key_SRT2T9.tStartRefresh)
thisExp.addData('key_SRT2T9.stopped', key_SRT2T9.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T9.started', text_SRT2T9.tStartRefresh)
thisExp.addData('text_SRT2T9.stopped', text_SRT2T9.tStopRefresh)
thisExp.addData('phases_SRT2T9.started', phases_SRT2T9.tStartRefresh)
thisExp.addData('phases_SRT2T9.stopped', phases_SRT2T9.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T10"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_sh7m_sh7m.setSound('Sounds/sh7m-sh7m.wav', hamming=True)
sound_sh7m_sh7m.setVolume(1, log=False)
key_SRT2T10.keys = []
key_SRT2T10.rt = []
_key_SRT2T10_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T10Components = [sound_sh7m_sh7m, key_SRT2T10, text_SRT2T10, phases_SRT2T10]
for thisComponent in SoundRecognitionT2T10Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T10"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T10Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T10Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_sh7m_sh7m
    if sound_sh7m_sh7m.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_sh7m_sh7m.frameNStart = frameN  # exact frame index
        sound_sh7m_sh7m.tStart = t  # local t and not account for scr refresh
        sound_sh7m_sh7m.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh7m_sh7m.play(when=win)  # sync with win flip
    if sound_sh7m_sh7m.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh7m_sh7m.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh7m_sh7m.tStop = t  # not accounting for scr refresh
            sound_sh7m_sh7m.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh7m_sh7m, 'tStopRefresh')  # time at next scr refresh
            sound_sh7m_sh7m.stop()
    
    # *key_SRT2T10* updates
    waitOnFlip = False
    if key_SRT2T10.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T10.frameNStart = frameN  # exact frame index
        key_SRT2T10.tStart = t  # local t and not account for scr refresh
        key_SRT2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T10, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T10.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T10.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T10.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T10.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T10.tStop = t  # not accounting for scr refresh
            key_SRT2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T10, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T10.status = FINISHED
    if key_SRT2T10.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T10.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T10_allKeys.extend(theseKeys)
        if len(_key_SRT2T10_allKeys):
            key_SRT2T10.keys = _key_SRT2T10_allKeys[-1].name  # just the last key pressed
            key_SRT2T10.rt = _key_SRT2T10_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T10.keys == str('1')) or (key_SRT2T10.keys == '1'):
                key_SRT2T10.corr = 1
            else:
                key_SRT2T10.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T10* updates
    if text_SRT2T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T10.frameNStart = frameN  # exact frame index
        text_SRT2T10.tStart = t  # local t and not account for scr refresh
        text_SRT2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T10, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T10.setAutoDraw(True)
    if text_SRT2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T10.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T10.tStop = t  # not accounting for scr refresh
            text_SRT2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T10, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T10.setAutoDraw(False)
    
    # *phases_SRT2T10* updates
    if phases_SRT2T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T10.frameNStart = frameN  # exact frame index
        phases_SRT2T10.tStart = t  # local t and not account for scr refresh
        phases_SRT2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T10, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T10.setAutoDraw(True)
    if phases_SRT2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T10.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T10.tStop = t  # not accounting for scr refresh
            phases_SRT2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T10, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T10.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T10Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T10"-------
for thisComponent in SoundRecognitionT2T10Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_sh7m_sh7m.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh7m_sh7m.started', sound_sh7m_sh7m.tStartRefresh)
thisExp.addData('sound_sh7m_sh7m.stopped', sound_sh7m_sh7m.tStopRefresh)
# check responses
if key_SRT2T10.keys in ['', [], None]:  # No response was made
    key_SRT2T10.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT2T10.corr = 1;  # correct non-response
    else:
       key_SRT2T10.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T10.keys',key_SRT2T10.keys)
thisExp.addData('key_SRT2T10.corr', key_SRT2T10.corr)
if key_SRT2T10.keys != None:  # we had a response
    thisExp.addData('key_SRT2T10.rt', key_SRT2T10.rt)
thisExp.addData('key_SRT2T10.started', key_SRT2T10.tStartRefresh)
thisExp.addData('key_SRT2T10.stopped', key_SRT2T10.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T10.started', text_SRT2T10.tStartRefresh)
thisExp.addData('text_SRT2T10.stopped', text_SRT2T10.tStopRefresh)
thisExp.addData('phases_SRT2T10.started', phases_SRT2T10.tStartRefresh)
thisExp.addData('phases_SRT2T10.stopped', phases_SRT2T10.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T11"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_shra_ththra.setSound('Sounds/shra-ththra.wav', hamming=True)
sound_shra_ththra.setVolume(1, log=False)
key_SRT2T11.keys = []
key_SRT2T11.rt = []
_key_SRT2T11_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T11Components = [sound_shra_ththra, key_SRT2T11, text_SRT2T11, phases_SRT2T11]
for thisComponent in SoundRecognitionT2T11Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T11"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T11Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T11Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_shra_ththra
    if sound_shra_ththra.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_shra_ththra.frameNStart = frameN  # exact frame index
        sound_shra_ththra.tStart = t  # local t and not account for scr refresh
        sound_shra_ththra.tStartRefresh = tThisFlipGlobal  # on global time
        sound_shra_ththra.play(when=win)  # sync with win flip
    if sound_shra_ththra.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_shra_ththra.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_shra_ththra.tStop = t  # not accounting for scr refresh
            sound_shra_ththra.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_shra_ththra, 'tStopRefresh')  # time at next scr refresh
            sound_shra_ththra.stop()
    
    # *key_SRT2T11* updates
    waitOnFlip = False
    if key_SRT2T11.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T11.frameNStart = frameN  # exact frame index
        key_SRT2T11.tStart = t  # local t and not account for scr refresh
        key_SRT2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T11, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T11.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T11.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T11.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T11.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T11.tStop = t  # not accounting for scr refresh
            key_SRT2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T11, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T11.status = FINISHED
    if key_SRT2T11.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T11.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T11_allKeys.extend(theseKeys)
        if len(_key_SRT2T11_allKeys):
            key_SRT2T11.keys = _key_SRT2T11_allKeys[-1].name  # just the last key pressed
            key_SRT2T11.rt = _key_SRT2T11_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T11.keys == str('0')) or (key_SRT2T11.keys == '0'):
                key_SRT2T11.corr = 1
            else:
                key_SRT2T11.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T11* updates
    if text_SRT2T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T11.frameNStart = frameN  # exact frame index
        text_SRT2T11.tStart = t  # local t and not account for scr refresh
        text_SRT2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T11, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T11.setAutoDraw(True)
    if text_SRT2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T11.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T11.tStop = t  # not accounting for scr refresh
            text_SRT2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T11, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T11.setAutoDraw(False)
    
    # *phases_SRT2T11* updates
    if phases_SRT2T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T11.frameNStart = frameN  # exact frame index
        phases_SRT2T11.tStart = t  # local t and not account for scr refresh
        phases_SRT2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T11, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T11.setAutoDraw(True)
    if phases_SRT2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T11.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T11.tStop = t  # not accounting for scr refresh
            phases_SRT2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T11, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T11.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T11Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T11"-------
for thisComponent in SoundRecognitionT2T11Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_shra_ththra.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_shra_ththra.started', sound_shra_ththra.tStartRefresh)
thisExp.addData('sound_shra_ththra.stopped', sound_shra_ththra.tStopRefresh)
# check responses
if key_SRT2T11.keys in ['', [], None]:  # No response was made
    key_SRT2T11.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_SRT2T11.corr = 1;  # correct non-response
    else:
       key_SRT2T11.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T11.keys',key_SRT2T11.keys)
thisExp.addData('key_SRT2T11.corr', key_SRT2T11.corr)
if key_SRT2T11.keys != None:  # we had a response
    thisExp.addData('key_SRT2T11.rt', key_SRT2T11.rt)
thisExp.addData('key_SRT2T11.started', key_SRT2T11.tStartRefresh)
thisExp.addData('key_SRT2T11.stopped', key_SRT2T11.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T11.started', text_SRT2T11.tStartRefresh)
thisExp.addData('text_SRT2T11.stopped', text_SRT2T11.tStopRefresh)
thisExp.addData('phases_SRT2T11.started', phases_SRT2T11.tStartRefresh)
thisExp.addData('phases_SRT2T11.stopped', phases_SRT2T11.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "SoundRecognitionT2T12"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_shfa_shfa.setSound('Sounds/shfa-shfa.wav', hamming=True)
sound_shfa_shfa.setVolume(1, log=False)
key_SRT2T12.keys = []
key_SRT2T12.rt = []
_key_SRT2T12_allKeys = []
# keep track of which components have finished
SoundRecognitionT2T12Components = [sound_shfa_shfa, key_SRT2T12, text_SRT2T12, phases_SRT2T12]
for thisComponent in SoundRecognitionT2T12Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
SoundRecognitionT2T12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "SoundRecognitionT2T12"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = SoundRecognitionT2T12Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=SoundRecognitionT2T12Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_shfa_shfa
    if sound_shfa_shfa.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_shfa_shfa.frameNStart = frameN  # exact frame index
        sound_shfa_shfa.tStart = t  # local t and not account for scr refresh
        sound_shfa_shfa.tStartRefresh = tThisFlipGlobal  # on global time
        sound_shfa_shfa.play(when=win)  # sync with win flip
    if sound_shfa_shfa.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_shfa_shfa.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_shfa_shfa.tStop = t  # not accounting for scr refresh
            sound_shfa_shfa.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_shfa_shfa, 'tStopRefresh')  # time at next scr refresh
            sound_shfa_shfa.stop()
    
    # *key_SRT2T12* updates
    waitOnFlip = False
    if key_SRT2T12.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_SRT2T12.frameNStart = frameN  # exact frame index
        key_SRT2T12.tStart = t  # local t and not account for scr refresh
        key_SRT2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRT2T12, 'tStartRefresh')  # time at next scr refresh
        key_SRT2T12.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRT2T12.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRT2T12.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRT2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_SRT2T12.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_SRT2T12.tStop = t  # not accounting for scr refresh
            key_SRT2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_SRT2T12, 'tStopRefresh')  # time at next scr refresh
            key_SRT2T12.status = FINISHED
    if key_SRT2T12.status == STARTED and not waitOnFlip:
        theseKeys = key_SRT2T12.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_SRT2T12_allKeys.extend(theseKeys)
        if len(_key_SRT2T12_allKeys):
            key_SRT2T12.keys = _key_SRT2T12_allKeys[-1].name  # just the last key pressed
            key_SRT2T12.rt = _key_SRT2T12_allKeys[-1].rt
            # was this correct?
            if (key_SRT2T12.keys == str('1')) or (key_SRT2T12.keys == '1'):
                key_SRT2T12.corr = 1
            else:
                key_SRT2T12.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_SRT2T12* updates
    if text_SRT2T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRT2T12.frameNStart = frameN  # exact frame index
        text_SRT2T12.tStart = t  # local t and not account for scr refresh
        text_SRT2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRT2T12, 'tStartRefresh')  # time at next scr refresh
        text_SRT2T12.setAutoDraw(True)
    if text_SRT2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_SRT2T12.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_SRT2T12.tStop = t  # not accounting for scr refresh
            text_SRT2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_SRT2T12, 'tStopRefresh')  # time at next scr refresh
            text_SRT2T12.setAutoDraw(False)
    
    # *phases_SRT2T12* updates
    if phases_SRT2T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_SRT2T12.frameNStart = frameN  # exact frame index
        phases_SRT2T12.tStart = t  # local t and not account for scr refresh
        phases_SRT2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_SRT2T12, 'tStartRefresh')  # time at next scr refresh
        phases_SRT2T12.setAutoDraw(True)
    if phases_SRT2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_SRT2T12.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_SRT2T12.tStop = t  # not accounting for scr refresh
            phases_SRT2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_SRT2T12, 'tStopRefresh')  # time at next scr refresh
            phases_SRT2T12.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in SoundRecognitionT2T12Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "SoundRecognitionT2T12"-------
for thisComponent in SoundRecognitionT2T12Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_shfa_shfa.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_shfa_shfa.started', sound_shfa_shfa.tStartRefresh)
thisExp.addData('sound_shfa_shfa.stopped', sound_shfa_shfa.tStopRefresh)
# check responses
if key_SRT2T12.keys in ['', [], None]:  # No response was made
    key_SRT2T12.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_SRT2T12.corr = 1;  # correct non-response
    else:
       key_SRT2T12.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_SRT2T12.keys',key_SRT2T12.keys)
thisExp.addData('key_SRT2T12.corr', key_SRT2T12.corr)
if key_SRT2T12.keys != None:  # we had a response
    thisExp.addData('key_SRT2T12.rt', key_SRT2T12.rt)
thisExp.addData('key_SRT2T12.started', key_SRT2T12.tStartRefresh)
thisExp.addData('key_SRT2T12.stopped', key_SRT2T12.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_SRT2T12.started', text_SRT2T12.tStartRefresh)
thisExp.addData('text_SRT2T12.stopped', text_SRT2T12.tStopRefresh)
thisExp.addData('phases_SRT2T12.started', phases_SRT2T12.tStartRefresh)
thisExp.addData('phases_SRT2T12.stopped', phases_SRT2T12.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "EndSoundRecognition"-------
continueRoutine = True
# update component parameters for each repeat
key_EndSR.keys = []
key_EndSR.rt = []
_key_EndSR_allKeys = []
# keep track of which components have finished
EndSoundRecognitionComponents = [text_EndSR, key_EndSR, phases_endSR]
for thisComponent in EndSoundRecognitionComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
EndSoundRecognitionClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "EndSoundRecognition"-------
while continueRoutine:
    # get current time
    t = EndSoundRecognitionClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=EndSoundRecognitionClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_EndSR* updates
    if text_EndSR.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_EndSR.frameNStart = frameN  # exact frame index
        text_EndSR.tStart = t  # local t and not account for scr refresh
        text_EndSR.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_EndSR, 'tStartRefresh')  # time at next scr refresh
        text_EndSR.setAutoDraw(True)
    
    # *key_EndSR* updates
    waitOnFlip = False
    if key_EndSR.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_EndSR.frameNStart = frameN  # exact frame index
        key_EndSR.tStart = t  # local t and not account for scr refresh
        key_EndSR.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_EndSR, 'tStartRefresh')  # time at next scr refresh
        key_EndSR.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_EndSR.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_EndSR.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_EndSR.status == STARTED and not waitOnFlip:
        theseKeys = key_EndSR.getKeys(keyList=['space'], waitRelease=False)
        _key_EndSR_allKeys.extend(theseKeys)
        if len(_key_EndSR_allKeys):
            key_EndSR.keys = _key_EndSR_allKeys[-1].name  # just the last key pressed
            key_EndSR.rt = _key_EndSR_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # *phases_endSR* updates
    if phases_endSR.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_endSR.frameNStart = frameN  # exact frame index
        phases_endSR.tStart = t  # local t and not account for scr refresh
        phases_endSR.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_endSR, 'tStartRefresh')  # time at next scr refresh
        phases_endSR.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in EndSoundRecognitionComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "EndSoundRecognition"-------
for thisComponent in EndSoundRecognitionComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_EndSR.started', text_EndSR.tStartRefresh)
thisExp.addData('text_EndSR.stopped', text_EndSR.tStopRefresh)
# check responses
if key_EndSR.keys in ['', [], None]:  # No response was made
    key_EndSR.keys = None
thisExp.addData('key_EndSR.keys',key_EndSR.keys)
if key_EndSR.keys != None:  # we had a response
    thisExp.addData('key_EndSR.rt', key_EndSR.rt)
thisExp.addData('key_EndSR.started', key_EndSR.tStartRefresh)
thisExp.addData('key_EndSR.stopped', key_EndSR.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_endSR.started', phases_endSR.tStartRefresh)
thisExp.addData('phases_endSR.stopped', phases_endSR.tStopRefresh)
# the Routine "EndSoundRecognition" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Phase2instructions"-------
continueRoutine = True
# update component parameters for each repeat
key_WLinst.keys = []
key_WLinst.rt = []
_key_WLinst_allKeys = []
# keep track of which components have finished
Phase2instructionsComponents = [text, key_WLinst]
for thisComponent in Phase2instructionsComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase2instructionsClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase2instructions"-------
while continueRoutine:
    # get current time
    t = Phase2instructionsClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase2instructionsClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text* updates
    if text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text.frameNStart = frameN  # exact frame index
        text.tStart = t  # local t and not account for scr refresh
        text.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text, 'tStartRefresh')  # time at next scr refresh
        text.setAutoDraw(True)
    
    # *key_WLinst* updates
    waitOnFlip = False
    if key_WLinst.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_WLinst.frameNStart = frameN  # exact frame index
        key_WLinst.tStart = t  # local t and not account for scr refresh
        key_WLinst.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_WLinst, 'tStartRefresh')  # time at next scr refresh
        key_WLinst.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_WLinst.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_WLinst.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_WLinst.status == STARTED and not waitOnFlip:
        theseKeys = key_WLinst.getKeys(keyList=['space'], waitRelease=False)
        _key_WLinst_allKeys.extend(theseKeys)
        if len(_key_WLinst_allKeys):
            key_WLinst.keys = _key_WLinst_allKeys[-1].name  # just the last key pressed
            key_WLinst.rt = _key_WLinst_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase2instructionsComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase2instructions"-------
for thisComponent in Phase2instructionsComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text.started', text.tStartRefresh)
thisExp.addData('text.stopped', text.tStopRefresh)
# check responses
if key_WLinst.keys in ['', [], None]:  # No response was made
    key_WLinst.keys = None
thisExp.addData('key_WLinst.keys',key_WLinst.keys)
if key_WLinst.keys != None:  # we had a response
    thisExp.addData('key_WLinst.rt', key_WLinst.rt)
thisExp.addData('key_WLinst.started', key_WLinst.tStartRefresh)
thisExp.addData('key_WLinst.stopped', key_WLinst.tStopRefresh)
thisExp.nextEntry()
# the Routine "Phase2instructions" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
trials = data.TrialHandler(nReps=10, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=[None],
    seed=None, name='trials')
thisExp.addLoop(trials)  # add the loop to the experiment
thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)
if thisTrial != None:
    for paramName in thisTrial:
        exec('{} = thisTrial[paramName]'.format(paramName))

for thisTrial in trials:
    currentLoop = trials
    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)
    if thisTrial != None:
        for paramName in thisTrial:
            exec('{} = thisTrial[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "WordLearningT1"-------
    continueRoutine = True
    routineTimer.add(10.000000)
    # update component parameters for each repeat
    sound_ththami.setSound('Sounds/ththami.wav', hamming=True)
    sound_ththami.setVolume(1, log=False)
    sound_thami.setSound('Sounds/thami.wav', hamming=True)
    sound_thami.setVolume(1, log=False)
    # keep track of which components have finished
    WordLearningT1Components = [sound_ththami, image_ththami, sound_thami, image_thami]
    for thisComponent in WordLearningT1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    WordLearningT1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "WordLearningT1"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = WordLearningT1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=WordLearningT1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        # start/stop sound_ththami
        if sound_ththami.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
            # keep track of start time/frame for later
            sound_ththami.frameNStart = frameN  # exact frame index
            sound_ththami.tStart = t  # local t and not account for scr refresh
            sound_ththami.tStartRefresh = tThisFlipGlobal  # on global time
            sound_ththami.play(when=win)  # sync with win flip
        if sound_ththami.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > sound_ththami.tStartRefresh + 5.2-frameTolerance:
                # keep track of stop time/frame for later
                sound_ththami.tStop = t  # not accounting for scr refresh
                sound_ththami.frameNStop = frameN  # exact frame index
                win.timeOnFlip(sound_ththami, 'tStopRefresh')  # time at next scr refresh
                sound_ththami.stop()
        
        # *image_ththami* updates
        if image_ththami.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
            # keep track of start time/frame for later
            image_ththami.frameNStart = frameN  # exact frame index
            image_ththami.tStart = t  # local t and not account for scr refresh
            image_ththami.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_ththami, 'tStartRefresh')  # time at next scr refresh
            image_ththami.setAutoDraw(True)
        if image_ththami.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > image_ththami.tStartRefresh + 9.8-frameTolerance:
                # keep track of stop time/frame for later
                image_ththami.tStop = t  # not accounting for scr refresh
                image_ththami.frameNStop = frameN  # exact frame index
                win.timeOnFlip(image_ththami, 'tStopRefresh')  # time at next scr refresh
                image_ththami.setAutoDraw(False)
        # start/stop sound_thami
        if sound_thami.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
            # keep track of start time/frame for later
            sound_thami.frameNStart = frameN  # exact frame index
            sound_thami.tStart = t  # local t and not account for scr refresh
            sound_thami.tStartRefresh = tThisFlipGlobal  # on global time
            sound_thami.play(when=win)  # sync with win flip
        if sound_thami.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > sound_thami.tStartRefresh + 5-frameTolerance:
                # keep track of stop time/frame for later
                sound_thami.tStop = t  # not accounting for scr refresh
                sound_thami.frameNStop = frameN  # exact frame index
                win.timeOnFlip(sound_thami, 'tStopRefresh')  # time at next scr refresh
                sound_thami.stop()
        
        # *image_thami* updates
        if image_thami.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
            # keep track of start time/frame for later
            image_thami.frameNStart = frameN  # exact frame index
            image_thami.tStart = t  # local t and not account for scr refresh
            image_thami.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_thami, 'tStartRefresh')  # time at next scr refresh
            image_thami.setAutoDraw(True)
        if image_thami.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > image_thami.tStartRefresh + 5-frameTolerance:
                # keep track of stop time/frame for later
                image_thami.tStop = t  # not accounting for scr refresh
                image_thami.frameNStop = frameN  # exact frame index
                win.timeOnFlip(image_thami, 'tStopRefresh')  # time at next scr refresh
                image_thami.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in WordLearningT1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "WordLearningT1"-------
    for thisComponent in WordLearningT1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    sound_ththami.stop()  # ensure sound has stopped at end of routine
    trials.addData('sound_ththami.started', sound_ththami.tStartRefresh)
    trials.addData('sound_ththami.stopped', sound_ththami.tStopRefresh)
    trials.addData('image_ththami.started', image_ththami.tStartRefresh)
    trials.addData('image_ththami.stopped', image_ththami.tStopRefresh)
    sound_thami.stop()  # ensure sound has stopped at end of routine
    trials.addData('sound_thami.started', sound_thami.tStartRefresh)
    trials.addData('sound_thami.stopped', sound_thami.tStopRefresh)
    trials.addData('image_thami.started', image_thami.tStartRefresh)
    trials.addData('image_thami.stopped', image_thami.tStopRefresh)
    
    # ------Prepare to start Routine "WordLearningT2"-------
    continueRoutine = True
    routineTimer.add(10.000000)
    # update component parameters for each repeat
    sound_ththuri.setSound('Sounds/ththuri.wav', hamming=True)
    sound_ththuri.setVolume(1, log=False)
    sound_thuri.setSound('Sounds/thuri.wav', hamming=True)
    sound_thuri.setVolume(1, log=False)
    # keep track of which components have finished
    WordLearningT2Components = [sound_ththuri, image_ththuri, sound_thuri, image_thuri]
    for thisComponent in WordLearningT2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    WordLearningT2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "WordLearningT2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = WordLearningT2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=WordLearningT2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        # start/stop sound_ththuri
        if sound_ththuri.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
            # keep track of start time/frame for later
            sound_ththuri.frameNStart = frameN  # exact frame index
            sound_ththuri.tStart = t  # local t and not account for scr refresh
            sound_ththuri.tStartRefresh = tThisFlipGlobal  # on global time
            sound_ththuri.play(when=win)  # sync with win flip
        if sound_ththuri.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > sound_ththuri.tStartRefresh + 5.2-frameTolerance:
                # keep track of stop time/frame for later
                sound_ththuri.tStop = t  # not accounting for scr refresh
                sound_ththuri.frameNStop = frameN  # exact frame index
                win.timeOnFlip(sound_ththuri, 'tStopRefresh')  # time at next scr refresh
                sound_ththuri.stop()
        
        # *image_ththuri* updates
        if image_ththuri.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
            # keep track of start time/frame for later
            image_ththuri.frameNStart = frameN  # exact frame index
            image_ththuri.tStart = t  # local t and not account for scr refresh
            image_ththuri.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_ththuri, 'tStartRefresh')  # time at next scr refresh
            image_ththuri.setAutoDraw(True)
        if image_ththuri.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > image_ththuri.tStartRefresh + 9.8-frameTolerance:
                # keep track of stop time/frame for later
                image_ththuri.tStop = t  # not accounting for scr refresh
                image_ththuri.frameNStop = frameN  # exact frame index
                win.timeOnFlip(image_ththuri, 'tStopRefresh')  # time at next scr refresh
                image_ththuri.setAutoDraw(False)
        # start/stop sound_thuri
        if sound_thuri.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
            # keep track of start time/frame for later
            sound_thuri.frameNStart = frameN  # exact frame index
            sound_thuri.tStart = t  # local t and not account for scr refresh
            sound_thuri.tStartRefresh = tThisFlipGlobal  # on global time
            sound_thuri.play(when=win)  # sync with win flip
        if sound_thuri.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > sound_thuri.tStartRefresh + 5-frameTolerance:
                # keep track of stop time/frame for later
                sound_thuri.tStop = t  # not accounting for scr refresh
                sound_thuri.frameNStop = frameN  # exact frame index
                win.timeOnFlip(sound_thuri, 'tStopRefresh')  # time at next scr refresh
                sound_thuri.stop()
        
        # *image_thuri* updates
        if image_thuri.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
            # keep track of start time/frame for later
            image_thuri.frameNStart = frameN  # exact frame index
            image_thuri.tStart = t  # local t and not account for scr refresh
            image_thuri.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_thuri, 'tStartRefresh')  # time at next scr refresh
            image_thuri.setAutoDraw(True)
        if image_thuri.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > image_thuri.tStartRefresh + 5-frameTolerance:
                # keep track of stop time/frame for later
                image_thuri.tStop = t  # not accounting for scr refresh
                image_thuri.frameNStop = frameN  # exact frame index
                win.timeOnFlip(image_thuri, 'tStopRefresh')  # time at next scr refresh
                image_thuri.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in WordLearningT2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "WordLearningT2"-------
    for thisComponent in WordLearningT2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    sound_ththuri.stop()  # ensure sound has stopped at end of routine
    trials.addData('sound_ththuri.started', sound_ththuri.tStartRefresh)
    trials.addData('sound_ththuri.stopped', sound_ththuri.tStopRefresh)
    trials.addData('image_ththuri.started', image_ththuri.tStartRefresh)
    trials.addData('image_ththuri.stopped', image_ththuri.tStopRefresh)
    sound_thuri.stop()  # ensure sound has stopped at end of routine
    trials.addData('sound_thuri.started', sound_thuri.tStartRefresh)
    trials.addData('sound_thuri.stopped', sound_thuri.tStopRefresh)
    trials.addData('image_thuri.started', image_thuri.tStartRefresh)
    trials.addData('image_thuri.stopped', image_thuri.tStopRefresh)
    
    # ------Prepare to start Routine "WordLearningT3"-------
    continueRoutine = True
    routineTimer.add(10.000000)
    # update component parameters for each repeat
    sound_ththano.setSound('Sounds/ththano.wav', hamming=True)
    sound_ththano.setVolume(1, log=False)
    sound_thano.setSound('Sounds/thano.wav', hamming=True)
    sound_thano.setVolume(1, log=False)
    # keep track of which components have finished
    WordLearningT3Components = [sound_ththano, image_ththano, sound_thano, image_thano]
    for thisComponent in WordLearningT3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    WordLearningT3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "WordLearningT3"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = WordLearningT3Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=WordLearningT3Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        # start/stop sound_ththano
        if sound_ththano.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
            # keep track of start time/frame for later
            sound_ththano.frameNStart = frameN  # exact frame index
            sound_ththano.tStart = t  # local t and not account for scr refresh
            sound_ththano.tStartRefresh = tThisFlipGlobal  # on global time
            sound_ththano.play(when=win)  # sync with win flip
        if sound_ththano.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > sound_ththano.tStartRefresh + 5.2-frameTolerance:
                # keep track of stop time/frame for later
                sound_ththano.tStop = t  # not accounting for scr refresh
                sound_ththano.frameNStop = frameN  # exact frame index
                win.timeOnFlip(sound_ththano, 'tStopRefresh')  # time at next scr refresh
                sound_ththano.stop()
        
        # *image_ththano* updates
        if image_ththano.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
            # keep track of start time/frame for later
            image_ththano.frameNStart = frameN  # exact frame index
            image_ththano.tStart = t  # local t and not account for scr refresh
            image_ththano.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_ththano, 'tStartRefresh')  # time at next scr refresh
            image_ththano.setAutoDraw(True)
        if image_ththano.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > image_ththano.tStartRefresh + 9.8-frameTolerance:
                # keep track of stop time/frame for later
                image_ththano.tStop = t  # not accounting for scr refresh
                image_ththano.frameNStop = frameN  # exact frame index
                win.timeOnFlip(image_ththano, 'tStopRefresh')  # time at next scr refresh
                image_ththano.setAutoDraw(False)
        # start/stop sound_thano
        if sound_thano.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
            # keep track of start time/frame for later
            sound_thano.frameNStart = frameN  # exact frame index
            sound_thano.tStart = t  # local t and not account for scr refresh
            sound_thano.tStartRefresh = tThisFlipGlobal  # on global time
            sound_thano.play(when=win)  # sync with win flip
        if sound_thano.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > sound_thano.tStartRefresh + 5-frameTolerance:
                # keep track of stop time/frame for later
                sound_thano.tStop = t  # not accounting for scr refresh
                sound_thano.frameNStop = frameN  # exact frame index
                win.timeOnFlip(sound_thano, 'tStopRefresh')  # time at next scr refresh
                sound_thano.stop()
        
        # *image_thano* updates
        if image_thano.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
            # keep track of start time/frame for later
            image_thano.frameNStart = frameN  # exact frame index
            image_thano.tStart = t  # local t and not account for scr refresh
            image_thano.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_thano, 'tStartRefresh')  # time at next scr refresh
            image_thano.setAutoDraw(True)
        if image_thano.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > image_thano.tStartRefresh + 5-frameTolerance:
                # keep track of stop time/frame for later
                image_thano.tStop = t  # not accounting for scr refresh
                image_thano.frameNStop = frameN  # exact frame index
                win.timeOnFlip(image_thano, 'tStopRefresh')  # time at next scr refresh
                image_thano.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in WordLearningT3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "WordLearningT3"-------
    for thisComponent in WordLearningT3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    sound_ththano.stop()  # ensure sound has stopped at end of routine
    trials.addData('sound_ththano.started', sound_ththano.tStartRefresh)
    trials.addData('sound_ththano.stopped', sound_ththano.tStopRefresh)
    trials.addData('image_ththano.started', image_ththano.tStartRefresh)
    trials.addData('image_ththano.stopped', image_ththano.tStopRefresh)
    sound_thano.stop()  # ensure sound has stopped at end of routine
    trials.addData('sound_thano.started', sound_thano.tStartRefresh)
    trials.addData('sound_thano.stopped', sound_thano.tStopRefresh)
    trials.addData('image_thano.started', image_thano.tStartRefresh)
    trials.addData('image_thano.stopped', image_thano.tStopRefresh)
    thisExp.nextEntry()
    
# completed 10 repeats of 'trials'


# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "EndWordLearning"-------
continueRoutine = True
# update component parameters for each repeat
key_EndWL.keys = []
key_EndWL.rt = []
_key_EndWL_allKeys = []
# keep track of which components have finished
EndWordLearningComponents = [text_EndWL, key_EndWL, phases_endWL]
for thisComponent in EndWordLearningComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
EndWordLearningClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "EndWordLearning"-------
while continueRoutine:
    # get current time
    t = EndWordLearningClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=EndWordLearningClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_EndWL* updates
    if text_EndWL.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_EndWL.frameNStart = frameN  # exact frame index
        text_EndWL.tStart = t  # local t and not account for scr refresh
        text_EndWL.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_EndWL, 'tStartRefresh')  # time at next scr refresh
        text_EndWL.setAutoDraw(True)
    
    # *key_EndWL* updates
    waitOnFlip = False
    if key_EndWL.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_EndWL.frameNStart = frameN  # exact frame index
        key_EndWL.tStart = t  # local t and not account for scr refresh
        key_EndWL.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_EndWL, 'tStartRefresh')  # time at next scr refresh
        key_EndWL.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_EndWL.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_EndWL.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_EndWL.status == STARTED and not waitOnFlip:
        theseKeys = key_EndWL.getKeys(keyList=['space'], waitRelease=False)
        _key_EndWL_allKeys.extend(theseKeys)
        if len(_key_EndWL_allKeys):
            key_EndWL.keys = _key_EndWL_allKeys[-1].name  # just the last key pressed
            key_EndWL.rt = _key_EndWL_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # *phases_endWL* updates
    if phases_endWL.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_endWL.frameNStart = frameN  # exact frame index
        phases_endWL.tStart = t  # local t and not account for scr refresh
        phases_endWL.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_endWL, 'tStartRefresh')  # time at next scr refresh
        phases_endWL.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in EndWordLearningComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "EndWordLearning"-------
for thisComponent in EndWordLearningComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_EndWL.started', text_EndWL.tStartRefresh)
thisExp.addData('text_EndWL.stopped', text_EndWL.tStopRefresh)
# check responses
if key_EndWL.keys in ['', [], None]:  # No response was made
    key_EndWL.keys = None
thisExp.addData('key_EndWL.keys',key_EndWL.keys)
if key_EndWL.keys != None:  # we had a response
    thisExp.addData('key_EndWL.rt', key_EndWL.rt)
thisExp.addData('key_EndWL.started', key_EndWL.tStartRefresh)
thisExp.addData('key_EndWL.stopped', key_EndWL.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_endWL.started', phases_endWL.tStartRefresh)
thisExp.addData('phases_endWL.stopped', phases_endWL.tStopRefresh)
# the Routine "EndWordLearning" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Phase3Instructions1"-------
continueRoutine = True
# update component parameters for each repeat
key_CTinstructionsT1.keys = []
key_CTinstructionsT1.rt = []
_key_CTinstructionsT1_allKeys = []
# keep track of which components have finished
Phase3Instructions1Components = [text_CTInstructionsT1, key_CTinstructionsT1]
for thisComponent in Phase3Instructions1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase3Instructions1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase3Instructions1"-------
while continueRoutine:
    # get current time
    t = Phase3Instructions1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase3Instructions1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_CTInstructionsT1* updates
    if text_CTInstructionsT1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CTInstructionsT1.frameNStart = frameN  # exact frame index
        text_CTInstructionsT1.tStart = t  # local t and not account for scr refresh
        text_CTInstructionsT1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CTInstructionsT1, 'tStartRefresh')  # time at next scr refresh
        text_CTInstructionsT1.setAutoDraw(True)
    
    # *key_CTinstructionsT1* updates
    waitOnFlip = False
    if key_CTinstructionsT1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_CTinstructionsT1.frameNStart = frameN  # exact frame index
        key_CTinstructionsT1.tStart = t  # local t and not account for scr refresh
        key_CTinstructionsT1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CTinstructionsT1, 'tStartRefresh')  # time at next scr refresh
        key_CTinstructionsT1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CTinstructionsT1.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CTinstructionsT1.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CTinstructionsT1.status == STARTED and not waitOnFlip:
        theseKeys = key_CTinstructionsT1.getKeys(keyList=['space'], waitRelease=False)
        _key_CTinstructionsT1_allKeys.extend(theseKeys)
        if len(_key_CTinstructionsT1_allKeys):
            key_CTinstructionsT1.keys = _key_CTinstructionsT1_allKeys[-1].name  # just the last key pressed
            key_CTinstructionsT1.rt = _key_CTinstructionsT1_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase3Instructions1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase3Instructions1"-------
for thisComponent in Phase3Instructions1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_CTInstructionsT1.started', text_CTInstructionsT1.tStartRefresh)
thisExp.addData('text_CTInstructionsT1.stopped', text_CTInstructionsT1.tStopRefresh)
# check responses
if key_CTinstructionsT1.keys in ['', [], None]:  # No response was made
    key_CTinstructionsT1.keys = None
thisExp.addData('key_CTinstructionsT1.keys',key_CTinstructionsT1.keys)
if key_CTinstructionsT1.keys != None:  # we had a response
    thisExp.addData('key_CTinstructionsT1.rt', key_CTinstructionsT1.rt)
thisExp.addData('key_CTinstructionsT1.started', key_CTinstructionsT1.tStartRefresh)
thisExp.addData('key_CTinstructionsT1.stopped', key_CTinstructionsT1.tStopRefresh)
thisExp.nextEntry()
# the Routine "Phase3Instructions1" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "CriterionTestT1T1"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thuri2.setSound('Sounds/thuri.wav', hamming=True)
sound_thuri2.setVolume(1, log=False)
key_CT_T1T1.keys = []
key_CT_T1T1.rt = []
_key_CT_T1T1_allKeys = []
# keep track of which components have finished
CriterionTestT1T1Components = [sound_thuri2, image_thuri2, Text_CT_T1T1, key_CT_T1T1, phases_CT_T1T1]
for thisComponent in CriterionTestT1T1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT1T1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT1T1"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT1T1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT1T1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thuri2
    if sound_thuri2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thuri2.frameNStart = frameN  # exact frame index
        sound_thuri2.tStart = t  # local t and not account for scr refresh
        sound_thuri2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thuri2.play(when=win)  # sync with win flip
    if sound_thuri2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thuri2.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thuri2.tStop = t  # not accounting for scr refresh
            sound_thuri2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thuri2, 'tStopRefresh')  # time at next scr refresh
            sound_thuri2.stop()
    
    # *image_thuri2* updates
    if image_thuri2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri2.frameNStart = frameN  # exact frame index
        image_thuri2.tStart = t  # local t and not account for scr refresh
        image_thuri2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri2, 'tStartRefresh')  # time at next scr refresh
        image_thuri2.setAutoDraw(True)
    if image_thuri2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri2.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri2.tStop = t  # not accounting for scr refresh
            image_thuri2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri2, 'tStopRefresh')  # time at next scr refresh
            image_thuri2.setAutoDraw(False)
    
    # *Text_CT_T1T1* updates
    if Text_CT_T1T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        Text_CT_T1T1.frameNStart = frameN  # exact frame index
        Text_CT_T1T1.tStart = t  # local t and not account for scr refresh
        Text_CT_T1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(Text_CT_T1T1, 'tStartRefresh')  # time at next scr refresh
        Text_CT_T1T1.setAutoDraw(True)
    if Text_CT_T1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > Text_CT_T1T1.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            Text_CT_T1T1.tStop = t  # not accounting for scr refresh
            Text_CT_T1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(Text_CT_T1T1, 'tStopRefresh')  # time at next scr refresh
            Text_CT_T1T1.setAutoDraw(False)
    
    # *key_CT_T1T1* updates
    waitOnFlip = False
    if key_CT_T1T1.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T1.frameNStart = frameN  # exact frame index
        key_CT_T1T1.tStart = t  # local t and not account for scr refresh
        key_CT_T1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T1, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T1.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T1.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T1.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T1.tStop = t  # not accounting for scr refresh
            key_CT_T1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T1, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T1.status = FINISHED
    if key_CT_T1T1.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T1.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T1_allKeys.extend(theseKeys)
        if len(_key_CT_T1T1_allKeys):
            key_CT_T1T1.keys = _key_CT_T1T1_allKeys[-1].name  # just the last key pressed
            key_CT_T1T1.rt = _key_CT_T1T1_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T1.keys == str('1')) or (key_CT_T1T1.keys == '1'):
                key_CT_T1T1.corr = 1
            else:
                key_CT_T1T1.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T1* updates
    if phases_CT_T1T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T1.frameNStart = frameN  # exact frame index
        phases_CT_T1T1.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T1, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T1.setAutoDraw(True)
    if phases_CT_T1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T1.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T1.tStop = t  # not accounting for scr refresh
            phases_CT_T1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T1, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T1.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT1T1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT1T1"-------
for thisComponent in CriterionTestT1T1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thuri2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thuri2.started', sound_thuri2.tStartRefresh)
thisExp.addData('sound_thuri2.stopped', sound_thuri2.tStopRefresh)
thisExp.addData('image_thuri2.started', image_thuri2.tStartRefresh)
thisExp.addData('image_thuri2.stopped', image_thuri2.tStopRefresh)
thisExp.addData('Text_CT_T1T1.started', Text_CT_T1T1.tStartRefresh)
thisExp.addData('Text_CT_T1T1.stopped', Text_CT_T1T1.tStopRefresh)
# check responses
if key_CT_T1T1.keys in ['', [], None]:  # No response was made
    key_CT_T1T1.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T1T1.corr = 1;  # correct non-response
    else:
       key_CT_T1T1.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T1.keys',key_CT_T1T1.keys)
thisExp.addData('key_CT_T1T1.corr', key_CT_T1T1.corr)
if key_CT_T1T1.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T1.rt', key_CT_T1T1.rt)
thisExp.addData('key_CT_T1T1.started', key_CT_T1T1.tStartRefresh)
thisExp.addData('key_CT_T1T1.stopped', key_CT_T1T1.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T1.started', phases_CT_T1T1.tStartRefresh)
thisExp.addData('phases_CT_T1T1.stopped', phases_CT_T1T1.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT1T2"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thano2.setSound('Sounds/thano.wav', hamming=True)
sound_thano2.setVolume(1, log=False)
key_CT_T1T2.keys = []
key_CT_T1T2.rt = []
_key_CT_T1T2_allKeys = []
# keep track of which components have finished
CriterionTestT1T2Components = [sound_thano2, image_ththami2, text_CT_T1T2, key_CT_T1T2, phases_CT_T1T2]
for thisComponent in CriterionTestT1T2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT1T2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT1T2"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT1T2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT1T2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thano2
    if sound_thano2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thano2.frameNStart = frameN  # exact frame index
        sound_thano2.tStart = t  # local t and not account for scr refresh
        sound_thano2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thano2.play(when=win)  # sync with win flip
    if sound_thano2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thano2.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thano2.tStop = t  # not accounting for scr refresh
            sound_thano2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thano2, 'tStopRefresh')  # time at next scr refresh
            sound_thano2.stop()
    
    # *image_ththami2* updates
    if image_ththami2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami2.frameNStart = frameN  # exact frame index
        image_ththami2.tStart = t  # local t and not account for scr refresh
        image_ththami2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami2, 'tStartRefresh')  # time at next scr refresh
        image_ththami2.setAutoDraw(True)
    if image_ththami2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami2.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami2.tStop = t  # not accounting for scr refresh
            image_ththami2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami2, 'tStopRefresh')  # time at next scr refresh
            image_ththami2.setAutoDraw(False)
    
    # *text_CT_T1T2* updates
    if text_CT_T1T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T2.frameNStart = frameN  # exact frame index
        text_CT_T1T2.tStart = t  # local t and not account for scr refresh
        text_CT_T1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T2, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T2.setAutoDraw(True)
    if text_CT_T1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T2.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T2.tStop = t  # not accounting for scr refresh
            text_CT_T1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T2, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T2.setAutoDraw(False)
    
    # *key_CT_T1T2* updates
    waitOnFlip = False
    if key_CT_T1T2.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T2.frameNStart = frameN  # exact frame index
        key_CT_T1T2.tStart = t  # local t and not account for scr refresh
        key_CT_T1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T2, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T2.tStop = t  # not accounting for scr refresh
            key_CT_T1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T2, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T2.status = FINISHED
    if key_CT_T1T2.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T2.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T2_allKeys.extend(theseKeys)
        if len(_key_CT_T1T2_allKeys):
            key_CT_T1T2.keys = _key_CT_T1T2_allKeys[-1].name  # just the last key pressed
            key_CT_T1T2.rt = _key_CT_T1T2_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T2.keys == str('0')) or (key_CT_T1T2.keys == '0'):
                key_CT_T1T2.corr = 1
            else:
                key_CT_T1T2.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T2* updates
    if phases_CT_T1T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T2.frameNStart = frameN  # exact frame index
        phases_CT_T1T2.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T2, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T2.setAutoDraw(True)
    if phases_CT_T1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T2.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T2.tStop = t  # not accounting for scr refresh
            phases_CT_T1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T2, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T2.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT1T2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT1T2"-------
for thisComponent in CriterionTestT1T2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thano2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thano2.started', sound_thano2.tStartRefresh)
thisExp.addData('sound_thano2.stopped', sound_thano2.tStopRefresh)
thisExp.addData('image_ththami2.started', image_ththami2.tStartRefresh)
thisExp.addData('image_ththami2.stopped', image_ththami2.tStopRefresh)
thisExp.addData('text_CT_T1T2.started', text_CT_T1T2.tStartRefresh)
thisExp.addData('text_CT_T1T2.stopped', text_CT_T1T2.tStopRefresh)
# check responses
if key_CT_T1T2.keys in ['', [], None]:  # No response was made
    key_CT_T1T2.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T1T2.corr = 1;  # correct non-response
    else:
       key_CT_T1T2.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T2.keys',key_CT_T1T2.keys)
thisExp.addData('key_CT_T1T2.corr', key_CT_T1T2.corr)
if key_CT_T1T2.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T2.rt', key_CT_T1T2.rt)
thisExp.addData('key_CT_T1T2.started', key_CT_T1T2.tStartRefresh)
thisExp.addData('key_CT_T1T2.stopped', key_CT_T1T2.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T2.started', phases_CT_T1T2.tStartRefresh)
thisExp.addData('phases_CT_T1T2.stopped', phases_CT_T1T2.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT1T3"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththuri3.setSound('Sounds/ththuri.wav', hamming=True)
sound_ththuri3.setVolume(1, log=False)
key_CT_T1T3.keys = []
key_CT_T1T3.rt = []
_key_CT_T1T3_allKeys = []
# keep track of which components have finished
CriterionTestT1T3Components = [sound_ththuri3, image_ththuri3, text_CT_T1T3, key_CT_T1T3, phases_CT_T1T3]
for thisComponent in CriterionTestT1T3Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT1T3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT1T3"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT1T3Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT1T3Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththuri3
    if sound_ththuri3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththuri3.frameNStart = frameN  # exact frame index
        sound_ththuri3.tStart = t  # local t and not account for scr refresh
        sound_ththuri3.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththuri3.play(when=win)  # sync with win flip
    if sound_ththuri3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththuri3.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththuri3.tStop = t  # not accounting for scr refresh
            sound_ththuri3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththuri3, 'tStopRefresh')  # time at next scr refresh
            sound_ththuri3.stop()
    
    # *image_ththuri3* updates
    if image_ththuri3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri3.frameNStart = frameN  # exact frame index
        image_ththuri3.tStart = t  # local t and not account for scr refresh
        image_ththuri3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri3, 'tStartRefresh')  # time at next scr refresh
        image_ththuri3.setAutoDraw(True)
    if image_ththuri3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri3.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri3.tStop = t  # not accounting for scr refresh
            image_ththuri3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri3, 'tStopRefresh')  # time at next scr refresh
            image_ththuri3.setAutoDraw(False)
    
    # *text_CT_T1T3* updates
    if text_CT_T1T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T3.frameNStart = frameN  # exact frame index
        text_CT_T1T3.tStart = t  # local t and not account for scr refresh
        text_CT_T1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T3, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T3.setAutoDraw(True)
    if text_CT_T1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T3.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T3.tStop = t  # not accounting for scr refresh
            text_CT_T1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T3, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T3.setAutoDraw(False)
    
    # *key_CT_T1T3* updates
    waitOnFlip = False
    if key_CT_T1T3.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T3.frameNStart = frameN  # exact frame index
        key_CT_T1T3.tStart = t  # local t and not account for scr refresh
        key_CT_T1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T3, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T3.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T3.tStop = t  # not accounting for scr refresh
            key_CT_T1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T3, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T3.status = FINISHED
    if key_CT_T1T3.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T3.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T3_allKeys.extend(theseKeys)
        if len(_key_CT_T1T3_allKeys):
            key_CT_T1T3.keys = _key_CT_T1T3_allKeys[-1].name  # just the last key pressed
            key_CT_T1T3.rt = _key_CT_T1T3_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T3.keys == str('1')) or (key_CT_T1T3.keys == '1'):
                key_CT_T1T3.corr = 1
            else:
                key_CT_T1T3.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T3* updates
    if phases_CT_T1T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T3.frameNStart = frameN  # exact frame index
        phases_CT_T1T3.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T3, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T3.setAutoDraw(True)
    if phases_CT_T1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T3.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T3.tStop = t  # not accounting for scr refresh
            phases_CT_T1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T3, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T3.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT1T3Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT1T3"-------
for thisComponent in CriterionTestT1T3Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththuri3.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththuri3.started', sound_ththuri3.tStartRefresh)
thisExp.addData('sound_ththuri3.stopped', sound_ththuri3.tStopRefresh)
thisExp.addData('image_ththuri3.started', image_ththuri3.tStartRefresh)
thisExp.addData('image_ththuri3.stopped', image_ththuri3.tStopRefresh)
thisExp.addData('text_CT_T1T3.started', text_CT_T1T3.tStartRefresh)
thisExp.addData('text_CT_T1T3.stopped', text_CT_T1T3.tStopRefresh)
# check responses
if key_CT_T1T3.keys in ['', [], None]:  # No response was made
    key_CT_T1T3.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T1T3.corr = 1;  # correct non-response
    else:
       key_CT_T1T3.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T3.keys',key_CT_T1T3.keys)
thisExp.addData('key_CT_T1T3.corr', key_CT_T1T3.corr)
if key_CT_T1T3.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T3.rt', key_CT_T1T3.rt)
thisExp.addData('key_CT_T1T3.started', key_CT_T1T3.tStartRefresh)
thisExp.addData('key_CT_T1T3.stopped', key_CT_T1T3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T3.started', phases_CT_T1T3.tStartRefresh)
thisExp.addData('phases_CT_T1T3.stopped', phases_CT_T1T3.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT1T4"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thami3.setSound('Sounds/thami.wav', hamming=True)
sound_thami3.setVolume(1, log=False)
key_CT_T1T4.keys = []
key_CT_T1T4.rt = []
_key_CT_T1T4_allKeys = []
# keep track of which components have finished
CriterionTestT1T4Components = [sound_thami3, image_thami3, text_CT_T1T4, key_CT_T1T4, phases_CT_T1T4]
for thisComponent in CriterionTestT1T4Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT1T4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT1T4"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT1T4Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT1T4Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thami3
    if sound_thami3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thami3.frameNStart = frameN  # exact frame index
        sound_thami3.tStart = t  # local t and not account for scr refresh
        sound_thami3.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thami3.play(when=win)  # sync with win flip
    if sound_thami3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thami3.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thami3.tStop = t  # not accounting for scr refresh
            sound_thami3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thami3, 'tStopRefresh')  # time at next scr refresh
            sound_thami3.stop()
    
    # *image_thami3* updates
    if image_thami3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami3.frameNStart = frameN  # exact frame index
        image_thami3.tStart = t  # local t and not account for scr refresh
        image_thami3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami3, 'tStartRefresh')  # time at next scr refresh
        image_thami3.setAutoDraw(True)
    if image_thami3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami3.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami3.tStop = t  # not accounting for scr refresh
            image_thami3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami3, 'tStopRefresh')  # time at next scr refresh
            image_thami3.setAutoDraw(False)
    
    # *text_CT_T1T4* updates
    if text_CT_T1T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T4.frameNStart = frameN  # exact frame index
        text_CT_T1T4.tStart = t  # local t and not account for scr refresh
        text_CT_T1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T4, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T4.setAutoDraw(True)
    if text_CT_T1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T4.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T4.tStop = t  # not accounting for scr refresh
            text_CT_T1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T4, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T4.setAutoDraw(False)
    
    # *key_CT_T1T4* updates
    waitOnFlip = False
    if key_CT_T1T4.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T4.frameNStart = frameN  # exact frame index
        key_CT_T1T4.tStart = t  # local t and not account for scr refresh
        key_CT_T1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T4, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T4.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T4.tStop = t  # not accounting for scr refresh
            key_CT_T1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T4, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T4.status = FINISHED
    if key_CT_T1T4.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T4.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T4_allKeys.extend(theseKeys)
        if len(_key_CT_T1T4_allKeys):
            key_CT_T1T4.keys = _key_CT_T1T4_allKeys[-1].name  # just the last key pressed
            key_CT_T1T4.rt = _key_CT_T1T4_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T4.keys == str('1')) or (key_CT_T1T4.keys == '1'):
                key_CT_T1T4.corr = 1
            else:
                key_CT_T1T4.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T4* updates
    if phases_CT_T1T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T4.frameNStart = frameN  # exact frame index
        phases_CT_T1T4.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T4, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T4.setAutoDraw(True)
    if phases_CT_T1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T4.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T4.tStop = t  # not accounting for scr refresh
            phases_CT_T1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T4, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T4.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT1T4Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT1T4"-------
for thisComponent in CriterionTestT1T4Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thami3.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thami3.started', sound_thami3.tStartRefresh)
thisExp.addData('sound_thami3.stopped', sound_thami3.tStopRefresh)
thisExp.addData('image_thami3.started', image_thami3.tStartRefresh)
thisExp.addData('image_thami3.stopped', image_thami3.tStopRefresh)
thisExp.addData('text_CT_T1T4.started', text_CT_T1T4.tStartRefresh)
thisExp.addData('text_CT_T1T4.stopped', text_CT_T1T4.tStopRefresh)
# check responses
if key_CT_T1T4.keys in ['', [], None]:  # No response was made
    key_CT_T1T4.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T1T4.corr = 1;  # correct non-response
    else:
       key_CT_T1T4.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T4.keys',key_CT_T1T4.keys)
thisExp.addData('key_CT_T1T4.corr', key_CT_T1T4.corr)
if key_CT_T1T4.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T4.rt', key_CT_T1T4.rt)
thisExp.addData('key_CT_T1T4.started', key_CT_T1T4.tStartRefresh)
thisExp.addData('key_CT_T1T4.stopped', key_CT_T1T4.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T4.started', phases_CT_T1T4.tStartRefresh)
thisExp.addData('phases_CT_T1T4.stopped', phases_CT_T1T4.tStopRefresh)

# ------Prepare to start Routine "CriteterionTestT1T5"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththano2.setSound('Sounds/ththano.wav', hamming=True)
sound_ththano2.setVolume(1, log=False)
key_CT_T1T5.keys = []
key_CT_T1T5.rt = []
_key_CT_T1T5_allKeys = []
# keep track of which components have finished
CriteterionTestT1T5Components = [sound_ththano2, image_thuri3, text_CT_T1T5, key_CT_T1T5, phases_CT_T1T5]
for thisComponent in CriteterionTestT1T5Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriteterionTestT1T5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriteterionTestT1T5"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriteterionTestT1T5Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriteterionTestT1T5Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththano2
    if sound_ththano2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththano2.frameNStart = frameN  # exact frame index
        sound_ththano2.tStart = t  # local t and not account for scr refresh
        sound_ththano2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththano2.play(when=win)  # sync with win flip
    if sound_ththano2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththano2.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththano2.tStop = t  # not accounting for scr refresh
            sound_ththano2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththano2, 'tStopRefresh')  # time at next scr refresh
            sound_ththano2.stop()
    
    # *image_thuri3* updates
    if image_thuri3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri3.frameNStart = frameN  # exact frame index
        image_thuri3.tStart = t  # local t and not account for scr refresh
        image_thuri3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri3, 'tStartRefresh')  # time at next scr refresh
        image_thuri3.setAutoDraw(True)
    if image_thuri3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri3.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri3.tStop = t  # not accounting for scr refresh
            image_thuri3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri3, 'tStopRefresh')  # time at next scr refresh
            image_thuri3.setAutoDraw(False)
    
    # *text_CT_T1T5* updates
    if text_CT_T1T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T5.frameNStart = frameN  # exact frame index
        text_CT_T1T5.tStart = t  # local t and not account for scr refresh
        text_CT_T1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T5, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T5.setAutoDraw(True)
    if text_CT_T1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T5.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T5.tStop = t  # not accounting for scr refresh
            text_CT_T1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T5, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T5.setAutoDraw(False)
    
    # *key_CT_T1T5* updates
    waitOnFlip = False
    if key_CT_T1T5.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T5.frameNStart = frameN  # exact frame index
        key_CT_T1T5.tStart = t  # local t and not account for scr refresh
        key_CT_T1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T5, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T5.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T5.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T5.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T5.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T5.tStop = t  # not accounting for scr refresh
            key_CT_T1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T5, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T5.status = FINISHED
    if key_CT_T1T5.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T5.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T5_allKeys.extend(theseKeys)
        if len(_key_CT_T1T5_allKeys):
            key_CT_T1T5.keys = _key_CT_T1T5_allKeys[-1].name  # just the last key pressed
            key_CT_T1T5.rt = _key_CT_T1T5_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T5.keys == str('0')) or (key_CT_T1T5.keys == '0'):
                key_CT_T1T5.corr = 1
            else:
                key_CT_T1T5.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T5* updates
    if phases_CT_T1T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T5.frameNStart = frameN  # exact frame index
        phases_CT_T1T5.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T5, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T5.setAutoDraw(True)
    if phases_CT_T1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T5.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T5.tStop = t  # not accounting for scr refresh
            phases_CT_T1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T5, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T5.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriteterionTestT1T5Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriteterionTestT1T5"-------
for thisComponent in CriteterionTestT1T5Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththano2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththano2.started', sound_ththano2.tStartRefresh)
thisExp.addData('sound_ththano2.stopped', sound_ththano2.tStopRefresh)
thisExp.addData('image_thuri3.started', image_thuri3.tStartRefresh)
thisExp.addData('image_thuri3.stopped', image_thuri3.tStopRefresh)
thisExp.addData('text_CT_T1T5.started', text_CT_T1T5.tStartRefresh)
thisExp.addData('text_CT_T1T5.stopped', text_CT_T1T5.tStopRefresh)
# check responses
if key_CT_T1T5.keys in ['', [], None]:  # No response was made
    key_CT_T1T5.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T1T5.corr = 1;  # correct non-response
    else:
       key_CT_T1T5.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T5.keys',key_CT_T1T5.keys)
thisExp.addData('key_CT_T1T5.corr', key_CT_T1T5.corr)
if key_CT_T1T5.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T5.rt', key_CT_T1T5.rt)
thisExp.addData('key_CT_T1T5.started', key_CT_T1T5.tStartRefresh)
thisExp.addData('key_CT_T1T5.stopped', key_CT_T1T5.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T5.started', phases_CT_T1T5.tStartRefresh)
thisExp.addData('phases_CT_T1T5.stopped', phases_CT_T1T5.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT1T6"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththami3.setSound('Sounds/ththami.wav', hamming=True)
sound_ththami3.setVolume(1, log=False)
key_CT_T1T6.keys = []
key_CT_T1T6.rt = []
_key_CT_T1T6_allKeys = []
# keep track of which components have finished
CriterionTestT1T6Components = [sound_ththami3, image_ththami3, text_CT_T1T6, key_CT_T1T6, phases_CT_T1T6]
for thisComponent in CriterionTestT1T6Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT1T6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT1T6"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT1T6Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT1T6Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththami3
    if sound_ththami3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththami3.frameNStart = frameN  # exact frame index
        sound_ththami3.tStart = t  # local t and not account for scr refresh
        sound_ththami3.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththami3.play(when=win)  # sync with win flip
    if sound_ththami3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththami3.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththami3.tStop = t  # not accounting for scr refresh
            sound_ththami3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththami3, 'tStopRefresh')  # time at next scr refresh
            sound_ththami3.stop()
    
    # *image_ththami3* updates
    if image_ththami3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami3.frameNStart = frameN  # exact frame index
        image_ththami3.tStart = t  # local t and not account for scr refresh
        image_ththami3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami3, 'tStartRefresh')  # time at next scr refresh
        image_ththami3.setAutoDraw(True)
    if image_ththami3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami3.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami3.tStop = t  # not accounting for scr refresh
            image_ththami3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami3, 'tStopRefresh')  # time at next scr refresh
            image_ththami3.setAutoDraw(False)
    
    # *text_CT_T1T6* updates
    if text_CT_T1T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T6.frameNStart = frameN  # exact frame index
        text_CT_T1T6.tStart = t  # local t and not account for scr refresh
        text_CT_T1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T6, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T6.setAutoDraw(True)
    if text_CT_T1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T6.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T6.tStop = t  # not accounting for scr refresh
            text_CT_T1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T6, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T6.setAutoDraw(False)
    
    # *key_CT_T1T6* updates
    waitOnFlip = False
    if key_CT_T1T6.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T6.frameNStart = frameN  # exact frame index
        key_CT_T1T6.tStart = t  # local t and not account for scr refresh
        key_CT_T1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T6, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T6.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T6.tStop = t  # not accounting for scr refresh
            key_CT_T1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T6, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T6.status = FINISHED
    if key_CT_T1T6.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T6.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T6_allKeys.extend(theseKeys)
        if len(_key_CT_T1T6_allKeys):
            key_CT_T1T6.keys = _key_CT_T1T6_allKeys[-1].name  # just the last key pressed
            key_CT_T1T6.rt = _key_CT_T1T6_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T6.keys == str('1')) or (key_CT_T1T6.keys == '1'):
                key_CT_T1T6.corr = 1
            else:
                key_CT_T1T6.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T6* updates
    if phases_CT_T1T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T6.frameNStart = frameN  # exact frame index
        phases_CT_T1T6.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T6, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T6.setAutoDraw(True)
    if phases_CT_T1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T6.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T6.tStop = t  # not accounting for scr refresh
            phases_CT_T1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T6, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T6.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT1T6Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT1T6"-------
for thisComponent in CriterionTestT1T6Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththami3.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththami3.started', sound_ththami3.tStartRefresh)
thisExp.addData('sound_ththami3.stopped', sound_ththami3.tStopRefresh)
thisExp.addData('image_ththami3.started', image_ththami3.tStartRefresh)
thisExp.addData('image_ththami3.stopped', image_ththami3.tStopRefresh)
thisExp.addData('text_CT_T1T6.started', text_CT_T1T6.tStartRefresh)
thisExp.addData('text_CT_T1T6.stopped', text_CT_T1T6.tStopRefresh)
# check responses
if key_CT_T1T6.keys in ['', [], None]:  # No response was made
    key_CT_T1T6.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T1T6.corr = 1;  # correct non-response
    else:
       key_CT_T1T6.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T6.keys',key_CT_T1T6.keys)
thisExp.addData('key_CT_T1T6.corr', key_CT_T1T6.corr)
if key_CT_T1T6.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T6.rt', key_CT_T1T6.rt)
thisExp.addData('key_CT_T1T6.started', key_CT_T1T6.tStartRefresh)
thisExp.addData('key_CT_T1T6.stopped', key_CT_T1T6.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T6.started', phases_CT_T1T6.tStartRefresh)
thisExp.addData('phases_CT_T1T6.stopped', phases_CT_T1T6.tStopRefresh)

# ------Prepare to start Routine "CritertionTestT1T7"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thuri3.setSound('Sounds/thuri.wav', hamming=True)
sound_thuri3.setVolume(1, log=False)
key_CT_T1T7.keys = []
key_CT_T1T7.rt = []
_key_CT_T1T7_allKeys = []
# keep track of which components have finished
CritertionTestT1T7Components = [sound_thuri3, image_ththano2, text_CT_T1T7, key_CT_T1T7, phases_CT_T1T7]
for thisComponent in CritertionTestT1T7Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CritertionTestT1T7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CritertionTestT1T7"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CritertionTestT1T7Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CritertionTestT1T7Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thuri3
    if sound_thuri3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thuri3.frameNStart = frameN  # exact frame index
        sound_thuri3.tStart = t  # local t and not account for scr refresh
        sound_thuri3.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thuri3.play(when=win)  # sync with win flip
    if sound_thuri3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thuri3.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thuri3.tStop = t  # not accounting for scr refresh
            sound_thuri3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thuri3, 'tStopRefresh')  # time at next scr refresh
            sound_thuri3.stop()
    
    # *image_ththano2* updates
    if image_ththano2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano2.frameNStart = frameN  # exact frame index
        image_ththano2.tStart = t  # local t and not account for scr refresh
        image_ththano2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano2, 'tStartRefresh')  # time at next scr refresh
        image_ththano2.setAutoDraw(True)
    if image_ththano2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano2.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano2.tStop = t  # not accounting for scr refresh
            image_ththano2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano2, 'tStopRefresh')  # time at next scr refresh
            image_ththano2.setAutoDraw(False)
    
    # *text_CT_T1T7* updates
    if text_CT_T1T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T7.frameNStart = frameN  # exact frame index
        text_CT_T1T7.tStart = t  # local t and not account for scr refresh
        text_CT_T1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T7, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T7.setAutoDraw(True)
    if text_CT_T1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T7.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T7.tStop = t  # not accounting for scr refresh
            text_CT_T1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T7, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T7.setAutoDraw(False)
    
    # *key_CT_T1T7* updates
    waitOnFlip = False
    if key_CT_T1T7.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T7.frameNStart = frameN  # exact frame index
        key_CT_T1T7.tStart = t  # local t and not account for scr refresh
        key_CT_T1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T7, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T7.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T7.tStop = t  # not accounting for scr refresh
            key_CT_T1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T7, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T7.status = FINISHED
    if key_CT_T1T7.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T7.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T7_allKeys.extend(theseKeys)
        if len(_key_CT_T1T7_allKeys):
            key_CT_T1T7.keys = _key_CT_T1T7_allKeys[-1].name  # just the last key pressed
            key_CT_T1T7.rt = _key_CT_T1T7_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T7.keys == str('0')) or (key_CT_T1T7.keys == '0'):
                key_CT_T1T7.corr = 1
            else:
                key_CT_T1T7.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T7* updates
    if phases_CT_T1T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T7.frameNStart = frameN  # exact frame index
        phases_CT_T1T7.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T7, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T7.setAutoDraw(True)
    if phases_CT_T1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T7.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T7.tStop = t  # not accounting for scr refresh
            phases_CT_T1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T7, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T7.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CritertionTestT1T7Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CritertionTestT1T7"-------
for thisComponent in CritertionTestT1T7Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thuri3.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thuri3.started', sound_thuri3.tStartRefresh)
thisExp.addData('sound_thuri3.stopped', sound_thuri3.tStopRefresh)
thisExp.addData('image_ththano2.started', image_ththano2.tStartRefresh)
thisExp.addData('image_ththano2.stopped', image_ththano2.tStopRefresh)
thisExp.addData('text_CT_T1T7.started', text_CT_T1T7.tStartRefresh)
thisExp.addData('text_CT_T1T7.stopped', text_CT_T1T7.tStopRefresh)
# check responses
if key_CT_T1T7.keys in ['', [], None]:  # No response was made
    key_CT_T1T7.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T1T7.corr = 1;  # correct non-response
    else:
       key_CT_T1T7.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T7.keys',key_CT_T1T7.keys)
thisExp.addData('key_CT_T1T7.corr', key_CT_T1T7.corr)
if key_CT_T1T7.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T7.rt', key_CT_T1T7.rt)
thisExp.addData('key_CT_T1T7.started', key_CT_T1T7.tStartRefresh)
thisExp.addData('key_CT_T1T7.stopped', key_CT_T1T7.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T7.started', phases_CT_T1T7.tStartRefresh)
thisExp.addData('phases_CT_T1T7.stopped', phases_CT_T1T7.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT1T8"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththuri2.setSound('Sounds/ththuri.wav', hamming=True)
sound_ththuri2.setVolume(1, log=False)
key_CT_T1T8.keys = []
key_CT_T1T8.rt = []
_key_CT_T1T8_allKeys = []
# keep track of which components have finished
CriterionTestT1T8Components = [sound_ththuri2, image_thami2, text_CT_T1T8, key_CT_T1T8, phases_CT_T1T8]
for thisComponent in CriterionTestT1T8Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT1T8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT1T8"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT1T8Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT1T8Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththuri2
    if sound_ththuri2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththuri2.frameNStart = frameN  # exact frame index
        sound_ththuri2.tStart = t  # local t and not account for scr refresh
        sound_ththuri2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththuri2.play(when=win)  # sync with win flip
    if sound_ththuri2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththuri2.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththuri2.tStop = t  # not accounting for scr refresh
            sound_ththuri2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththuri2, 'tStopRefresh')  # time at next scr refresh
            sound_ththuri2.stop()
    
    # *image_thami2* updates
    if image_thami2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami2.frameNStart = frameN  # exact frame index
        image_thami2.tStart = t  # local t and not account for scr refresh
        image_thami2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami2, 'tStartRefresh')  # time at next scr refresh
        image_thami2.setAutoDraw(True)
    if image_thami2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami2.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami2.tStop = t  # not accounting for scr refresh
            image_thami2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami2, 'tStopRefresh')  # time at next scr refresh
            image_thami2.setAutoDraw(False)
    
    # *text_CT_T1T8* updates
    if text_CT_T1T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T8.frameNStart = frameN  # exact frame index
        text_CT_T1T8.tStart = t  # local t and not account for scr refresh
        text_CT_T1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T8, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T8.setAutoDraw(True)
    if text_CT_T1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T8.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T8.tStop = t  # not accounting for scr refresh
            text_CT_T1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T8, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T8.setAutoDraw(False)
    
    # *key_CT_T1T8* updates
    waitOnFlip = False
    if key_CT_T1T8.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T8.frameNStart = frameN  # exact frame index
        key_CT_T1T8.tStart = t  # local t and not account for scr refresh
        key_CT_T1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T8, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T8.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T8.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T8.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T8.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T8.tStop = t  # not accounting for scr refresh
            key_CT_T1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T8, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T8.status = FINISHED
    if key_CT_T1T8.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T8.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T8_allKeys.extend(theseKeys)
        if len(_key_CT_T1T8_allKeys):
            key_CT_T1T8.keys = _key_CT_T1T8_allKeys[-1].name  # just the last key pressed
            key_CT_T1T8.rt = _key_CT_T1T8_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T8.keys == str('0')) or (key_CT_T1T8.keys == '0'):
                key_CT_T1T8.corr = 1
            else:
                key_CT_T1T8.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T8* updates
    if phases_CT_T1T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T8.frameNStart = frameN  # exact frame index
        phases_CT_T1T8.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T8, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T8.setAutoDraw(True)
    if phases_CT_T1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T8.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T8.tStop = t  # not accounting for scr refresh
            phases_CT_T1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T8, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T8.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT1T8Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT1T8"-------
for thisComponent in CriterionTestT1T8Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththuri2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththuri2.started', sound_ththuri2.tStartRefresh)
thisExp.addData('sound_ththuri2.stopped', sound_ththuri2.tStopRefresh)
thisExp.addData('image_thami2.started', image_thami2.tStartRefresh)
thisExp.addData('image_thami2.stopped', image_thami2.tStopRefresh)
thisExp.addData('text_CT_T1T8.started', text_CT_T1T8.tStartRefresh)
thisExp.addData('text_CT_T1T8.stopped', text_CT_T1T8.tStopRefresh)
# check responses
if key_CT_T1T8.keys in ['', [], None]:  # No response was made
    key_CT_T1T8.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T1T8.corr = 1;  # correct non-response
    else:
       key_CT_T1T8.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T8.keys',key_CT_T1T8.keys)
thisExp.addData('key_CT_T1T8.corr', key_CT_T1T8.corr)
if key_CT_T1T8.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T8.rt', key_CT_T1T8.rt)
thisExp.addData('key_CT_T1T8.started', key_CT_T1T8.tStartRefresh)
thisExp.addData('key_CT_T1T8.stopped', key_CT_T1T8.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T8.started', phases_CT_T1T8.tStartRefresh)
thisExp.addData('phases_CT_T1T8.stopped', phases_CT_T1T8.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT1T9"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thano3.setSound('Sounds/thano.wav', hamming=True)
sound_thano3.setVolume(1, log=False)
key_CT_T1T9.keys = []
key_CT_T1T9.rt = []
_key_CT_T1T9_allKeys = []
# keep track of which components have finished
CriterionTestT1T9Components = [sound_thano3, image_thano3, text_CT_T1T9, key_CT_T1T9, phases_CT_T1T9]
for thisComponent in CriterionTestT1T9Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT1T9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT1T9"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT1T9Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT1T9Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thano3
    if sound_thano3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thano3.frameNStart = frameN  # exact frame index
        sound_thano3.tStart = t  # local t and not account for scr refresh
        sound_thano3.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thano3.play(when=win)  # sync with win flip
    if sound_thano3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thano3.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thano3.tStop = t  # not accounting for scr refresh
            sound_thano3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thano3, 'tStopRefresh')  # time at next scr refresh
            sound_thano3.stop()
    
    # *image_thano3* updates
    if image_thano3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano3.frameNStart = frameN  # exact frame index
        image_thano3.tStart = t  # local t and not account for scr refresh
        image_thano3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano3, 'tStartRefresh')  # time at next scr refresh
        image_thano3.setAutoDraw(True)
    if image_thano3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano3.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano3.tStop = t  # not accounting for scr refresh
            image_thano3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano3, 'tStopRefresh')  # time at next scr refresh
            image_thano3.setAutoDraw(False)
    
    # *text_CT_T1T9* updates
    if text_CT_T1T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T9.frameNStart = frameN  # exact frame index
        text_CT_T1T9.tStart = t  # local t and not account for scr refresh
        text_CT_T1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T9, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T9.setAutoDraw(True)
    if text_CT_T1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T9.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T9.tStop = t  # not accounting for scr refresh
            text_CT_T1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T9, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T9.setAutoDraw(False)
    
    # *key_CT_T1T9* updates
    waitOnFlip = False
    if key_CT_T1T9.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T9.frameNStart = frameN  # exact frame index
        key_CT_T1T9.tStart = t  # local t and not account for scr refresh
        key_CT_T1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T9, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T9.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T9.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T9.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T9.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T9.tStop = t  # not accounting for scr refresh
            key_CT_T1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T9, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T9.status = FINISHED
    if key_CT_T1T9.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T9.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T9_allKeys.extend(theseKeys)
        if len(_key_CT_T1T9_allKeys):
            key_CT_T1T9.keys = _key_CT_T1T9_allKeys[-1].name  # just the last key pressed
            key_CT_T1T9.rt = _key_CT_T1T9_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T9.keys == str('1')) or (key_CT_T1T9.keys == '1'):
                key_CT_T1T9.corr = 1
            else:
                key_CT_T1T9.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T9* updates
    if phases_CT_T1T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T9.frameNStart = frameN  # exact frame index
        phases_CT_T1T9.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T9, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T9.setAutoDraw(True)
    if phases_CT_T1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T9.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T9.tStop = t  # not accounting for scr refresh
            phases_CT_T1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T9, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T9.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT1T9Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT1T9"-------
for thisComponent in CriterionTestT1T9Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thano3.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thano3.started', sound_thano3.tStartRefresh)
thisExp.addData('sound_thano3.stopped', sound_thano3.tStopRefresh)
thisExp.addData('image_thano3.started', image_thano3.tStartRefresh)
thisExp.addData('image_thano3.stopped', image_thano3.tStopRefresh)
thisExp.addData('text_CT_T1T9.started', text_CT_T1T9.tStartRefresh)
thisExp.addData('text_CT_T1T9.stopped', text_CT_T1T9.tStopRefresh)
# check responses
if key_CT_T1T9.keys in ['', [], None]:  # No response was made
    key_CT_T1T9.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T1T9.corr = 1;  # correct non-response
    else:
       key_CT_T1T9.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T9.keys',key_CT_T1T9.keys)
thisExp.addData('key_CT_T1T9.corr', key_CT_T1T9.corr)
if key_CT_T1T9.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T9.rt', key_CT_T1T9.rt)
thisExp.addData('key_CT_T1T9.started', key_CT_T1T9.tStartRefresh)
thisExp.addData('key_CT_T1T9.stopped', key_CT_T1T9.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T9.started', phases_CT_T1T9.tStartRefresh)
thisExp.addData('phases_CT_T1T9.stopped', phases_CT_T1T9.tStopRefresh)

# ------Prepare to start Routine "CritertionTestT1T10"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththami2.setSound('Sounds/ththami.wav', hamming=True)
sound_ththami2.setVolume(1, log=False)
key_CT_T1T10.keys = []
key_CT_T1T10.rt = []
_key_CT_T1T10_allKeys = []
# keep track of which components have finished
CritertionTestT1T10Components = [sound_ththami2, image_thano2, text_CT_T1T10, key_CT_T1T10, phases_CT_T1T10]
for thisComponent in CritertionTestT1T10Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CritertionTestT1T10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CritertionTestT1T10"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CritertionTestT1T10Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CritertionTestT1T10Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththami2
    if sound_ththami2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththami2.frameNStart = frameN  # exact frame index
        sound_ththami2.tStart = t  # local t and not account for scr refresh
        sound_ththami2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththami2.play(when=win)  # sync with win flip
    if sound_ththami2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththami2.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththami2.tStop = t  # not accounting for scr refresh
            sound_ththami2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththami2, 'tStopRefresh')  # time at next scr refresh
            sound_ththami2.stop()
    
    # *image_thano2* updates
    if image_thano2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano2.frameNStart = frameN  # exact frame index
        image_thano2.tStart = t  # local t and not account for scr refresh
        image_thano2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano2, 'tStartRefresh')  # time at next scr refresh
        image_thano2.setAutoDraw(True)
    if image_thano2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano2.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano2.tStop = t  # not accounting for scr refresh
            image_thano2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano2, 'tStopRefresh')  # time at next scr refresh
            image_thano2.setAutoDraw(False)
    
    # *text_CT_T1T10* updates
    if text_CT_T1T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T10.frameNStart = frameN  # exact frame index
        text_CT_T1T10.tStart = t  # local t and not account for scr refresh
        text_CT_T1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T10, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T10.setAutoDraw(True)
    if text_CT_T1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T10.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T10.tStop = t  # not accounting for scr refresh
            text_CT_T1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T10, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T10.setAutoDraw(False)
    
    # *key_CT_T1T10* updates
    waitOnFlip = False
    if key_CT_T1T10.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T10.frameNStart = frameN  # exact frame index
        key_CT_T1T10.tStart = t  # local t and not account for scr refresh
        key_CT_T1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T10, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T10.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T10.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T10.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T10.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T10.tStop = t  # not accounting for scr refresh
            key_CT_T1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T10, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T10.status = FINISHED
    if key_CT_T1T10.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T10.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T10_allKeys.extend(theseKeys)
        if len(_key_CT_T1T10_allKeys):
            key_CT_T1T10.keys = _key_CT_T1T10_allKeys[-1].name  # just the last key pressed
            key_CT_T1T10.rt = _key_CT_T1T10_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T10.keys == str('0')) or (key_CT_T1T10.keys == '0'):
                key_CT_T1T10.corr = 1
            else:
                key_CT_T1T10.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T10* updates
    if phases_CT_T1T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T10.frameNStart = frameN  # exact frame index
        phases_CT_T1T10.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T10, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T10.setAutoDraw(True)
    if phases_CT_T1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T10.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T10.tStop = t  # not accounting for scr refresh
            phases_CT_T1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T10, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T10.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CritertionTestT1T10Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CritertionTestT1T10"-------
for thisComponent in CritertionTestT1T10Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththami2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththami2.started', sound_ththami2.tStartRefresh)
thisExp.addData('sound_ththami2.stopped', sound_ththami2.tStopRefresh)
thisExp.addData('image_thano2.started', image_thano2.tStartRefresh)
thisExp.addData('image_thano2.stopped', image_thano2.tStopRefresh)
thisExp.addData('text_CT_T1T10.started', text_CT_T1T10.tStartRefresh)
thisExp.addData('text_CT_T1T10.stopped', text_CT_T1T10.tStopRefresh)
# check responses
if key_CT_T1T10.keys in ['', [], None]:  # No response was made
    key_CT_T1T10.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T1T10.corr = 1;  # correct non-response
    else:
       key_CT_T1T10.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T10.keys',key_CT_T1T10.keys)
thisExp.addData('key_CT_T1T10.corr', key_CT_T1T10.corr)
if key_CT_T1T10.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T10.rt', key_CT_T1T10.rt)
thisExp.addData('key_CT_T1T10.started', key_CT_T1T10.tStartRefresh)
thisExp.addData('key_CT_T1T10.stopped', key_CT_T1T10.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T10.started', phases_CT_T1T10.tStartRefresh)
thisExp.addData('phases_CT_T1T10.stopped', phases_CT_T1T10.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT1T11"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththano3.setSound('Sounds/ththano.wav', hamming=True)
sound_ththano3.setVolume(1, log=False)
key_CT_T1T11.keys = []
key_CT_T1T11.rt = []
_key_CT_T1T11_allKeys = []
# keep track of which components have finished
CriterionTestT1T11Components = [sound_ththano3, image_ththano3, text_CT_T1T11, key_CT_T1T11, phases_CT_T1T11]
for thisComponent in CriterionTestT1T11Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT1T11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT1T11"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT1T11Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT1T11Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththano3
    if sound_ththano3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththano3.frameNStart = frameN  # exact frame index
        sound_ththano3.tStart = t  # local t and not account for scr refresh
        sound_ththano3.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththano3.play(when=win)  # sync with win flip
    if sound_ththano3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththano3.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththano3.tStop = t  # not accounting for scr refresh
            sound_ththano3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththano3, 'tStopRefresh')  # time at next scr refresh
            sound_ththano3.stop()
    
    # *image_ththano3* updates
    if image_ththano3.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano3.frameNStart = frameN  # exact frame index
        image_ththano3.tStart = t  # local t and not account for scr refresh
        image_ththano3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano3, 'tStartRefresh')  # time at next scr refresh
        image_ththano3.setAutoDraw(True)
    if image_ththano3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano3.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano3.tStop = t  # not accounting for scr refresh
            image_ththano3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano3, 'tStopRefresh')  # time at next scr refresh
            image_ththano3.setAutoDraw(False)
    
    # *text_CT_T1T11* updates
    if text_CT_T1T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T11.frameNStart = frameN  # exact frame index
        text_CT_T1T11.tStart = t  # local t and not account for scr refresh
        text_CT_T1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T11, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T11.setAutoDraw(True)
    if text_CT_T1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T11.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T11.tStop = t  # not accounting for scr refresh
            text_CT_T1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T11, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T11.setAutoDraw(False)
    
    # *key_CT_T1T11* updates
    waitOnFlip = False
    if key_CT_T1T11.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T11.frameNStart = frameN  # exact frame index
        key_CT_T1T11.tStart = t  # local t and not account for scr refresh
        key_CT_T1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T11, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T11.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T11.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T11.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T11.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T11.tStop = t  # not accounting for scr refresh
            key_CT_T1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T11, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T11.status = FINISHED
    if key_CT_T1T11.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T11.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T11_allKeys.extend(theseKeys)
        if len(_key_CT_T1T11_allKeys):
            key_CT_T1T11.keys = _key_CT_T1T11_allKeys[-1].name  # just the last key pressed
            key_CT_T1T11.rt = _key_CT_T1T11_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T11.keys == str('1')) or (key_CT_T1T11.keys == '1'):
                key_CT_T1T11.corr = 1
            else:
                key_CT_T1T11.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T11* updates
    if phases_CT_T1T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T11.frameNStart = frameN  # exact frame index
        phases_CT_T1T11.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T11, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T11.setAutoDraw(True)
    if phases_CT_T1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T11.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T11.tStop = t  # not accounting for scr refresh
            phases_CT_T1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T11, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T11.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT1T11Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT1T11"-------
for thisComponent in CriterionTestT1T11Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththano3.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththano3.started', sound_ththano3.tStartRefresh)
thisExp.addData('sound_ththano3.stopped', sound_ththano3.tStopRefresh)
thisExp.addData('image_ththano3.started', image_ththano3.tStartRefresh)
thisExp.addData('image_ththano3.stopped', image_ththano3.tStopRefresh)
thisExp.addData('text_CT_T1T11.started', text_CT_T1T11.tStartRefresh)
thisExp.addData('text_CT_T1T11.stopped', text_CT_T1T11.tStopRefresh)
# check responses
if key_CT_T1T11.keys in ['', [], None]:  # No response was made
    key_CT_T1T11.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T1T11.corr = 1;  # correct non-response
    else:
       key_CT_T1T11.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T11.keys',key_CT_T1T11.keys)
thisExp.addData('key_CT_T1T11.corr', key_CT_T1T11.corr)
if key_CT_T1T11.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T11.rt', key_CT_T1T11.rt)
thisExp.addData('key_CT_T1T11.started', key_CT_T1T11.tStartRefresh)
thisExp.addData('key_CT_T1T11.stopped', key_CT_T1T11.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T11.started', phases_CT_T1T11.tStartRefresh)
thisExp.addData('phases_CT_T1T11.stopped', phases_CT_T1T11.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT1T12"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thami2.setSound('Sounds/thami.wav', hamming=True)
sound_thami2.setVolume(1, log=False)
key_CT_T1T12.keys = []
key_CT_T1T12.rt = []
_key_CT_T1T12_allKeys = []
# keep track of which components have finished
CriterionTestT1T12Components = [sound_thami2, image_ththuri2, text_CT_T1T12, key_CT_T1T12, phases_CT_T1T12]
for thisComponent in CriterionTestT1T12Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT1T12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT1T12"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT1T12Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT1T12Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thami2
    if sound_thami2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thami2.frameNStart = frameN  # exact frame index
        sound_thami2.tStart = t  # local t and not account for scr refresh
        sound_thami2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thami2.play(when=win)  # sync with win flip
    if sound_thami2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thami2.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thami2.tStop = t  # not accounting for scr refresh
            sound_thami2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thami2, 'tStopRefresh')  # time at next scr refresh
            sound_thami2.stop()
    
    # *image_ththuri2* updates
    if image_ththuri2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri2.frameNStart = frameN  # exact frame index
        image_ththuri2.tStart = t  # local t and not account for scr refresh
        image_ththuri2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri2, 'tStartRefresh')  # time at next scr refresh
        image_ththuri2.setAutoDraw(True)
    if image_ththuri2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri2.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri2.tStop = t  # not accounting for scr refresh
            image_ththuri2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri2, 'tStopRefresh')  # time at next scr refresh
            image_ththuri2.setAutoDraw(False)
    
    # *text_CT_T1T12* updates
    if text_CT_T1T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T1T12.frameNStart = frameN  # exact frame index
        text_CT_T1T12.tStart = t  # local t and not account for scr refresh
        text_CT_T1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T1T12, 'tStartRefresh')  # time at next scr refresh
        text_CT_T1T12.setAutoDraw(True)
    if text_CT_T1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T1T12.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T1T12.tStop = t  # not accounting for scr refresh
            text_CT_T1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T1T12, 'tStopRefresh')  # time at next scr refresh
            text_CT_T1T12.setAutoDraw(False)
    
    # *key_CT_T1T12* updates
    waitOnFlip = False
    if key_CT_T1T12.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T1T12.frameNStart = frameN  # exact frame index
        key_CT_T1T12.tStart = t  # local t and not account for scr refresh
        key_CT_T1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T1T12, 'tStartRefresh')  # time at next scr refresh
        key_CT_T1T12.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T1T12.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T1T12.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T1T12.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T1T12.tStop = t  # not accounting for scr refresh
            key_CT_T1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T1T12, 'tStopRefresh')  # time at next scr refresh
            key_CT_T1T12.status = FINISHED
    if key_CT_T1T12.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T1T12.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T1T12_allKeys.extend(theseKeys)
        if len(_key_CT_T1T12_allKeys):
            key_CT_T1T12.keys = _key_CT_T1T12_allKeys[-1].name  # just the last key pressed
            key_CT_T1T12.rt = _key_CT_T1T12_allKeys[-1].rt
            # was this correct?
            if (key_CT_T1T12.keys == str('0')) or (key_CT_T1T12.keys == '0'):
                key_CT_T1T12.corr = 1
            else:
                key_CT_T1T12.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T1T12* updates
    if phases_CT_T1T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T1T12.frameNStart = frameN  # exact frame index
        phases_CT_T1T12.tStart = t  # local t and not account for scr refresh
        phases_CT_T1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T1T12, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T1T12.setAutoDraw(True)
    if phases_CT_T1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T1T12.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T1T12.tStop = t  # not accounting for scr refresh
            phases_CT_T1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T1T12, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T1T12.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT1T12Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT1T12"-------
for thisComponent in CriterionTestT1T12Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thami2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thami2.started', sound_thami2.tStartRefresh)
thisExp.addData('sound_thami2.stopped', sound_thami2.tStopRefresh)
thisExp.addData('image_ththuri2.started', image_ththuri2.tStartRefresh)
thisExp.addData('image_ththuri2.stopped', image_ththuri2.tStopRefresh)
thisExp.addData('text_CT_T1T12.started', text_CT_T1T12.tStartRefresh)
thisExp.addData('text_CT_T1T12.stopped', text_CT_T1T12.tStopRefresh)
# check responses
if key_CT_T1T12.keys in ['', [], None]:  # No response was made
    key_CT_T1T12.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T1T12.corr = 1;  # correct non-response
    else:
       key_CT_T1T12.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T1T12.keys',key_CT_T1T12.keys)
thisExp.addData('key_CT_T1T12.corr', key_CT_T1T12.corr)
if key_CT_T1T12.keys != None:  # we had a response
    thisExp.addData('key_CT_T1T12.rt', key_CT_T1T12.rt)
thisExp.addData('key_CT_T1T12.started', key_CT_T1T12.tStartRefresh)
thisExp.addData('key_CT_T1T12.stopped', key_CT_T1T12.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T1T12.started', phases_CT_T1T12.tStartRefresh)
thisExp.addData('phases_CT_T1T12.stopped', phases_CT_T1T12.tStopRefresh)

# ------Prepare to start Routine "Phase3instructions2_2"-------
continueRoutine = True
# update component parameters for each repeat
key_CTinstructions2.keys = []
key_CTinstructions2.rt = []
_key_CTinstructions2_allKeys = []
# keep track of which components have finished
Phase3instructions2_2Components = [text_CTinstructions2, key_CTinstructions2]
for thisComponent in Phase3instructions2_2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase3instructions2_2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase3instructions2_2"-------
while continueRoutine:
    # get current time
    t = Phase3instructions2_2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase3instructions2_2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_CTinstructions2* updates
    if text_CTinstructions2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CTinstructions2.frameNStart = frameN  # exact frame index
        text_CTinstructions2.tStart = t  # local t and not account for scr refresh
        text_CTinstructions2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CTinstructions2, 'tStartRefresh')  # time at next scr refresh
        text_CTinstructions2.setAutoDraw(True)
    
    # *key_CTinstructions2* updates
    waitOnFlip = False
    if key_CTinstructions2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_CTinstructions2.frameNStart = frameN  # exact frame index
        key_CTinstructions2.tStart = t  # local t and not account for scr refresh
        key_CTinstructions2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CTinstructions2, 'tStartRefresh')  # time at next scr refresh
        key_CTinstructions2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CTinstructions2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CTinstructions2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CTinstructions2.status == STARTED and not waitOnFlip:
        theseKeys = key_CTinstructions2.getKeys(keyList=['space'], waitRelease=False)
        _key_CTinstructions2_allKeys.extend(theseKeys)
        if len(_key_CTinstructions2_allKeys):
            key_CTinstructions2.keys = _key_CTinstructions2_allKeys[-1].name  # just the last key pressed
            key_CTinstructions2.rt = _key_CTinstructions2_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase3instructions2_2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase3instructions2_2"-------
for thisComponent in Phase3instructions2_2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_CTinstructions2.started', text_CTinstructions2.tStartRefresh)
thisExp.addData('text_CTinstructions2.stopped', text_CTinstructions2.tStopRefresh)
# check responses
if key_CTinstructions2.keys in ['', [], None]:  # No response was made
    key_CTinstructions2.keys = None
thisExp.addData('key_CTinstructions2.keys',key_CTinstructions2.keys)
if key_CTinstructions2.keys != None:  # we had a response
    thisExp.addData('key_CTinstructions2.rt', key_CTinstructions2.rt)
thisExp.addData('key_CTinstructions2.started', key_CTinstructions2.tStartRefresh)
thisExp.addData('key_CTinstructions2.stopped', key_CTinstructions2.tStopRefresh)
thisExp.nextEntry()
# the Routine "Phase3instructions2_2" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "CriterionTestT2T1"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththuri4.setSound('Sounds/ththuri.wav', hamming=True)
sound_ththuri4.setVolume(1, log=False)
key_CT_T2T1.keys = []
key_CT_T2T1.rt = []
_key_CT_T2T1_allKeys = []
# keep track of which components have finished
CriterionTestT2T1Components = [image_ththuri4, image_thano4, text_CT_T2T1_1, text_CT_T2T1_0, sound_ththuri4, text_CT_T2T1, key_CT_T2T1, phases_CT_T2T1]
for thisComponent in CriterionTestT2T1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T1"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththuri4* updates
    if image_ththuri4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri4.frameNStart = frameN  # exact frame index
        image_ththuri4.tStart = t  # local t and not account for scr refresh
        image_ththuri4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri4, 'tStartRefresh')  # time at next scr refresh
        image_ththuri4.setAutoDraw(True)
    if image_ththuri4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri4.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri4.tStop = t  # not accounting for scr refresh
            image_ththuri4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri4, 'tStopRefresh')  # time at next scr refresh
            image_ththuri4.setAutoDraw(False)
    
    # *image_thano4* updates
    if image_thano4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano4.frameNStart = frameN  # exact frame index
        image_thano4.tStart = t  # local t and not account for scr refresh
        image_thano4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano4, 'tStartRefresh')  # time at next scr refresh
        image_thano4.setAutoDraw(True)
    if image_thano4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano4.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano4.tStop = t  # not accounting for scr refresh
            image_thano4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano4, 'tStopRefresh')  # time at next scr refresh
            image_thano4.setAutoDraw(False)
    
    # *text_CT_T2T1_1* updates
    if text_CT_T2T1_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T1_1.frameNStart = frameN  # exact frame index
        text_CT_T2T1_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T1_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T1_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T1_1.setAutoDraw(True)
    if text_CT_T2T1_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T1_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T1_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T1_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T1_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T1_1.setAutoDraw(False)
    
    # *text_CT_T2T1_0* updates
    if text_CT_T2T1_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T1_0.frameNStart = frameN  # exact frame index
        text_CT_T2T1_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T1_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T1_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T1_0.setAutoDraw(True)
    if text_CT_T2T1_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T1_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T1_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T1_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T1_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T1_0.setAutoDraw(False)
    # start/stop sound_ththuri4
    if sound_ththuri4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththuri4.frameNStart = frameN  # exact frame index
        sound_ththuri4.tStart = t  # local t and not account for scr refresh
        sound_ththuri4.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththuri4.play(when=win)  # sync with win flip
    if sound_ththuri4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththuri4.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththuri4.tStop = t  # not accounting for scr refresh
            sound_ththuri4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththuri4, 'tStopRefresh')  # time at next scr refresh
            sound_ththuri4.stop()
    
    # *text_CT_T2T1* updates
    if text_CT_T2T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T1.frameNStart = frameN  # exact frame index
        text_CT_T2T1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T1.setAutoDraw(True)
    if text_CT_T2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T1.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T1.tStop = t  # not accounting for scr refresh
            text_CT_T2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T1.setAutoDraw(False)
    
    # *key_CT_T2T1* updates
    waitOnFlip = False
    if key_CT_T2T1.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T1.frameNStart = frameN  # exact frame index
        key_CT_T2T1.tStart = t  # local t and not account for scr refresh
        key_CT_T2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T1, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T1.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T1.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T1.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T1.tStop = t  # not accounting for scr refresh
            key_CT_T2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T1, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T1.status = FINISHED
    if key_CT_T2T1.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T1.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T1_allKeys.extend(theseKeys)
        if len(_key_CT_T2T1_allKeys):
            key_CT_T2T1.keys = _key_CT_T2T1_allKeys[-1].name  # just the last key pressed
            key_CT_T2T1.rt = _key_CT_T2T1_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T1.keys == str('1')) or (key_CT_T2T1.keys == '1'):
                key_CT_T2T1.corr = 1
            else:
                key_CT_T2T1.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T1* updates
    if phases_CT_T2T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T1.frameNStart = frameN  # exact frame index
        phases_CT_T2T1.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T1, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T1.setAutoDraw(True)
    if phases_CT_T2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T1.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T1.tStop = t  # not accounting for scr refresh
            phases_CT_T2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T1, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T1.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T1"-------
for thisComponent in CriterionTestT2T1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththuri4.started', image_ththuri4.tStartRefresh)
thisExp.addData('image_ththuri4.stopped', image_ththuri4.tStopRefresh)
thisExp.addData('image_thano4.started', image_thano4.tStartRefresh)
thisExp.addData('image_thano4.stopped', image_thano4.tStopRefresh)
thisExp.addData('text_CT_T2T1_1.started', text_CT_T2T1_1.tStartRefresh)
thisExp.addData('text_CT_T2T1_1.stopped', text_CT_T2T1_1.tStopRefresh)
thisExp.addData('text_CT_T2T1_0.started', text_CT_T2T1_0.tStartRefresh)
thisExp.addData('text_CT_T2T1_0.stopped', text_CT_T2T1_0.tStopRefresh)
sound_ththuri4.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththuri4.started', sound_ththuri4.tStartRefresh)
thisExp.addData('sound_ththuri4.stopped', sound_ththuri4.tStopRefresh)
thisExp.addData('text_CT_T2T1.started', text_CT_T2T1.tStartRefresh)
thisExp.addData('text_CT_T2T1.stopped', text_CT_T2T1.tStopRefresh)
# check responses
if key_CT_T2T1.keys in ['', [], None]:  # No response was made
    key_CT_T2T1.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T2T1.corr = 1;  # correct non-response
    else:
       key_CT_T2T1.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T1.keys',key_CT_T2T1.keys)
thisExp.addData('key_CT_T2T1.corr', key_CT_T2T1.corr)
if key_CT_T2T1.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T1.rt', key_CT_T2T1.rt)
thisExp.addData('key_CT_T2T1.started', key_CT_T2T1.tStartRefresh)
thisExp.addData('key_CT_T2T1.stopped', key_CT_T2T1.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T1.started', phases_CT_T2T1.tStartRefresh)
thisExp.addData('phases_CT_T2T1.stopped', phases_CT_T2T1.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT2T2"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththami4.setSound('Sounds/ththami.wav', hamming=True)
sound_ththami4.setVolume(1, log=False)
key_CT_T2T2.keys = []
key_CT_T2T2.rt = []
_key_CT_T2T2_allKeys = []
# keep track of which components have finished
CriterionTestT2T2Components = [image_thuri4, image_ththami4, text_CT_T2T2_1, text_CT_T2T2_0, sound_ththami4, text_CT_T2T2, key_CT_T2T2, CT_T2T2]
for thisComponent in CriterionTestT2T2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T2"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_thuri4* updates
    if image_thuri4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri4.frameNStart = frameN  # exact frame index
        image_thuri4.tStart = t  # local t and not account for scr refresh
        image_thuri4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri4, 'tStartRefresh')  # time at next scr refresh
        image_thuri4.setAutoDraw(True)
    if image_thuri4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri4.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri4.tStop = t  # not accounting for scr refresh
            image_thuri4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri4, 'tStopRefresh')  # time at next scr refresh
            image_thuri4.setAutoDraw(False)
    
    # *image_ththami4* updates
    if image_ththami4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami4.frameNStart = frameN  # exact frame index
        image_ththami4.tStart = t  # local t and not account for scr refresh
        image_ththami4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami4, 'tStartRefresh')  # time at next scr refresh
        image_ththami4.setAutoDraw(True)
    if image_ththami4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami4.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami4.tStop = t  # not accounting for scr refresh
            image_ththami4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami4, 'tStopRefresh')  # time at next scr refresh
            image_ththami4.setAutoDraw(False)
    
    # *text_CT_T2T2_1* updates
    if text_CT_T2T2_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T2_1.frameNStart = frameN  # exact frame index
        text_CT_T2T2_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T2_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T2_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T2_1.setAutoDraw(True)
    if text_CT_T2T2_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T2_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T2_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T2_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T2_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T2_1.setAutoDraw(False)
    
    # *text_CT_T2T2_0* updates
    if text_CT_T2T2_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T2_0.frameNStart = frameN  # exact frame index
        text_CT_T2T2_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T2_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T2_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T2_0.setAutoDraw(True)
    if text_CT_T2T2_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T2_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T2_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T2_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T2_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T2_0.setAutoDraw(False)
    # start/stop sound_ththami4
    if sound_ththami4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththami4.frameNStart = frameN  # exact frame index
        sound_ththami4.tStart = t  # local t and not account for scr refresh
        sound_ththami4.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththami4.play(when=win)  # sync with win flip
    if sound_ththami4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththami4.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththami4.tStop = t  # not accounting for scr refresh
            sound_ththami4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththami4, 'tStopRefresh')  # time at next scr refresh
            sound_ththami4.stop()
    
    # *text_CT_T2T2* updates
    if text_CT_T2T2.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T2.frameNStart = frameN  # exact frame index
        text_CT_T2T2.tStart = t  # local t and not account for scr refresh
        text_CT_T2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T2, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T2.setAutoDraw(True)
    if text_CT_T2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T2.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T2.tStop = t  # not accounting for scr refresh
            text_CT_T2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T2, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T2.setAutoDraw(False)
    
    # *key_CT_T2T2* updates
    waitOnFlip = False
    if key_CT_T2T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T2.frameNStart = frameN  # exact frame index
        key_CT_T2T2.tStart = t  # local t and not account for scr refresh
        key_CT_T2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T2, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T2.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T2.tStop = t  # not accounting for scr refresh
            key_CT_T2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T2, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T2.status = FINISHED
    if key_CT_T2T2.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T2.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T2_allKeys.extend(theseKeys)
        if len(_key_CT_T2T2_allKeys):
            key_CT_T2T2.keys = _key_CT_T2T2_allKeys[-1].name  # just the last key pressed
            key_CT_T2T2.rt = _key_CT_T2T2_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T2.keys == str('0')) or (key_CT_T2T2.keys == '0'):
                key_CT_T2T2.corr = 1
            else:
                key_CT_T2T2.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *CT_T2T2* updates
    if CT_T2T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        CT_T2T2.frameNStart = frameN  # exact frame index
        CT_T2T2.tStart = t  # local t and not account for scr refresh
        CT_T2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(CT_T2T2, 'tStartRefresh')  # time at next scr refresh
        CT_T2T2.setAutoDraw(True)
    if CT_T2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > CT_T2T2.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            CT_T2T2.tStop = t  # not accounting for scr refresh
            CT_T2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(CT_T2T2, 'tStopRefresh')  # time at next scr refresh
            CT_T2T2.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T2"-------
for thisComponent in CriterionTestT2T2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_thuri4.started', image_thuri4.tStartRefresh)
thisExp.addData('image_thuri4.stopped', image_thuri4.tStopRefresh)
thisExp.addData('image_ththami4.started', image_ththami4.tStartRefresh)
thisExp.addData('image_ththami4.stopped', image_ththami4.tStopRefresh)
thisExp.addData('text_CT_T2T2_1.started', text_CT_T2T2_1.tStartRefresh)
thisExp.addData('text_CT_T2T2_1.stopped', text_CT_T2T2_1.tStopRefresh)
thisExp.addData('text_CT_T2T2_0.started', text_CT_T2T2_0.tStartRefresh)
thisExp.addData('text_CT_T2T2_0.stopped', text_CT_T2T2_0.tStopRefresh)
sound_ththami4.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththami4.started', sound_ththami4.tStartRefresh)
thisExp.addData('sound_ththami4.stopped', sound_ththami4.tStopRefresh)
thisExp.addData('text_CT_T2T2.started', text_CT_T2T2.tStartRefresh)
thisExp.addData('text_CT_T2T2.stopped', text_CT_T2T2.tStopRefresh)
# check responses
if key_CT_T2T2.keys in ['', [], None]:  # No response was made
    key_CT_T2T2.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T2T2.corr = 1;  # correct non-response
    else:
       key_CT_T2T2.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T2.keys',key_CT_T2T2.keys)
thisExp.addData('key_CT_T2T2.corr', key_CT_T2T2.corr)
if key_CT_T2T2.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T2.rt', key_CT_T2T2.rt)
thisExp.addData('key_CT_T2T2.started', key_CT_T2T2.tStartRefresh)
thisExp.addData('key_CT_T2T2.stopped', key_CT_T2T2.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('CT_T2T2.started', CT_T2T2.tStartRefresh)
thisExp.addData('CT_T2T2.stopped', CT_T2T2.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT2T3"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththano4.setSound('Sounds/ththano.wav', hamming=True)
sound_ththano4.setVolume(1, log=False)
key_CT_T2T3.keys = []
key_CT_T2T3.rt = []
_key_CT_T2T3_allKeys = []
# keep track of which components have finished
CriterionTestT2T3Components = [image_ththano4, image_thami4, text_CT_T2T3_1, text_CT_T2T3_0, sound_ththano4, text_CT_T2T3, key_CT_T2T3, phases_CT_T2T3]
for thisComponent in CriterionTestT2T3Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T3"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T3Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T3Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththano4* updates
    if image_ththano4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano4.frameNStart = frameN  # exact frame index
        image_ththano4.tStart = t  # local t and not account for scr refresh
        image_ththano4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano4, 'tStartRefresh')  # time at next scr refresh
        image_ththano4.setAutoDraw(True)
    if image_ththano4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano4.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano4.tStop = t  # not accounting for scr refresh
            image_ththano4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano4, 'tStopRefresh')  # time at next scr refresh
            image_ththano4.setAutoDraw(False)
    
    # *image_thami4* updates
    if image_thami4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami4.frameNStart = frameN  # exact frame index
        image_thami4.tStart = t  # local t and not account for scr refresh
        image_thami4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami4, 'tStartRefresh')  # time at next scr refresh
        image_thami4.setAutoDraw(True)
    if image_thami4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami4.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami4.tStop = t  # not accounting for scr refresh
            image_thami4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami4, 'tStopRefresh')  # time at next scr refresh
            image_thami4.setAutoDraw(False)
    
    # *text_CT_T2T3_1* updates
    if text_CT_T2T3_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T3_1.frameNStart = frameN  # exact frame index
        text_CT_T2T3_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T3_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T3_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T3_1.setAutoDraw(True)
    if text_CT_T2T3_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T3_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T3_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T3_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T3_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T3_1.setAutoDraw(False)
    
    # *text_CT_T2T3_0* updates
    if text_CT_T2T3_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T3_0.frameNStart = frameN  # exact frame index
        text_CT_T2T3_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T3_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T3_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T3_0.setAutoDraw(True)
    if text_CT_T2T3_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T3_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T3_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T3_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T3_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T3_0.setAutoDraw(False)
    # start/stop sound_ththano4
    if sound_ththano4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththano4.frameNStart = frameN  # exact frame index
        sound_ththano4.tStart = t  # local t and not account for scr refresh
        sound_ththano4.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththano4.play(when=win)  # sync with win flip
    if sound_ththano4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththano4.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththano4.tStop = t  # not accounting for scr refresh
            sound_ththano4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththano4, 'tStopRefresh')  # time at next scr refresh
            sound_ththano4.stop()
    
    # *text_CT_T2T3* updates
    if text_CT_T2T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T3.frameNStart = frameN  # exact frame index
        text_CT_T2T3.tStart = t  # local t and not account for scr refresh
        text_CT_T2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T3, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T3.setAutoDraw(True)
    if text_CT_T2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T3.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T3.tStop = t  # not accounting for scr refresh
            text_CT_T2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T3, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T3.setAutoDraw(False)
    
    # *key_CT_T2T3* updates
    waitOnFlip = False
    if key_CT_T2T3.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T3.frameNStart = frameN  # exact frame index
        key_CT_T2T3.tStart = t  # local t and not account for scr refresh
        key_CT_T2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T3, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T3.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T3.tStop = t  # not accounting for scr refresh
            key_CT_T2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T3, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T3.status = FINISHED
    if key_CT_T2T3.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T3.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T3_allKeys.extend(theseKeys)
        if len(_key_CT_T2T3_allKeys):
            key_CT_T2T3.keys = _key_CT_T2T3_allKeys[-1].name  # just the last key pressed
            key_CT_T2T3.rt = _key_CT_T2T3_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T3.keys == str('1')) or (key_CT_T2T3.keys == '1'):
                key_CT_T2T3.corr = 1
            else:
                key_CT_T2T3.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T3* updates
    if phases_CT_T2T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T3.frameNStart = frameN  # exact frame index
        phases_CT_T2T3.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T3, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T3.setAutoDraw(True)
    if phases_CT_T2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T3.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T3.tStop = t  # not accounting for scr refresh
            phases_CT_T2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T3, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T3.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T3Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T3"-------
for thisComponent in CriterionTestT2T3Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththano4.started', image_ththano4.tStartRefresh)
thisExp.addData('image_ththano4.stopped', image_ththano4.tStopRefresh)
thisExp.addData('image_thami4.started', image_thami4.tStartRefresh)
thisExp.addData('image_thami4.stopped', image_thami4.tStopRefresh)
thisExp.addData('text_CT_T2T3_1.started', text_CT_T2T3_1.tStartRefresh)
thisExp.addData('text_CT_T2T3_1.stopped', text_CT_T2T3_1.tStopRefresh)
thisExp.addData('text_CT_T2T3_0.started', text_CT_T2T3_0.tStartRefresh)
thisExp.addData('text_CT_T2T3_0.stopped', text_CT_T2T3_0.tStopRefresh)
sound_ththano4.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththano4.started', sound_ththano4.tStartRefresh)
thisExp.addData('sound_ththano4.stopped', sound_ththano4.tStopRefresh)
thisExp.addData('text_CT_T2T3.started', text_CT_T2T3.tStartRefresh)
thisExp.addData('text_CT_T2T3.stopped', text_CT_T2T3.tStopRefresh)
# check responses
if key_CT_T2T3.keys in ['', [], None]:  # No response was made
    key_CT_T2T3.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T2T3.corr = 1;  # correct non-response
    else:
       key_CT_T2T3.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T3.keys',key_CT_T2T3.keys)
thisExp.addData('key_CT_T2T3.corr', key_CT_T2T3.corr)
if key_CT_T2T3.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T3.rt', key_CT_T2T3.rt)
thisExp.addData('key_CT_T2T3.started', key_CT_T2T3.tStartRefresh)
thisExp.addData('key_CT_T2T3.stopped', key_CT_T2T3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T3.started', phases_CT_T2T3.tStartRefresh)
thisExp.addData('phases_CT_T2T3.stopped', phases_CT_T2T3.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT3T4"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththami5.setSound('Sounds/ththami.wav', hamming=True)
sound_ththami5.setVolume(1, log=False)
key_CT_T2T4.keys = []
key_CT_T2T4.rt = []
_key_CT_T2T4_allKeys = []
# keep track of which components have finished
CriterionTestT3T4Components = [image_ththami5, image_thano5, text_CT_T2T4_1, text_CT_T2T4_0, sound_ththami5, text_CT_T2T4, key_CT_T2T4, phases_CT_T2T4]
for thisComponent in CriterionTestT3T4Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT3T4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT3T4"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT3T4Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT3T4Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththami5* updates
    if image_ththami5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami5.frameNStart = frameN  # exact frame index
        image_ththami5.tStart = t  # local t and not account for scr refresh
        image_ththami5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami5, 'tStartRefresh')  # time at next scr refresh
        image_ththami5.setAutoDraw(True)
    if image_ththami5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami5.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami5.tStop = t  # not accounting for scr refresh
            image_ththami5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami5, 'tStopRefresh')  # time at next scr refresh
            image_ththami5.setAutoDraw(False)
    
    # *image_thano5* updates
    if image_thano5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano5.frameNStart = frameN  # exact frame index
        image_thano5.tStart = t  # local t and not account for scr refresh
        image_thano5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano5, 'tStartRefresh')  # time at next scr refresh
        image_thano5.setAutoDraw(True)
    if image_thano5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano5.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano5.tStop = t  # not accounting for scr refresh
            image_thano5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano5, 'tStopRefresh')  # time at next scr refresh
            image_thano5.setAutoDraw(False)
    
    # *text_CT_T2T4_1* updates
    if text_CT_T2T4_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T4_1.frameNStart = frameN  # exact frame index
        text_CT_T2T4_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T4_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T4_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T4_1.setAutoDraw(True)
    if text_CT_T2T4_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T4_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T4_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T4_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T4_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T4_1.setAutoDraw(False)
    
    # *text_CT_T2T4_0* updates
    if text_CT_T2T4_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T4_0.frameNStart = frameN  # exact frame index
        text_CT_T2T4_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T4_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T4_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T4_0.setAutoDraw(True)
    if text_CT_T2T4_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T4_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T4_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T4_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T4_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T4_0.setAutoDraw(False)
    # start/stop sound_ththami5
    if sound_ththami5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththami5.frameNStart = frameN  # exact frame index
        sound_ththami5.tStart = t  # local t and not account for scr refresh
        sound_ththami5.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththami5.play(when=win)  # sync with win flip
    if sound_ththami5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththami5.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththami5.tStop = t  # not accounting for scr refresh
            sound_ththami5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththami5, 'tStopRefresh')  # time at next scr refresh
            sound_ththami5.stop()
    
    # *text_CT_T2T4* updates
    if text_CT_T2T4.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T4.frameNStart = frameN  # exact frame index
        text_CT_T2T4.tStart = t  # local t and not account for scr refresh
        text_CT_T2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T4, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T4.setAutoDraw(True)
    if text_CT_T2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T4.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T4.tStop = t  # not accounting for scr refresh
            text_CT_T2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T4, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T4.setAutoDraw(False)
    
    # *key_CT_T2T4* updates
    waitOnFlip = False
    if key_CT_T2T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T4.frameNStart = frameN  # exact frame index
        key_CT_T2T4.tStart = t  # local t and not account for scr refresh
        key_CT_T2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T4, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T4.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T4.tStop = t  # not accounting for scr refresh
            key_CT_T2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T4, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T4.status = FINISHED
    if key_CT_T2T4.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T4.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T4_allKeys.extend(theseKeys)
        if len(_key_CT_T2T4_allKeys):
            key_CT_T2T4.keys = _key_CT_T2T4_allKeys[-1].name  # just the last key pressed
            key_CT_T2T4.rt = _key_CT_T2T4_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T4.keys == str('1')) or (key_CT_T2T4.keys == '1'):
                key_CT_T2T4.corr = 1
            else:
                key_CT_T2T4.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T4* updates
    if phases_CT_T2T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T4.frameNStart = frameN  # exact frame index
        phases_CT_T2T4.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T4, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T4.setAutoDraw(True)
    if phases_CT_T2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T4.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T4.tStop = t  # not accounting for scr refresh
            phases_CT_T2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T4, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T4.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT3T4Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT3T4"-------
for thisComponent in CriterionTestT3T4Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththami5.started', image_ththami5.tStartRefresh)
thisExp.addData('image_ththami5.stopped', image_ththami5.tStopRefresh)
thisExp.addData('image_thano5.started', image_thano5.tStartRefresh)
thisExp.addData('image_thano5.stopped', image_thano5.tStopRefresh)
thisExp.addData('text_CT_T2T4_1.started', text_CT_T2T4_1.tStartRefresh)
thisExp.addData('text_CT_T2T4_1.stopped', text_CT_T2T4_1.tStopRefresh)
thisExp.addData('text_CT_T2T4_0.started', text_CT_T2T4_0.tStartRefresh)
thisExp.addData('text_CT_T2T4_0.stopped', text_CT_T2T4_0.tStopRefresh)
sound_ththami5.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththami5.started', sound_ththami5.tStartRefresh)
thisExp.addData('sound_ththami5.stopped', sound_ththami5.tStopRefresh)
thisExp.addData('text_CT_T2T4.started', text_CT_T2T4.tStartRefresh)
thisExp.addData('text_CT_T2T4.stopped', text_CT_T2T4.tStopRefresh)
# check responses
if key_CT_T2T4.keys in ['', [], None]:  # No response was made
    key_CT_T2T4.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T2T4.corr = 1;  # correct non-response
    else:
       key_CT_T2T4.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T4.keys',key_CT_T2T4.keys)
thisExp.addData('key_CT_T2T4.corr', key_CT_T2T4.corr)
if key_CT_T2T4.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T4.rt', key_CT_T2T4.rt)
thisExp.addData('key_CT_T2T4.started', key_CT_T2T4.tStartRefresh)
thisExp.addData('key_CT_T2T4.stopped', key_CT_T2T4.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T4.started', phases_CT_T2T4.tStartRefresh)
thisExp.addData('phases_CT_T2T4.stopped', phases_CT_T2T4.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT2T5"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththuri5.setSound('Sounds/ththuri.wav', hamming=True)
sound_ththuri5.setVolume(1, log=False)
key_CT_T2T5.keys = []
key_CT_T2T5.rt = []
_key_CT_T2T5_allKeys = []
# keep track of which components have finished
CriterionTestT2T5Components = [image_thami5, image_ththuri5, text_CT_T2T5_1, text_CT_T2T5_0, sound_ththuri5, text_CT_T2T5, key_CT_T2T5, phases_CT_T2T5]
for thisComponent in CriterionTestT2T5Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T5"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T5Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T5Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_thami5* updates
    if image_thami5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami5.frameNStart = frameN  # exact frame index
        image_thami5.tStart = t  # local t and not account for scr refresh
        image_thami5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami5, 'tStartRefresh')  # time at next scr refresh
        image_thami5.setAutoDraw(True)
    if image_thami5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami5.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami5.tStop = t  # not accounting for scr refresh
            image_thami5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami5, 'tStopRefresh')  # time at next scr refresh
            image_thami5.setAutoDraw(False)
    
    # *image_ththuri5* updates
    if image_ththuri5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri5.frameNStart = frameN  # exact frame index
        image_ththuri5.tStart = t  # local t and not account for scr refresh
        image_ththuri5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri5, 'tStartRefresh')  # time at next scr refresh
        image_ththuri5.setAutoDraw(True)
    if image_ththuri5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri5.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri5.tStop = t  # not accounting for scr refresh
            image_ththuri5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri5, 'tStopRefresh')  # time at next scr refresh
            image_ththuri5.setAutoDraw(False)
    
    # *text_CT_T2T5_1* updates
    if text_CT_T2T5_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T5_1.frameNStart = frameN  # exact frame index
        text_CT_T2T5_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T5_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T5_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T5_1.setAutoDraw(True)
    if text_CT_T2T5_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T5_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T5_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T5_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T5_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T5_1.setAutoDraw(False)
    
    # *text_CT_T2T5_0* updates
    if text_CT_T2T5_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T5_0.frameNStart = frameN  # exact frame index
        text_CT_T2T5_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T5_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T5_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T5_0.setAutoDraw(True)
    if text_CT_T2T5_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T5_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T5_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T5_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T5_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T5_0.setAutoDraw(False)
    # start/stop sound_ththuri5
    if sound_ththuri5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththuri5.frameNStart = frameN  # exact frame index
        sound_ththuri5.tStart = t  # local t and not account for scr refresh
        sound_ththuri5.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththuri5.play(when=win)  # sync with win flip
    if sound_ththuri5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththuri5.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththuri5.tStop = t  # not accounting for scr refresh
            sound_ththuri5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththuri5, 'tStopRefresh')  # time at next scr refresh
            sound_ththuri5.stop()
    
    # *text_CT_T2T5* updates
    if text_CT_T2T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T5.frameNStart = frameN  # exact frame index
        text_CT_T2T5.tStart = t  # local t and not account for scr refresh
        text_CT_T2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T5, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T5.setAutoDraw(True)
    if text_CT_T2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T5.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T5.tStop = t  # not accounting for scr refresh
            text_CT_T2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T5, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T5.setAutoDraw(False)
    
    # *key_CT_T2T5* updates
    waitOnFlip = False
    if key_CT_T2T5.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T5.frameNStart = frameN  # exact frame index
        key_CT_T2T5.tStart = t  # local t and not account for scr refresh
        key_CT_T2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T5, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T5.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T5.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T5.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T5.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T5.tStop = t  # not accounting for scr refresh
            key_CT_T2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T5, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T5.status = FINISHED
    if key_CT_T2T5.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T5.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T5_allKeys.extend(theseKeys)
        if len(_key_CT_T2T5_allKeys):
            key_CT_T2T5.keys = _key_CT_T2T5_allKeys[-1].name  # just the last key pressed
            key_CT_T2T5.rt = _key_CT_T2T5_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T5.keys == str('0')) or (key_CT_T2T5.keys == '0'):
                key_CT_T2T5.corr = 1
            else:
                key_CT_T2T5.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T5* updates
    if phases_CT_T2T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T5.frameNStart = frameN  # exact frame index
        phases_CT_T2T5.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T5, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T5.setAutoDraw(True)
    if phases_CT_T2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T5.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T5.tStop = t  # not accounting for scr refresh
            phases_CT_T2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T5, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T5.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T5Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T5"-------
for thisComponent in CriterionTestT2T5Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_thami5.started', image_thami5.tStartRefresh)
thisExp.addData('image_thami5.stopped', image_thami5.tStopRefresh)
thisExp.addData('image_ththuri5.started', image_ththuri5.tStartRefresh)
thisExp.addData('image_ththuri5.stopped', image_ththuri5.tStopRefresh)
thisExp.addData('text_CT_T2T5_1.started', text_CT_T2T5_1.tStartRefresh)
thisExp.addData('text_CT_T2T5_1.stopped', text_CT_T2T5_1.tStopRefresh)
thisExp.addData('text_CT_T2T5_0.started', text_CT_T2T5_0.tStartRefresh)
thisExp.addData('text_CT_T2T5_0.stopped', text_CT_T2T5_0.tStopRefresh)
sound_ththuri5.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththuri5.started', sound_ththuri5.tStartRefresh)
thisExp.addData('sound_ththuri5.stopped', sound_ththuri5.tStopRefresh)
thisExp.addData('text_CT_T2T5.started', text_CT_T2T5.tStartRefresh)
thisExp.addData('text_CT_T2T5.stopped', text_CT_T2T5.tStopRefresh)
# check responses
if key_CT_T2T5.keys in ['', [], None]:  # No response was made
    key_CT_T2T5.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T2T5.corr = 1;  # correct non-response
    else:
       key_CT_T2T5.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T5.keys',key_CT_T2T5.keys)
thisExp.addData('key_CT_T2T5.corr', key_CT_T2T5.corr)
if key_CT_T2T5.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T5.rt', key_CT_T2T5.rt)
thisExp.addData('key_CT_T2T5.started', key_CT_T2T5.tStartRefresh)
thisExp.addData('key_CT_T2T5.stopped', key_CT_T2T5.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T5.started', phases_CT_T2T5.tStartRefresh)
thisExp.addData('phases_CT_T2T5.stopped', phases_CT_T2T5.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT2T6"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththano5.setSound('Sounds/ththano.wav', hamming=True)
sound_ththano5.setVolume(1, log=False)
key_CT_T2T6.keys = []
key_CT_T2T6.rt = []
_key_CT_T2T6_allKeys = []
# keep track of which components have finished
CriterionTestT2T6Components = [image_ththano5, image_thuri5, text_CT_T2T6_1, text_CT_T2T6_0, sound_ththano5, text_CT_T2T6, key_CT_T2T6, phases_CT_T2T6]
for thisComponent in CriterionTestT2T6Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T6"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T6Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T6Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththano5* updates
    if image_ththano5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano5.frameNStart = frameN  # exact frame index
        image_ththano5.tStart = t  # local t and not account for scr refresh
        image_ththano5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano5, 'tStartRefresh')  # time at next scr refresh
        image_ththano5.setAutoDraw(True)
    if image_ththano5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano5.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano5.tStop = t  # not accounting for scr refresh
            image_ththano5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano5, 'tStopRefresh')  # time at next scr refresh
            image_ththano5.setAutoDraw(False)
    
    # *image_thuri5* updates
    if image_thuri5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri5.frameNStart = frameN  # exact frame index
        image_thuri5.tStart = t  # local t and not account for scr refresh
        image_thuri5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri5, 'tStartRefresh')  # time at next scr refresh
        image_thuri5.setAutoDraw(True)
    if image_thuri5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri5.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri5.tStop = t  # not accounting for scr refresh
            image_thuri5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri5, 'tStopRefresh')  # time at next scr refresh
            image_thuri5.setAutoDraw(False)
    
    # *text_CT_T2T6_1* updates
    if text_CT_T2T6_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T6_1.frameNStart = frameN  # exact frame index
        text_CT_T2T6_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T6_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T6_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T6_1.setAutoDraw(True)
    if text_CT_T2T6_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T6_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T6_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T6_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T6_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T6_1.setAutoDraw(False)
    
    # *text_CT_T2T6_0* updates
    if text_CT_T2T6_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T6_0.frameNStart = frameN  # exact frame index
        text_CT_T2T6_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T6_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T6_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T6_0.setAutoDraw(True)
    if text_CT_T2T6_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T6_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T6_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T6_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T6_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T6_0.setAutoDraw(False)
    # start/stop sound_ththano5
    if sound_ththano5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththano5.frameNStart = frameN  # exact frame index
        sound_ththano5.tStart = t  # local t and not account for scr refresh
        sound_ththano5.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththano5.play(when=win)  # sync with win flip
    if sound_ththano5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththano5.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththano5.tStop = t  # not accounting for scr refresh
            sound_ththano5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththano5, 'tStopRefresh')  # time at next scr refresh
            sound_ththano5.stop()
    
    # *text_CT_T2T6* updates
    if text_CT_T2T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T6.frameNStart = frameN  # exact frame index
        text_CT_T2T6.tStart = t  # local t and not account for scr refresh
        text_CT_T2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T6, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T6.setAutoDraw(True)
    if text_CT_T2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T6.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T6.tStop = t  # not accounting for scr refresh
            text_CT_T2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T6, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T6.setAutoDraw(False)
    
    # *key_CT_T2T6* updates
    waitOnFlip = False
    if key_CT_T2T6.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T6.frameNStart = frameN  # exact frame index
        key_CT_T2T6.tStart = t  # local t and not account for scr refresh
        key_CT_T2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T6, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T6.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T6.tStop = t  # not accounting for scr refresh
            key_CT_T2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T6, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T6.status = FINISHED
    if key_CT_T2T6.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T6.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T6_allKeys.extend(theseKeys)
        if len(_key_CT_T2T6_allKeys):
            key_CT_T2T6.keys = _key_CT_T2T6_allKeys[-1].name  # just the last key pressed
            key_CT_T2T6.rt = _key_CT_T2T6_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T6.keys == str('1')) or (key_CT_T2T6.keys == '1'):
                key_CT_T2T6.corr = 1
            else:
                key_CT_T2T6.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T6* updates
    if phases_CT_T2T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T6.frameNStart = frameN  # exact frame index
        phases_CT_T2T6.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T6, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T6.setAutoDraw(True)
    if phases_CT_T2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T6.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T6.tStop = t  # not accounting for scr refresh
            phases_CT_T2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T6, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T6.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T6Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T6"-------
for thisComponent in CriterionTestT2T6Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththano5.started', image_ththano5.tStartRefresh)
thisExp.addData('image_ththano5.stopped', image_ththano5.tStopRefresh)
thisExp.addData('image_thuri5.started', image_thuri5.tStartRefresh)
thisExp.addData('image_thuri5.stopped', image_thuri5.tStopRefresh)
thisExp.addData('text_CT_T2T6_1.started', text_CT_T2T6_1.tStartRefresh)
thisExp.addData('text_CT_T2T6_1.stopped', text_CT_T2T6_1.tStopRefresh)
thisExp.addData('text_CT_T2T6_0.started', text_CT_T2T6_0.tStartRefresh)
thisExp.addData('text_CT_T2T6_0.stopped', text_CT_T2T6_0.tStopRefresh)
sound_ththano5.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththano5.started', sound_ththano5.tStartRefresh)
thisExp.addData('sound_ththano5.stopped', sound_ththano5.tStopRefresh)
thisExp.addData('text_CT_T2T6.started', text_CT_T2T6.tStartRefresh)
thisExp.addData('text_CT_T2T6.stopped', text_CT_T2T6.tStopRefresh)
# check responses
if key_CT_T2T6.keys in ['', [], None]:  # No response was made
    key_CT_T2T6.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T2T6.corr = 1;  # correct non-response
    else:
       key_CT_T2T6.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T6.keys',key_CT_T2T6.keys)
thisExp.addData('key_CT_T2T6.corr', key_CT_T2T6.corr)
if key_CT_T2T6.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T6.rt', key_CT_T2T6.rt)
thisExp.addData('key_CT_T2T6.started', key_CT_T2T6.tStartRefresh)
thisExp.addData('key_CT_T2T6.stopped', key_CT_T2T6.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T6.started', phases_CT_T2T6.tStartRefresh)
thisExp.addData('phases_CT_T2T6.stopped', phases_CT_T2T6.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT2T7"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thuri5.setSound('Sounds/thuri.wav', hamming=True)
sound_thuri5.setVolume(1, log=False)
key_CT_T2T7.keys = []
key_CT_T2T7.rt = []
_key_CT_T2T7_allKeys = []
# keep track of which components have finished
CriterionTestT2T7Components = [image_ththami6, image_thuri6, text_CT_T2T7_1, text_CT_T2T7_0, sound_thuri5, text_CT_T2T7, key_CT_T2T7, phases_CT_T2T7]
for thisComponent in CriterionTestT2T7Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T7"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T7Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T7Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththami6* updates
    if image_ththami6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami6.frameNStart = frameN  # exact frame index
        image_ththami6.tStart = t  # local t and not account for scr refresh
        image_ththami6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami6, 'tStartRefresh')  # time at next scr refresh
        image_ththami6.setAutoDraw(True)
    if image_ththami6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami6.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami6.tStop = t  # not accounting for scr refresh
            image_ththami6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami6, 'tStopRefresh')  # time at next scr refresh
            image_ththami6.setAutoDraw(False)
    
    # *image_thuri6* updates
    if image_thuri6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri6.frameNStart = frameN  # exact frame index
        image_thuri6.tStart = t  # local t and not account for scr refresh
        image_thuri6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri6, 'tStartRefresh')  # time at next scr refresh
        image_thuri6.setAutoDraw(True)
    if image_thuri6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri6.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri6.tStop = t  # not accounting for scr refresh
            image_thuri6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri6, 'tStopRefresh')  # time at next scr refresh
            image_thuri6.setAutoDraw(False)
    
    # *text_CT_T2T7_1* updates
    if text_CT_T2T7_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T7_1.frameNStart = frameN  # exact frame index
        text_CT_T2T7_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T7_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T7_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T7_1.setAutoDraw(True)
    if text_CT_T2T7_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T7_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T7_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T7_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T7_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T7_1.setAutoDraw(False)
    
    # *text_CT_T2T7_0* updates
    if text_CT_T2T7_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T7_0.frameNStart = frameN  # exact frame index
        text_CT_T2T7_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T7_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T7_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T7_0.setAutoDraw(True)
    if text_CT_T2T7_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T7_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T7_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T7_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T7_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T7_0.setAutoDraw(False)
    # start/stop sound_thuri5
    if sound_thuri5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thuri5.frameNStart = frameN  # exact frame index
        sound_thuri5.tStart = t  # local t and not account for scr refresh
        sound_thuri5.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thuri5.play(when=win)  # sync with win flip
    if sound_thuri5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thuri5.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thuri5.tStop = t  # not accounting for scr refresh
            sound_thuri5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thuri5, 'tStopRefresh')  # time at next scr refresh
            sound_thuri5.stop()
    
    # *text_CT_T2T7* updates
    if text_CT_T2T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T7.frameNStart = frameN  # exact frame index
        text_CT_T2T7.tStart = t  # local t and not account for scr refresh
        text_CT_T2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T7, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T7.setAutoDraw(True)
    if text_CT_T2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T7.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T7.tStop = t  # not accounting for scr refresh
            text_CT_T2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T7, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T7.setAutoDraw(False)
    
    # *key_CT_T2T7* updates
    waitOnFlip = False
    if key_CT_T2T7.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T7.frameNStart = frameN  # exact frame index
        key_CT_T2T7.tStart = t  # local t and not account for scr refresh
        key_CT_T2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T7, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T7.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T7.tStop = t  # not accounting for scr refresh
            key_CT_T2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T7, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T7.status = FINISHED
    if key_CT_T2T7.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T7.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T7_allKeys.extend(theseKeys)
        if len(_key_CT_T2T7_allKeys):
            key_CT_T2T7.keys = _key_CT_T2T7_allKeys[-1].name  # just the last key pressed
            key_CT_T2T7.rt = _key_CT_T2T7_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T7.keys == str('0')) or (key_CT_T2T7.keys == '0'):
                key_CT_T2T7.corr = 1
            else:
                key_CT_T2T7.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T7* updates
    if phases_CT_T2T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T7.frameNStart = frameN  # exact frame index
        phases_CT_T2T7.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T7, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T7.setAutoDraw(True)
    if phases_CT_T2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T7.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T7.tStop = t  # not accounting for scr refresh
            phases_CT_T2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T7, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T7.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T7Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T7"-------
for thisComponent in CriterionTestT2T7Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththami6.started', image_ththami6.tStartRefresh)
thisExp.addData('image_ththami6.stopped', image_ththami6.tStopRefresh)
thisExp.addData('image_thuri6.started', image_thuri6.tStartRefresh)
thisExp.addData('image_thuri6.stopped', image_thuri6.tStopRefresh)
thisExp.addData('text_CT_T2T7_1.started', text_CT_T2T7_1.tStartRefresh)
thisExp.addData('text_CT_T2T7_1.stopped', text_CT_T2T7_1.tStopRefresh)
thisExp.addData('text_CT_T2T7_0.started', text_CT_T2T7_0.tStartRefresh)
thisExp.addData('text_CT_T2T7_0.stopped', text_CT_T2T7_0.tStopRefresh)
sound_thuri5.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thuri5.started', sound_thuri5.tStartRefresh)
thisExp.addData('sound_thuri5.stopped', sound_thuri5.tStopRefresh)
thisExp.addData('text_CT_T2T7.started', text_CT_T2T7.tStartRefresh)
thisExp.addData('text_CT_T2T7.stopped', text_CT_T2T7.tStopRefresh)
# check responses
if key_CT_T2T7.keys in ['', [], None]:  # No response was made
    key_CT_T2T7.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T2T7.corr = 1;  # correct non-response
    else:
       key_CT_T2T7.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T7.keys',key_CT_T2T7.keys)
thisExp.addData('key_CT_T2T7.corr', key_CT_T2T7.corr)
if key_CT_T2T7.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T7.rt', key_CT_T2T7.rt)
thisExp.addData('key_CT_T2T7.started', key_CT_T2T7.tStartRefresh)
thisExp.addData('key_CT_T2T7.stopped', key_CT_T2T7.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T7.started', phases_CT_T2T7.tStartRefresh)
thisExp.addData('phases_CT_T2T7.stopped', phases_CT_T2T7.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT2T8"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thami4.setSound('Sounds/thami.wav', hamming=True)
sound_thami4.setVolume(1, log=False)
key_CT_T2T8.keys = []
key_CT_T2T8.rt = []
_key_CT_T2T8_allKeys = []
# keep track of which components have finished
CriterionTestT2T8Components = [image_ththano6, image_thami6, text_CT_T2T8_1, text_CT_T2T8_0, sound_thami4, text_CT_T2T8, key_CT_T2T8, phases_CT_T2T8]
for thisComponent in CriterionTestT2T8Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T8"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T8Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T8Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththano6* updates
    if image_ththano6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano6.frameNStart = frameN  # exact frame index
        image_ththano6.tStart = t  # local t and not account for scr refresh
        image_ththano6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano6, 'tStartRefresh')  # time at next scr refresh
        image_ththano6.setAutoDraw(True)
    if image_ththano6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano6.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano6.tStop = t  # not accounting for scr refresh
            image_ththano6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano6, 'tStopRefresh')  # time at next scr refresh
            image_ththano6.setAutoDraw(False)
    
    # *image_thami6* updates
    if image_thami6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami6.frameNStart = frameN  # exact frame index
        image_thami6.tStart = t  # local t and not account for scr refresh
        image_thami6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami6, 'tStartRefresh')  # time at next scr refresh
        image_thami6.setAutoDraw(True)
    if image_thami6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami6.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami6.tStop = t  # not accounting for scr refresh
            image_thami6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami6, 'tStopRefresh')  # time at next scr refresh
            image_thami6.setAutoDraw(False)
    
    # *text_CT_T2T8_1* updates
    if text_CT_T2T8_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T8_1.frameNStart = frameN  # exact frame index
        text_CT_T2T8_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T8_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T8_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T8_1.setAutoDraw(True)
    if text_CT_T2T8_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T8_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T8_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T8_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T8_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T8_1.setAutoDraw(False)
    
    # *text_CT_T2T8_0* updates
    if text_CT_T2T8_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T8_0.frameNStart = frameN  # exact frame index
        text_CT_T2T8_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T8_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T8_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T8_0.setAutoDraw(True)
    if text_CT_T2T8_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T8_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T8_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T8_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T8_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T8_0.setAutoDraw(False)
    # start/stop sound_thami4
    if sound_thami4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thami4.frameNStart = frameN  # exact frame index
        sound_thami4.tStart = t  # local t and not account for scr refresh
        sound_thami4.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thami4.play(when=win)  # sync with win flip
    if sound_thami4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thami4.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thami4.tStop = t  # not accounting for scr refresh
            sound_thami4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thami4, 'tStopRefresh')  # time at next scr refresh
            sound_thami4.stop()
    
    # *text_CT_T2T8* updates
    if text_CT_T2T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T8.frameNStart = frameN  # exact frame index
        text_CT_T2T8.tStart = t  # local t and not account for scr refresh
        text_CT_T2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T8, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T8.setAutoDraw(True)
    if text_CT_T2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T8.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T8.tStop = t  # not accounting for scr refresh
            text_CT_T2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T8, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T8.setAutoDraw(False)
    
    # *key_CT_T2T8* updates
    waitOnFlip = False
    if key_CT_T2T8.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T8.frameNStart = frameN  # exact frame index
        key_CT_T2T8.tStart = t  # local t and not account for scr refresh
        key_CT_T2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T8, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T8.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T8.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T8.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T8.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T8.tStop = t  # not accounting for scr refresh
            key_CT_T2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T8, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T8.status = FINISHED
    if key_CT_T2T8.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T8.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T8_allKeys.extend(theseKeys)
        if len(_key_CT_T2T8_allKeys):
            key_CT_T2T8.keys = _key_CT_T2T8_allKeys[-1].name  # just the last key pressed
            key_CT_T2T8.rt = _key_CT_T2T8_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T8.keys == str('0')) or (key_CT_T2T8.keys == '0'):
                key_CT_T2T8.corr = 1
            else:
                key_CT_T2T8.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T8* updates
    if phases_CT_T2T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T8.frameNStart = frameN  # exact frame index
        phases_CT_T2T8.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T8, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T8.setAutoDraw(True)
    if phases_CT_T2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T8.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T8.tStop = t  # not accounting for scr refresh
            phases_CT_T2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T8, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T8.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T8Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T8"-------
for thisComponent in CriterionTestT2T8Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththano6.started', image_ththano6.tStartRefresh)
thisExp.addData('image_ththano6.stopped', image_ththano6.tStopRefresh)
thisExp.addData('image_thami6.started', image_thami6.tStartRefresh)
thisExp.addData('image_thami6.stopped', image_thami6.tStopRefresh)
thisExp.addData('text_CT_T2T8_1.started', text_CT_T2T8_1.tStartRefresh)
thisExp.addData('text_CT_T2T8_1.stopped', text_CT_T2T8_1.tStopRefresh)
thisExp.addData('text_CT_T2T8_0.started', text_CT_T2T8_0.tStartRefresh)
thisExp.addData('text_CT_T2T8_0.stopped', text_CT_T2T8_0.tStopRefresh)
sound_thami4.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thami4.started', sound_thami4.tStartRefresh)
thisExp.addData('sound_thami4.stopped', sound_thami4.tStopRefresh)
thisExp.addData('text_CT_T2T8.started', text_CT_T2T8.tStartRefresh)
thisExp.addData('text_CT_T2T8.stopped', text_CT_T2T8.tStopRefresh)
# check responses
if key_CT_T2T8.keys in ['', [], None]:  # No response was made
    key_CT_T2T8.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T2T8.corr = 1;  # correct non-response
    else:
       key_CT_T2T8.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T8.keys',key_CT_T2T8.keys)
thisExp.addData('key_CT_T2T8.corr', key_CT_T2T8.corr)
if key_CT_T2T8.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T8.rt', key_CT_T2T8.rt)
thisExp.addData('key_CT_T2T8.started', key_CT_T2T8.tStartRefresh)
thisExp.addData('key_CT_T2T8.stopped', key_CT_T2T8.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T8.started', phases_CT_T2T8.tStartRefresh)
thisExp.addData('phases_CT_T2T8.stopped', phases_CT_T2T8.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT2T9"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thano4.setSound('Sounds/thano.wav', hamming=True)
sound_thano4.setVolume(1, log=False)
key_CT_T2T9.keys = []
key_CT_T2T9.rt = []
_key_CT_T2T9_allKeys = []
# keep track of which components have finished
CriterionTestT2T9Components = [image_ththuri6, image_thano6, text_CT_T2T9_1, text_CT_T2T9_0, sound_thano4, text_CT_T2T9, key_CT_T2T9, phases_CT_T2T9]
for thisComponent in CriterionTestT2T9Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T9"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T9Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T9Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththuri6* updates
    if image_ththuri6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri6.frameNStart = frameN  # exact frame index
        image_ththuri6.tStart = t  # local t and not account for scr refresh
        image_ththuri6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri6, 'tStartRefresh')  # time at next scr refresh
        image_ththuri6.setAutoDraw(True)
    if image_ththuri6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri6.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri6.tStop = t  # not accounting for scr refresh
            image_ththuri6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri6, 'tStopRefresh')  # time at next scr refresh
            image_ththuri6.setAutoDraw(False)
    
    # *image_thano6* updates
    if image_thano6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano6.frameNStart = frameN  # exact frame index
        image_thano6.tStart = t  # local t and not account for scr refresh
        image_thano6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano6, 'tStartRefresh')  # time at next scr refresh
        image_thano6.setAutoDraw(True)
    if image_thano6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano6.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano6.tStop = t  # not accounting for scr refresh
            image_thano6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano6, 'tStopRefresh')  # time at next scr refresh
            image_thano6.setAutoDraw(False)
    
    # *text_CT_T2T9_1* updates
    if text_CT_T2T9_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T9_1.frameNStart = frameN  # exact frame index
        text_CT_T2T9_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T9_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T9_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T9_1.setAutoDraw(True)
    if text_CT_T2T9_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T9_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T9_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T9_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T9_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T9_1.setAutoDraw(False)
    
    # *text_CT_T2T9_0* updates
    if text_CT_T2T9_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T9_0.frameNStart = frameN  # exact frame index
        text_CT_T2T9_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T9_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T9_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T9_0.setAutoDraw(True)
    if text_CT_T2T9_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T9_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T9_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T9_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T9_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T9_0.setAutoDraw(False)
    # start/stop sound_thano4
    if sound_thano4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thano4.frameNStart = frameN  # exact frame index
        sound_thano4.tStart = t  # local t and not account for scr refresh
        sound_thano4.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thano4.play(when=win)  # sync with win flip
    if sound_thano4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thano4.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thano4.tStop = t  # not accounting for scr refresh
            sound_thano4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thano4, 'tStopRefresh')  # time at next scr refresh
            sound_thano4.stop()
    
    # *text_CT_T2T9* updates
    if text_CT_T2T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T9.frameNStart = frameN  # exact frame index
        text_CT_T2T9.tStart = t  # local t and not account for scr refresh
        text_CT_T2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T9, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T9.setAutoDraw(True)
    if text_CT_T2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T9.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T9.tStop = t  # not accounting for scr refresh
            text_CT_T2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T9, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T9.setAutoDraw(False)
    
    # *key_CT_T2T9* updates
    waitOnFlip = False
    if key_CT_T2T9.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T9.frameNStart = frameN  # exact frame index
        key_CT_T2T9.tStart = t  # local t and not account for scr refresh
        key_CT_T2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T9, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T9.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T9.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T9.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T9.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T9.tStop = t  # not accounting for scr refresh
            key_CT_T2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T9, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T9.status = FINISHED
    if key_CT_T2T9.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T9.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T9_allKeys.extend(theseKeys)
        if len(_key_CT_T2T9_allKeys):
            key_CT_T2T9.keys = _key_CT_T2T9_allKeys[-1].name  # just the last key pressed
            key_CT_T2T9.rt = _key_CT_T2T9_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T9.keys == str('0')) or (key_CT_T2T9.keys == '0'):
                key_CT_T2T9.corr = 1
            else:
                key_CT_T2T9.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T9* updates
    if phases_CT_T2T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T9.frameNStart = frameN  # exact frame index
        phases_CT_T2T9.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T9, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T9.setAutoDraw(True)
    if phases_CT_T2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T9.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T9.tStop = t  # not accounting for scr refresh
            phases_CT_T2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T9, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T9.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T9Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T9"-------
for thisComponent in CriterionTestT2T9Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththuri6.started', image_ththuri6.tStartRefresh)
thisExp.addData('image_ththuri6.stopped', image_ththuri6.tStopRefresh)
thisExp.addData('image_thano6.started', image_thano6.tStartRefresh)
thisExp.addData('image_thano6.stopped', image_thano6.tStopRefresh)
thisExp.addData('text_CT_T2T9_1.started', text_CT_T2T9_1.tStartRefresh)
thisExp.addData('text_CT_T2T9_1.stopped', text_CT_T2T9_1.tStopRefresh)
thisExp.addData('text_CT_T2T9_0.started', text_CT_T2T9_0.tStartRefresh)
thisExp.addData('text_CT_T2T9_0.stopped', text_CT_T2T9_0.tStopRefresh)
sound_thano4.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thano4.started', sound_thano4.tStartRefresh)
thisExp.addData('sound_thano4.stopped', sound_thano4.tStopRefresh)
thisExp.addData('text_CT_T2T9.started', text_CT_T2T9.tStartRefresh)
thisExp.addData('text_CT_T2T9.stopped', text_CT_T2T9.tStopRefresh)
# check responses
if key_CT_T2T9.keys in ['', [], None]:  # No response was made
    key_CT_T2T9.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T2T9.corr = 1;  # correct non-response
    else:
       key_CT_T2T9.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T9.keys',key_CT_T2T9.keys)
thisExp.addData('key_CT_T2T9.corr', key_CT_T2T9.corr)
if key_CT_T2T9.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T9.rt', key_CT_T2T9.rt)
thisExp.addData('key_CT_T2T9.started', key_CT_T2T9.tStartRefresh)
thisExp.addData('key_CT_T2T9.stopped', key_CT_T2T9.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T9.started', phases_CT_T2T9.tStartRefresh)
thisExp.addData('phases_CT_T2T9.stopped', phases_CT_T2T9.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT2T10"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thuri4.setSound('Sounds/thuri.wav', hamming=True)
sound_thuri4.setVolume(1, log=False)
key_CT_T2T10.keys = []
key_CT_T2T10.rt = []
_key_CT_T2T10_allKeys = []
# keep track of which components have finished
CriterionTestT2T10Components = [image_thuri7, image_ththano7, text_CT_T2T10_1, text_CT_T2T10_0, sound_thuri4, text_CT_T2T10, key_CT_T2T10, phases_CT_T2T10]
for thisComponent in CriterionTestT2T10Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T10"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T10Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T10Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_thuri7* updates
    if image_thuri7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri7.frameNStart = frameN  # exact frame index
        image_thuri7.tStart = t  # local t and not account for scr refresh
        image_thuri7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri7, 'tStartRefresh')  # time at next scr refresh
        image_thuri7.setAutoDraw(True)
    if image_thuri7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri7.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri7.tStop = t  # not accounting for scr refresh
            image_thuri7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri7, 'tStopRefresh')  # time at next scr refresh
            image_thuri7.setAutoDraw(False)
    
    # *image_ththano7* updates
    if image_ththano7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano7.frameNStart = frameN  # exact frame index
        image_ththano7.tStart = t  # local t and not account for scr refresh
        image_ththano7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano7, 'tStartRefresh')  # time at next scr refresh
        image_ththano7.setAutoDraw(True)
    if image_ththano7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano7.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano7.tStop = t  # not accounting for scr refresh
            image_ththano7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano7, 'tStopRefresh')  # time at next scr refresh
            image_ththano7.setAutoDraw(False)
    
    # *text_CT_T2T10_1* updates
    if text_CT_T2T10_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T10_1.frameNStart = frameN  # exact frame index
        text_CT_T2T10_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T10_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T10_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T10_1.setAutoDraw(True)
    if text_CT_T2T10_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T10_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T10_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T10_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T10_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T10_1.setAutoDraw(False)
    
    # *text_CT_T2T10_0* updates
    if text_CT_T2T10_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T10_0.frameNStart = frameN  # exact frame index
        text_CT_T2T10_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T10_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T10_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T10_0.setAutoDraw(True)
    if text_CT_T2T10_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T10_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T10_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T10_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T10_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T10_0.setAutoDraw(False)
    # start/stop sound_thuri4
    if sound_thuri4.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thuri4.frameNStart = frameN  # exact frame index
        sound_thuri4.tStart = t  # local t and not account for scr refresh
        sound_thuri4.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thuri4.play(when=win)  # sync with win flip
    if sound_thuri4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thuri4.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thuri4.tStop = t  # not accounting for scr refresh
            sound_thuri4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thuri4, 'tStopRefresh')  # time at next scr refresh
            sound_thuri4.stop()
    
    # *text_CT_T2T10* updates
    if text_CT_T2T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T10.frameNStart = frameN  # exact frame index
        text_CT_T2T10.tStart = t  # local t and not account for scr refresh
        text_CT_T2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T10, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T10.setAutoDraw(True)
    if text_CT_T2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T10.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T10.tStop = t  # not accounting for scr refresh
            text_CT_T2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T10, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T10.setAutoDraw(False)
    
    # *key_CT_T2T10* updates
    waitOnFlip = False
    if key_CT_T2T10.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T10.frameNStart = frameN  # exact frame index
        key_CT_T2T10.tStart = t  # local t and not account for scr refresh
        key_CT_T2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T10, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T10.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T10.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T10.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T10.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T10.tStop = t  # not accounting for scr refresh
            key_CT_T2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T10, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T10.status = FINISHED
    if key_CT_T2T10.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T10.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T10_allKeys.extend(theseKeys)
        if len(_key_CT_T2T10_allKeys):
            key_CT_T2T10.keys = _key_CT_T2T10_allKeys[-1].name  # just the last key pressed
            key_CT_T2T10.rt = _key_CT_T2T10_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T10.keys == str('1')) or (key_CT_T2T10.keys == '1'):
                key_CT_T2T10.corr = 1
            else:
                key_CT_T2T10.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T10* updates
    if phases_CT_T2T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T10.frameNStart = frameN  # exact frame index
        phases_CT_T2T10.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T10, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T10.setAutoDraw(True)
    if phases_CT_T2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T10.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T10.tStop = t  # not accounting for scr refresh
            phases_CT_T2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T10, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T10.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T10Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T10"-------
for thisComponent in CriterionTestT2T10Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_thuri7.started', image_thuri7.tStartRefresh)
thisExp.addData('image_thuri7.stopped', image_thuri7.tStopRefresh)
thisExp.addData('image_ththano7.started', image_ththano7.tStartRefresh)
thisExp.addData('image_ththano7.stopped', image_ththano7.tStopRefresh)
thisExp.addData('text_CT_T2T10_1.started', text_CT_T2T10_1.tStartRefresh)
thisExp.addData('text_CT_T2T10_1.stopped', text_CT_T2T10_1.tStopRefresh)
thisExp.addData('text_CT_T2T10_0.started', text_CT_T2T10_0.tStartRefresh)
thisExp.addData('text_CT_T2T10_0.stopped', text_CT_T2T10_0.tStopRefresh)
sound_thuri4.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thuri4.started', sound_thuri4.tStartRefresh)
thisExp.addData('sound_thuri4.stopped', sound_thuri4.tStopRefresh)
thisExp.addData('text_CT_T2T10.started', text_CT_T2T10.tStartRefresh)
thisExp.addData('text_CT_T2T10.stopped', text_CT_T2T10.tStopRefresh)
# check responses
if key_CT_T2T10.keys in ['', [], None]:  # No response was made
    key_CT_T2T10.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T2T10.corr = 1;  # correct non-response
    else:
       key_CT_T2T10.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T10.keys',key_CT_T2T10.keys)
thisExp.addData('key_CT_T2T10.corr', key_CT_T2T10.corr)
if key_CT_T2T10.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T10.rt', key_CT_T2T10.rt)
thisExp.addData('key_CT_T2T10.started', key_CT_T2T10.tStartRefresh)
thisExp.addData('key_CT_T2T10.stopped', key_CT_T2T10.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T10.started', phases_CT_T2T10.tStartRefresh)
thisExp.addData('phases_CT_T2T10.stopped', phases_CT_T2T10.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT2T11"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thano5.setSound('Sounds/thano.wav', hamming=True)
sound_thano5.setVolume(1, log=False)
key_CT_T2T11.keys = []
key_CT_T2T11.rt = []
_key_CT_T2T11_allKeys = []
# keep track of which components have finished
CriterionTestT2T11Components = [image_ththami7, image_thano7, text_CT_T2T11_1, text_CT_T2T11_0, sound_thano5, text_CT_T2T11, key_CT_T2T11, phases_CT_T2T11]
for thisComponent in CriterionTestT2T11Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T11"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T11Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T11Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththami7* updates
    if image_ththami7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami7.frameNStart = frameN  # exact frame index
        image_ththami7.tStart = t  # local t and not account for scr refresh
        image_ththami7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami7, 'tStartRefresh')  # time at next scr refresh
        image_ththami7.setAutoDraw(True)
    if image_ththami7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami7.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami7.tStop = t  # not accounting for scr refresh
            image_ththami7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami7, 'tStopRefresh')  # time at next scr refresh
            image_ththami7.setAutoDraw(False)
    
    # *image_thano7* updates
    if image_thano7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano7.frameNStart = frameN  # exact frame index
        image_thano7.tStart = t  # local t and not account for scr refresh
        image_thano7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano7, 'tStartRefresh')  # time at next scr refresh
        image_thano7.setAutoDraw(True)
    if image_thano7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano7.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano7.tStop = t  # not accounting for scr refresh
            image_thano7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano7, 'tStopRefresh')  # time at next scr refresh
            image_thano7.setAutoDraw(False)
    
    # *text_CT_T2T11_1* updates
    if text_CT_T2T11_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T11_1.frameNStart = frameN  # exact frame index
        text_CT_T2T11_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T11_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T11_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T11_1.setAutoDraw(True)
    if text_CT_T2T11_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T11_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T11_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T11_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T11_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T11_1.setAutoDraw(False)
    
    # *text_CT_T2T11_0* updates
    if text_CT_T2T11_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T11_0.frameNStart = frameN  # exact frame index
        text_CT_T2T11_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T11_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T11_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T11_0.setAutoDraw(True)
    if text_CT_T2T11_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T11_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T11_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T11_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T11_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T11_0.setAutoDraw(False)
    # start/stop sound_thano5
    if sound_thano5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thano5.frameNStart = frameN  # exact frame index
        sound_thano5.tStart = t  # local t and not account for scr refresh
        sound_thano5.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thano5.play(when=win)  # sync with win flip
    if sound_thano5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thano5.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thano5.tStop = t  # not accounting for scr refresh
            sound_thano5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thano5, 'tStopRefresh')  # time at next scr refresh
            sound_thano5.stop()
    
    # *text_CT_T2T11* updates
    if text_CT_T2T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T11.frameNStart = frameN  # exact frame index
        text_CT_T2T11.tStart = t  # local t and not account for scr refresh
        text_CT_T2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T11, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T11.setAutoDraw(True)
    if text_CT_T2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T11.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T11.tStop = t  # not accounting for scr refresh
            text_CT_T2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T11, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T11.setAutoDraw(False)
    
    # *key_CT_T2T11* updates
    waitOnFlip = False
    if key_CT_T2T11.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T11.frameNStart = frameN  # exact frame index
        key_CT_T2T11.tStart = t  # local t and not account for scr refresh
        key_CT_T2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T11, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T11.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T11.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T11.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T11.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T11.tStop = t  # not accounting for scr refresh
            key_CT_T2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T11, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T11.status = FINISHED
    if key_CT_T2T11.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T11.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T11_allKeys.extend(theseKeys)
        if len(_key_CT_T2T11_allKeys):
            key_CT_T2T11.keys = _key_CT_T2T11_allKeys[-1].name  # just the last key pressed
            key_CT_T2T11.rt = _key_CT_T2T11_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T11.keys == str('0')) or (key_CT_T2T11.keys == '0'):
                key_CT_T2T11.corr = 1
            else:
                key_CT_T2T11.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T11* updates
    if phases_CT_T2T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T11.frameNStart = frameN  # exact frame index
        phases_CT_T2T11.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T11, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T11.setAutoDraw(True)
    if phases_CT_T2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T11.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T11.tStop = t  # not accounting for scr refresh
            phases_CT_T2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T11, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T11.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T11Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T11"-------
for thisComponent in CriterionTestT2T11Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththami7.started', image_ththami7.tStartRefresh)
thisExp.addData('image_ththami7.stopped', image_ththami7.tStopRefresh)
thisExp.addData('image_thano7.started', image_thano7.tStartRefresh)
thisExp.addData('image_thano7.stopped', image_thano7.tStopRefresh)
thisExp.addData('text_CT_T2T11_1.started', text_CT_T2T11_1.tStartRefresh)
thisExp.addData('text_CT_T2T11_1.stopped', text_CT_T2T11_1.tStopRefresh)
thisExp.addData('text_CT_T2T11_0.started', text_CT_T2T11_0.tStartRefresh)
thisExp.addData('text_CT_T2T11_0.stopped', text_CT_T2T11_0.tStopRefresh)
sound_thano5.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thano5.started', sound_thano5.tStartRefresh)
thisExp.addData('sound_thano5.stopped', sound_thano5.tStopRefresh)
thisExp.addData('text_CT_T2T11.started', text_CT_T2T11.tStartRefresh)
thisExp.addData('text_CT_T2T11.stopped', text_CT_T2T11.tStopRefresh)
# check responses
if key_CT_T2T11.keys in ['', [], None]:  # No response was made
    key_CT_T2T11.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_CT_T2T11.corr = 1;  # correct non-response
    else:
       key_CT_T2T11.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T11.keys',key_CT_T2T11.keys)
thisExp.addData('key_CT_T2T11.corr', key_CT_T2T11.corr)
if key_CT_T2T11.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T11.rt', key_CT_T2T11.rt)
thisExp.addData('key_CT_T2T11.started', key_CT_T2T11.tStartRefresh)
thisExp.addData('key_CT_T2T11.stopped', key_CT_T2T11.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T11.started', phases_CT_T2T11.tStartRefresh)
thisExp.addData('phases_CT_T2T11.stopped', phases_CT_T2T11.tStopRefresh)

# ------Prepare to start Routine "CriterionTestT2T12"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thami5.setSound('Sounds/thami.wav', hamming=True)
sound_thami5.setVolume(1, log=False)
key_CT_T2T12.keys = []
key_CT_T2T12.rt = []
_key_CT_T2T12_allKeys = []
# keep track of which components have finished
CriterionTestT2T12Components = [image_thami7, image_ththuri7, text_CT_T2T12_1, text_CT_T2T12_0, sound_thami5, text_CT_T2T12, key_CT_T2T12, phases_CT_T2T12]
for thisComponent in CriterionTestT2T12Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
CriterionTestT2T12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "CriterionTestT2T12"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = CriterionTestT2T12Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=CriterionTestT2T12Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_thami7* updates
    if image_thami7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami7.frameNStart = frameN  # exact frame index
        image_thami7.tStart = t  # local t and not account for scr refresh
        image_thami7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami7, 'tStartRefresh')  # time at next scr refresh
        image_thami7.setAutoDraw(True)
    if image_thami7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami7.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami7.tStop = t  # not accounting for scr refresh
            image_thami7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami7, 'tStopRefresh')  # time at next scr refresh
            image_thami7.setAutoDraw(False)
    
    # *image_ththuri7* updates
    if image_ththuri7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri7.frameNStart = frameN  # exact frame index
        image_ththuri7.tStart = t  # local t and not account for scr refresh
        image_ththuri7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri7, 'tStartRefresh')  # time at next scr refresh
        image_ththuri7.setAutoDraw(True)
    if image_ththuri7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri7.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri7.tStop = t  # not accounting for scr refresh
            image_ththuri7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri7, 'tStopRefresh')  # time at next scr refresh
            image_ththuri7.setAutoDraw(False)
    
    # *text_CT_T2T12_1* updates
    if text_CT_T2T12_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T12_1.frameNStart = frameN  # exact frame index
        text_CT_T2T12_1.tStart = t  # local t and not account for scr refresh
        text_CT_T2T12_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T12_1, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T12_1.setAutoDraw(True)
    if text_CT_T2T12_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T12_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T12_1.tStop = t  # not accounting for scr refresh
            text_CT_T2T12_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T12_1, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T12_1.setAutoDraw(False)
    
    # *text_CT_T2T12_0* updates
    if text_CT_T2T12_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T12_0.frameNStart = frameN  # exact frame index
        text_CT_T2T12_0.tStart = t  # local t and not account for scr refresh
        text_CT_T2T12_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T12_0, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T12_0.setAutoDraw(True)
    if text_CT_T2T12_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T12_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T12_0.tStop = t  # not accounting for scr refresh
            text_CT_T2T12_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T12_0, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T12_0.setAutoDraw(False)
    # start/stop sound_thami5
    if sound_thami5.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thami5.frameNStart = frameN  # exact frame index
        sound_thami5.tStart = t  # local t and not account for scr refresh
        sound_thami5.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thami5.play(when=win)  # sync with win flip
    if sound_thami5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thami5.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thami5.tStop = t  # not accounting for scr refresh
            sound_thami5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thami5, 'tStopRefresh')  # time at next scr refresh
            sound_thami5.stop()
    
    # *text_CT_T2T12* updates
    if text_CT_T2T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_CT_T2T12.frameNStart = frameN  # exact frame index
        text_CT_T2T12.tStart = t  # local t and not account for scr refresh
        text_CT_T2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_CT_T2T12, 'tStartRefresh')  # time at next scr refresh
        text_CT_T2T12.setAutoDraw(True)
    if text_CT_T2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_CT_T2T12.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_CT_T2T12.tStop = t  # not accounting for scr refresh
            text_CT_T2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_CT_T2T12, 'tStopRefresh')  # time at next scr refresh
            text_CT_T2T12.setAutoDraw(False)
    
    # *key_CT_T2T12* updates
    waitOnFlip = False
    if key_CT_T2T12.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_CT_T2T12.frameNStart = frameN  # exact frame index
        key_CT_T2T12.tStart = t  # local t and not account for scr refresh
        key_CT_T2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_CT_T2T12, 'tStartRefresh')  # time at next scr refresh
        key_CT_T2T12.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_CT_T2T12.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_CT_T2T12.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_CT_T2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_CT_T2T12.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_CT_T2T12.tStop = t  # not accounting for scr refresh
            key_CT_T2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_CT_T2T12, 'tStopRefresh')  # time at next scr refresh
            key_CT_T2T12.status = FINISHED
    if key_CT_T2T12.status == STARTED and not waitOnFlip:
        theseKeys = key_CT_T2T12.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_CT_T2T12_allKeys.extend(theseKeys)
        if len(_key_CT_T2T12_allKeys):
            key_CT_T2T12.keys = _key_CT_T2T12_allKeys[-1].name  # just the last key pressed
            key_CT_T2T12.rt = _key_CT_T2T12_allKeys[-1].rt
            # was this correct?
            if (key_CT_T2T12.keys == str('1')) or (key_CT_T2T12.keys == '1'):
                key_CT_T2T12.corr = 1
            else:
                key_CT_T2T12.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_CT_T2T12* updates
    if phases_CT_T2T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_CT_T2T12.frameNStart = frameN  # exact frame index
        phases_CT_T2T12.tStart = t  # local t and not account for scr refresh
        phases_CT_T2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_CT_T2T12, 'tStartRefresh')  # time at next scr refresh
        phases_CT_T2T12.setAutoDraw(True)
    if phases_CT_T2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_CT_T2T12.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_CT_T2T12.tStop = t  # not accounting for scr refresh
            phases_CT_T2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_CT_T2T12, 'tStopRefresh')  # time at next scr refresh
            phases_CT_T2T12.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in CriterionTestT2T12Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "CriterionTestT2T12"-------
for thisComponent in CriterionTestT2T12Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_thami7.started', image_thami7.tStartRefresh)
thisExp.addData('image_thami7.stopped', image_thami7.tStopRefresh)
thisExp.addData('image_ththuri7.started', image_ththuri7.tStartRefresh)
thisExp.addData('image_ththuri7.stopped', image_ththuri7.tStopRefresh)
thisExp.addData('text_CT_T2T12_1.started', text_CT_T2T12_1.tStartRefresh)
thisExp.addData('text_CT_T2T12_1.stopped', text_CT_T2T12_1.tStopRefresh)
thisExp.addData('text_CT_T2T12_0.started', text_CT_T2T12_0.tStartRefresh)
thisExp.addData('text_CT_T2T12_0.stopped', text_CT_T2T12_0.tStopRefresh)
sound_thami5.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thami5.started', sound_thami5.tStartRefresh)
thisExp.addData('sound_thami5.stopped', sound_thami5.tStopRefresh)
thisExp.addData('text_CT_T2T12.started', text_CT_T2T12.tStartRefresh)
thisExp.addData('text_CT_T2T12.stopped', text_CT_T2T12.tStopRefresh)
# check responses
if key_CT_T2T12.keys in ['', [], None]:  # No response was made
    key_CT_T2T12.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_CT_T2T12.corr = 1;  # correct non-response
    else:
       key_CT_T2T12.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_CT_T2T12.keys',key_CT_T2T12.keys)
thisExp.addData('key_CT_T2T12.corr', key_CT_T2T12.corr)
if key_CT_T2T12.keys != None:  # we had a response
    thisExp.addData('key_CT_T2T12.rt', key_CT_T2T12.rt)
thisExp.addData('key_CT_T2T12.started', key_CT_T2T12.tStartRefresh)
thisExp.addData('key_CT_T2T12.stopped', key_CT_T2T12.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_CT_T2T12.started', phases_CT_T2T12.tStartRefresh)
thisExp.addData('phases_CT_T2T12.stopped', phases_CT_T2T12.tStopRefresh)

# ------Prepare to start Routine "EndCriterionTest"-------
continueRoutine = True
# update component parameters for each repeat
key_EndCT.keys = []
key_EndCT.rt = []
_key_EndCT_allKeys = []
# keep track of which components have finished
EndCriterionTestComponents = [text_EndCT, key_EndCT, phases_endCT]
for thisComponent in EndCriterionTestComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
EndCriterionTestClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "EndCriterionTest"-------
while continueRoutine:
    # get current time
    t = EndCriterionTestClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=EndCriterionTestClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_EndCT* updates
    if text_EndCT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_EndCT.frameNStart = frameN  # exact frame index
        text_EndCT.tStart = t  # local t and not account for scr refresh
        text_EndCT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_EndCT, 'tStartRefresh')  # time at next scr refresh
        text_EndCT.setAutoDraw(True)
    
    # *key_EndCT* updates
    waitOnFlip = False
    if key_EndCT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_EndCT.frameNStart = frameN  # exact frame index
        key_EndCT.tStart = t  # local t and not account for scr refresh
        key_EndCT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_EndCT, 'tStartRefresh')  # time at next scr refresh
        key_EndCT.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_EndCT.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_EndCT.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_EndCT.status == STARTED and not waitOnFlip:
        theseKeys = key_EndCT.getKeys(keyList=['space'], waitRelease=False)
        _key_EndCT_allKeys.extend(theseKeys)
        if len(_key_EndCT_allKeys):
            key_EndCT.keys = _key_EndCT_allKeys[-1].name  # just the last key pressed
            key_EndCT.rt = _key_EndCT_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # *phases_endCT* updates
    if phases_endCT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_endCT.frameNStart = frameN  # exact frame index
        phases_endCT.tStart = t  # local t and not account for scr refresh
        phases_endCT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_endCT, 'tStartRefresh')  # time at next scr refresh
        phases_endCT.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in EndCriterionTestComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "EndCriterionTest"-------
for thisComponent in EndCriterionTestComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_EndCT.started', text_EndCT.tStartRefresh)
thisExp.addData('text_EndCT.stopped', text_EndCT.tStopRefresh)
# check responses
if key_EndCT.keys in ['', [], None]:  # No response was made
    key_EndCT.keys = None
thisExp.addData('key_EndCT.keys',key_EndCT.keys)
if key_EndCT.keys != None:  # we had a response
    thisExp.addData('key_EndCT.rt', key_EndCT.rt)
thisExp.addData('key_EndCT.started', key_EndCT.tStartRefresh)
thisExp.addData('key_EndCT.stopped', key_EndCT.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_endCT.started', phases_endCT.tStartRefresh)
thisExp.addData('phases_endCT.stopped', phases_endCT.tStopRefresh)
# the Routine "EndCriterionTest" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Phase4Instructions1"-------
continueRoutine = True
# update component parameters for each repeat
key_FTinstructions1.keys = []
key_FTinstructions1.rt = []
_key_FTinstructions1_allKeys = []
# keep track of which components have finished
Phase4Instructions1Components = [text_FTinstructions1, key_FTinstructions1]
for thisComponent in Phase4Instructions1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase4Instructions1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase4Instructions1"-------
while continueRoutine:
    # get current time
    t = Phase4Instructions1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase4Instructions1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_FTinstructions1* updates
    if text_FTinstructions1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FTinstructions1.frameNStart = frameN  # exact frame index
        text_FTinstructions1.tStart = t  # local t and not account for scr refresh
        text_FTinstructions1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FTinstructions1, 'tStartRefresh')  # time at next scr refresh
        text_FTinstructions1.setAutoDraw(True)
    
    # *key_FTinstructions1* updates
    waitOnFlip = False
    if key_FTinstructions1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_FTinstructions1.frameNStart = frameN  # exact frame index
        key_FTinstructions1.tStart = t  # local t and not account for scr refresh
        key_FTinstructions1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FTinstructions1, 'tStartRefresh')  # time at next scr refresh
        key_FTinstructions1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FTinstructions1.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FTinstructions1.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FTinstructions1.status == STARTED and not waitOnFlip:
        theseKeys = key_FTinstructions1.getKeys(keyList=['space'], waitRelease=False)
        _key_FTinstructions1_allKeys.extend(theseKeys)
        if len(_key_FTinstructions1_allKeys):
            key_FTinstructions1.keys = _key_FTinstructions1_allKeys[-1].name  # just the last key pressed
            key_FTinstructions1.rt = _key_FTinstructions1_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase4Instructions1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase4Instructions1"-------
for thisComponent in Phase4Instructions1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_FTinstructions1.started', text_FTinstructions1.tStartRefresh)
thisExp.addData('text_FTinstructions1.stopped', text_FTinstructions1.tStopRefresh)
# check responses
if key_FTinstructions1.keys in ['', [], None]:  # No response was made
    key_FTinstructions1.keys = None
thisExp.addData('key_FTinstructions1.keys',key_FTinstructions1.keys)
if key_FTinstructions1.keys != None:  # we had a response
    thisExp.addData('key_FTinstructions1.rt', key_FTinstructions1.rt)
thisExp.addData('key_FTinstructions1.started', key_FTinstructions1.tStartRefresh)
thisExp.addData('key_FTinstructions1.stopped', key_FTinstructions1.tStopRefresh)
thisExp.nextEntry()
# the Routine "Phase4Instructions1" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "FinalTestT1T1"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththuri6.setSound('Sounds/ththuri.wav', hamming=True)
sound_ththuri6.setVolume(1, log=False)
key_FT_T1T1.keys = []
key_FT_T1T1.rt = []
_key_FT_T1T1_allKeys = []
# keep track of which components have finished
FinalTestT1T1Components = [sound_ththuri6, image_thuri8, text_FT_T1T1, key_FT_T1T1, phases_FT_T1T1]
for thisComponent in FinalTestT1T1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T1"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththuri6
    if sound_ththuri6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththuri6.frameNStart = frameN  # exact frame index
        sound_ththuri6.tStart = t  # local t and not account for scr refresh
        sound_ththuri6.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththuri6.play(when=win)  # sync with win flip
    if sound_ththuri6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththuri6.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththuri6.tStop = t  # not accounting for scr refresh
            sound_ththuri6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththuri6, 'tStopRefresh')  # time at next scr refresh
            sound_ththuri6.stop()
    
    # *image_thuri8* updates
    if image_thuri8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri8.frameNStart = frameN  # exact frame index
        image_thuri8.tStart = t  # local t and not account for scr refresh
        image_thuri8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri8, 'tStartRefresh')  # time at next scr refresh
        image_thuri8.setAutoDraw(True)
    if image_thuri8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri8.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri8.tStop = t  # not accounting for scr refresh
            image_thuri8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri8, 'tStopRefresh')  # time at next scr refresh
            image_thuri8.setAutoDraw(False)
    
    # *text_FT_T1T1* updates
    if text_FT_T1T1.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T1.frameNStart = frameN  # exact frame index
        text_FT_T1T1.tStart = t  # local t and not account for scr refresh
        text_FT_T1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T1.setAutoDraw(True)
    if text_FT_T1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T1.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T1.tStop = t  # not accounting for scr refresh
            text_FT_T1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T1.setAutoDraw(False)
    
    # *key_FT_T1T1* updates
    waitOnFlip = False
    if key_FT_T1T1.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T1.frameNStart = frameN  # exact frame index
        key_FT_T1T1.tStart = t  # local t and not account for scr refresh
        key_FT_T1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T1, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T1.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T1.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T1.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T1.tStop = t  # not accounting for scr refresh
            key_FT_T1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T1, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T1.status = FINISHED
    if key_FT_T1T1.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T1.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T1_allKeys.extend(theseKeys)
        if len(_key_FT_T1T1_allKeys):
            key_FT_T1T1.keys = _key_FT_T1T1_allKeys[-1].name  # just the last key pressed
            key_FT_T1T1.rt = _key_FT_T1T1_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T1.keys == str('0')) or (key_FT_T1T1.keys == '0'):
                key_FT_T1T1.corr = 1
            else:
                key_FT_T1T1.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T1* updates
    if phases_FT_T1T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T1.frameNStart = frameN  # exact frame index
        phases_FT_T1T1.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T1, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T1.setAutoDraw(True)
    if phases_FT_T1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T1.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T1.tStop = t  # not accounting for scr refresh
            phases_FT_T1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T1, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T1.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T1"-------
for thisComponent in FinalTestT1T1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththuri6.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththuri6.started', sound_ththuri6.tStartRefresh)
thisExp.addData('sound_ththuri6.stopped', sound_ththuri6.tStopRefresh)
thisExp.addData('image_thuri8.started', image_thuri8.tStartRefresh)
thisExp.addData('image_thuri8.stopped', image_thuri8.tStopRefresh)
thisExp.addData('text_FT_T1T1.started', text_FT_T1T1.tStartRefresh)
thisExp.addData('text_FT_T1T1.stopped', text_FT_T1T1.tStopRefresh)
# check responses
if key_FT_T1T1.keys in ['', [], None]:  # No response was made
    key_FT_T1T1.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T1T1.corr = 1;  # correct non-response
    else:
       key_FT_T1T1.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T1.keys',key_FT_T1T1.keys)
thisExp.addData('key_FT_T1T1.corr', key_FT_T1T1.corr)
if key_FT_T1T1.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T1.rt', key_FT_T1T1.rt)
thisExp.addData('key_FT_T1T1.started', key_FT_T1T1.tStartRefresh)
thisExp.addData('key_FT_T1T1.stopped', key_FT_T1T1.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T1.started', phases_FT_T1T1.tStartRefresh)
thisExp.addData('phases_FT_T1T1.stopped', phases_FT_T1T1.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T2"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thami6.setSound('Sounds/thami.wav', hamming=True)
sound_thami6.setVolume(1, log=False)
key_FT_T1T2.keys = []
key_FT_T1T2.rt = []
_key_FT_T1T2_allKeys = []
# keep track of which components have finished
FinalTestT1T2Components = [sound_thami6, image_ththami8, text_FT_T1T2, key_FT_T1T2, phases_FT_T1T2]
for thisComponent in FinalTestT1T2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T2"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thami6
    if sound_thami6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thami6.frameNStart = frameN  # exact frame index
        sound_thami6.tStart = t  # local t and not account for scr refresh
        sound_thami6.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thami6.play(when=win)  # sync with win flip
    if sound_thami6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thami6.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thami6.tStop = t  # not accounting for scr refresh
            sound_thami6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thami6, 'tStopRefresh')  # time at next scr refresh
            sound_thami6.stop()
    
    # *image_ththami8* updates
    if image_ththami8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami8.frameNStart = frameN  # exact frame index
        image_ththami8.tStart = t  # local t and not account for scr refresh
        image_ththami8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami8, 'tStartRefresh')  # time at next scr refresh
        image_ththami8.setAutoDraw(True)
    if image_ththami8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami8.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami8.tStop = t  # not accounting for scr refresh
            image_ththami8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami8, 'tStopRefresh')  # time at next scr refresh
            image_ththami8.setAutoDraw(False)
    
    # *text_FT_T1T2* updates
    if text_FT_T1T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T2.frameNStart = frameN  # exact frame index
        text_FT_T1T2.tStart = t  # local t and not account for scr refresh
        text_FT_T1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T2, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T2.setAutoDraw(True)
    if text_FT_T1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T2.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T2.tStop = t  # not accounting for scr refresh
            text_FT_T1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T2, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T2.setAutoDraw(False)
    
    # *key_FT_T1T2* updates
    waitOnFlip = False
    if key_FT_T1T2.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T2.frameNStart = frameN  # exact frame index
        key_FT_T1T2.tStart = t  # local t and not account for scr refresh
        key_FT_T1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T2, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T2.tStop = t  # not accounting for scr refresh
            key_FT_T1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T2, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T2.status = FINISHED
    if key_FT_T1T2.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T2.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T2_allKeys.extend(theseKeys)
        if len(_key_FT_T1T2_allKeys):
            key_FT_T1T2.keys = _key_FT_T1T2_allKeys[-1].name  # just the last key pressed
            key_FT_T1T2.rt = _key_FT_T1T2_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T2.keys == str('0')) or (key_FT_T1T2.keys == '0'):
                key_FT_T1T2.corr = 1
            else:
                key_FT_T1T2.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T2* updates
    if phases_FT_T1T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T2.frameNStart = frameN  # exact frame index
        phases_FT_T1T2.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T2, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T2.setAutoDraw(True)
    if phases_FT_T1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T2.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T2.tStop = t  # not accounting for scr refresh
            phases_FT_T1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T2, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T2.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T2"-------
for thisComponent in FinalTestT1T2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thami6.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thami6.started', sound_thami6.tStartRefresh)
thisExp.addData('sound_thami6.stopped', sound_thami6.tStopRefresh)
thisExp.addData('image_ththami8.started', image_ththami8.tStartRefresh)
thisExp.addData('image_ththami8.stopped', image_ththami8.tStopRefresh)
thisExp.addData('text_FT_T1T2.started', text_FT_T1T2.tStartRefresh)
thisExp.addData('text_FT_T1T2.stopped', text_FT_T1T2.tStopRefresh)
# check responses
if key_FT_T1T2.keys in ['', [], None]:  # No response was made
    key_FT_T1T2.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T1T2.corr = 1;  # correct non-response
    else:
       key_FT_T1T2.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T2.keys',key_FT_T1T2.keys)
thisExp.addData('key_FT_T1T2.corr', key_FT_T1T2.corr)
if key_FT_T1T2.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T2.rt', key_FT_T1T2.rt)
thisExp.addData('key_FT_T1T2.started', key_FT_T1T2.tStartRefresh)
thisExp.addData('key_FT_T1T2.stopped', key_FT_T1T2.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T2.started', phases_FT_T1T2.tStartRefresh)
thisExp.addData('phases_FT_T1T2.stopped', phases_FT_T1T2.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T3"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thuri6.setSound('Sounds/thuri.wav', hamming=True)
sound_thuri6.setVolume(1, log=False)
key_FT_T1T3.keys = []
key_FT_T1T3.rt = []
_key_FT_T1T3_allKeys = []
# keep track of which components have finished
FinalTestT1T3Components = [sound_thuri6, image_thuri9, text_FT_T1T3, key_FT_T1T3, phases_FT_T1T3]
for thisComponent in FinalTestT1T3Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T3"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T3Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T3Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thuri6
    if sound_thuri6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thuri6.frameNStart = frameN  # exact frame index
        sound_thuri6.tStart = t  # local t and not account for scr refresh
        sound_thuri6.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thuri6.play(when=win)  # sync with win flip
    if sound_thuri6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thuri6.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thuri6.tStop = t  # not accounting for scr refresh
            sound_thuri6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thuri6, 'tStopRefresh')  # time at next scr refresh
            sound_thuri6.stop()
    
    # *image_thuri9* updates
    if image_thuri9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri9.frameNStart = frameN  # exact frame index
        image_thuri9.tStart = t  # local t and not account for scr refresh
        image_thuri9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri9, 'tStartRefresh')  # time at next scr refresh
        image_thuri9.setAutoDraw(True)
    if image_thuri9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri9.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri9.tStop = t  # not accounting for scr refresh
            image_thuri9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri9, 'tStopRefresh')  # time at next scr refresh
            image_thuri9.setAutoDraw(False)
    
    # *text_FT_T1T3* updates
    if text_FT_T1T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T3.frameNStart = frameN  # exact frame index
        text_FT_T1T3.tStart = t  # local t and not account for scr refresh
        text_FT_T1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T3, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T3.setAutoDraw(True)
    if text_FT_T1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T3.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T3.tStop = t  # not accounting for scr refresh
            text_FT_T1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T3, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T3.setAutoDraw(False)
    
    # *key_FT_T1T3* updates
    waitOnFlip = False
    if key_FT_T1T3.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T3.frameNStart = frameN  # exact frame index
        key_FT_T1T3.tStart = t  # local t and not account for scr refresh
        key_FT_T1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T3, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T3.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T3.tStop = t  # not accounting for scr refresh
            key_FT_T1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T3, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T3.status = FINISHED
    if key_FT_T1T3.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T3.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T3_allKeys.extend(theseKeys)
        if len(_key_FT_T1T3_allKeys):
            key_FT_T1T3.keys = _key_FT_T1T3_allKeys[-1].name  # just the last key pressed
            key_FT_T1T3.rt = _key_FT_T1T3_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T3.keys == str('1')) or (key_FT_T1T3.keys == '1'):
                key_FT_T1T3.corr = 1
            else:
                key_FT_T1T3.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T3* updates
    if phases_FT_T1T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T3.frameNStart = frameN  # exact frame index
        phases_FT_T1T3.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T3, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T3.setAutoDraw(True)
    if phases_FT_T1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T3.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T3.tStop = t  # not accounting for scr refresh
            phases_FT_T1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T3, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T3.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T3Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T3"-------
for thisComponent in FinalTestT1T3Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thuri6.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thuri6.started', sound_thuri6.tStartRefresh)
thisExp.addData('sound_thuri6.stopped', sound_thuri6.tStopRefresh)
thisExp.addData('image_thuri9.started', image_thuri9.tStartRefresh)
thisExp.addData('image_thuri9.stopped', image_thuri9.tStopRefresh)
thisExp.addData('text_FT_T1T3.started', text_FT_T1T3.tStartRefresh)
thisExp.addData('text_FT_T1T3.stopped', text_FT_T1T3.tStopRefresh)
# check responses
if key_FT_T1T3.keys in ['', [], None]:  # No response was made
    key_FT_T1T3.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T1T3.corr = 1;  # correct non-response
    else:
       key_FT_T1T3.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T3.keys',key_FT_T1T3.keys)
thisExp.addData('key_FT_T1T3.corr', key_FT_T1T3.corr)
if key_FT_T1T3.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T3.rt', key_FT_T1T3.rt)
thisExp.addData('key_FT_T1T3.started', key_FT_T1T3.tStartRefresh)
thisExp.addData('key_FT_T1T3.stopped', key_FT_T1T3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T3.started', phases_FT_T1T3.tStartRefresh)
thisExp.addData('phases_FT_T1T3.stopped', phases_FT_T1T3.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T4"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththami6.setSound('Sounds/ththami.wav', hamming=True)
sound_ththami6.setVolume(1, log=False)
key_FT_T1T4.keys = []
key_FT_T1T4.rt = []
_key_FT_T1T4_allKeys = []
# keep track of which components have finished
FinalTestT1T4Components = [sound_ththami6, image_thami8, text_FT_T1T4, key_FT_T1T4, phases_FT_T1T4]
for thisComponent in FinalTestT1T4Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T4"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T4Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T4Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththami6
    if sound_ththami6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththami6.frameNStart = frameN  # exact frame index
        sound_ththami6.tStart = t  # local t and not account for scr refresh
        sound_ththami6.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththami6.play(when=win)  # sync with win flip
    if sound_ththami6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththami6.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththami6.tStop = t  # not accounting for scr refresh
            sound_ththami6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththami6, 'tStopRefresh')  # time at next scr refresh
            sound_ththami6.stop()
    
    # *image_thami8* updates
    if image_thami8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami8.frameNStart = frameN  # exact frame index
        image_thami8.tStart = t  # local t and not account for scr refresh
        image_thami8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami8, 'tStartRefresh')  # time at next scr refresh
        image_thami8.setAutoDraw(True)
    if image_thami8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami8.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami8.tStop = t  # not accounting for scr refresh
            image_thami8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami8, 'tStopRefresh')  # time at next scr refresh
            image_thami8.setAutoDraw(False)
    
    # *text_FT_T1T4* updates
    if text_FT_T1T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T4.frameNStart = frameN  # exact frame index
        text_FT_T1T4.tStart = t  # local t and not account for scr refresh
        text_FT_T1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T4, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T4.setAutoDraw(True)
    if text_FT_T1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T4.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T4.tStop = t  # not accounting for scr refresh
            text_FT_T1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T4, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T4.setAutoDraw(False)
    
    # *key_FT_T1T4* updates
    waitOnFlip = False
    if key_FT_T1T4.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T4.frameNStart = frameN  # exact frame index
        key_FT_T1T4.tStart = t  # local t and not account for scr refresh
        key_FT_T1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T4, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T4.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T4.tStop = t  # not accounting for scr refresh
            key_FT_T1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T4, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T4.status = FINISHED
    if key_FT_T1T4.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T4.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T4_allKeys.extend(theseKeys)
        if len(_key_FT_T1T4_allKeys):
            key_FT_T1T4.keys = _key_FT_T1T4_allKeys[-1].name  # just the last key pressed
            key_FT_T1T4.rt = _key_FT_T1T4_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T4.keys == str('0')) or (key_FT_T1T4.keys == '0'):
                key_FT_T1T4.corr = 1
            else:
                key_FT_T1T4.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T4* updates
    if phases_FT_T1T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T4.frameNStart = frameN  # exact frame index
        phases_FT_T1T4.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T4, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T4.setAutoDraw(True)
    if phases_FT_T1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T4.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T4.tStop = t  # not accounting for scr refresh
            phases_FT_T1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T4, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T4.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T4Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T4"-------
for thisComponent in FinalTestT1T4Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththami6.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththami6.started', sound_ththami6.tStartRefresh)
thisExp.addData('sound_ththami6.stopped', sound_ththami6.tStopRefresh)
thisExp.addData('image_thami8.started', image_thami8.tStartRefresh)
thisExp.addData('image_thami8.stopped', image_thami8.tStopRefresh)
thisExp.addData('text_FT_T1T4.started', text_FT_T1T4.tStartRefresh)
thisExp.addData('text_FT_T1T4.stopped', text_FT_T1T4.tStopRefresh)
# check responses
if key_FT_T1T4.keys in ['', [], None]:  # No response was made
    key_FT_T1T4.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T1T4.corr = 1;  # correct non-response
    else:
       key_FT_T1T4.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T4.keys',key_FT_T1T4.keys)
thisExp.addData('key_FT_T1T4.corr', key_FT_T1T4.corr)
if key_FT_T1T4.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T4.rt', key_FT_T1T4.rt)
thisExp.addData('key_FT_T1T4.started', key_FT_T1T4.tStartRefresh)
thisExp.addData('key_FT_T1T4.stopped', key_FT_T1T4.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T4.started', phases_FT_T1T4.tStartRefresh)
thisExp.addData('phases_FT_T1T4.stopped', phases_FT_T1T4.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T5"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thano6.setSound('Sounds/thano.wav', hamming=True)
sound_thano6.setVolume(1, log=False)
key_FT_T1T5.keys = []
key_FT_T1T5.rt = []
_key_FT_T1T5_allKeys = []
# keep track of which components have finished
FinalTestT1T5Components = [sound_thano6, image_thano8, text_FT_T1T5, key_FT_T1T5, phases_FT_T1T5]
for thisComponent in FinalTestT1T5Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T5"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T5Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T5Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thano6
    if sound_thano6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thano6.frameNStart = frameN  # exact frame index
        sound_thano6.tStart = t  # local t and not account for scr refresh
        sound_thano6.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thano6.play(when=win)  # sync with win flip
    if sound_thano6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thano6.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thano6.tStop = t  # not accounting for scr refresh
            sound_thano6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thano6, 'tStopRefresh')  # time at next scr refresh
            sound_thano6.stop()
    
    # *image_thano8* updates
    if image_thano8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano8.frameNStart = frameN  # exact frame index
        image_thano8.tStart = t  # local t and not account for scr refresh
        image_thano8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano8, 'tStartRefresh')  # time at next scr refresh
        image_thano8.setAutoDraw(True)
    if image_thano8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano8.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano8.tStop = t  # not accounting for scr refresh
            image_thano8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano8, 'tStopRefresh')  # time at next scr refresh
            image_thano8.setAutoDraw(False)
    
    # *text_FT_T1T5* updates
    if text_FT_T1T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T5.frameNStart = frameN  # exact frame index
        text_FT_T1T5.tStart = t  # local t and not account for scr refresh
        text_FT_T1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T5, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T5.setAutoDraw(True)
    if text_FT_T1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T5.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T5.tStop = t  # not accounting for scr refresh
            text_FT_T1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T5, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T5.setAutoDraw(False)
    
    # *key_FT_T1T5* updates
    waitOnFlip = False
    if key_FT_T1T5.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T5.frameNStart = frameN  # exact frame index
        key_FT_T1T5.tStart = t  # local t and not account for scr refresh
        key_FT_T1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T5, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T5.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T5.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T5.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T5.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T5.tStop = t  # not accounting for scr refresh
            key_FT_T1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T5, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T5.status = FINISHED
    if key_FT_T1T5.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T5.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T5_allKeys.extend(theseKeys)
        if len(_key_FT_T1T5_allKeys):
            key_FT_T1T5.keys = _key_FT_T1T5_allKeys[-1].name  # just the last key pressed
            key_FT_T1T5.rt = _key_FT_T1T5_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T5.keys == str('1')) or (key_FT_T1T5.keys == '1'):
                key_FT_T1T5.corr = 1
            else:
                key_FT_T1T5.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T5* updates
    if phases_FT_T1T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T5.frameNStart = frameN  # exact frame index
        phases_FT_T1T5.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T5, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T5.setAutoDraw(True)
    if phases_FT_T1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T5.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T5.tStop = t  # not accounting for scr refresh
            phases_FT_T1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T5, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T5.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T5Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T5"-------
for thisComponent in FinalTestT1T5Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thano6.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thano6.started', sound_thano6.tStartRefresh)
thisExp.addData('sound_thano6.stopped', sound_thano6.tStopRefresh)
thisExp.addData('image_thano8.started', image_thano8.tStartRefresh)
thisExp.addData('image_thano8.stopped', image_thano8.tStopRefresh)
thisExp.addData('text_FT_T1T5.started', text_FT_T1T5.tStartRefresh)
thisExp.addData('text_FT_T1T5.stopped', text_FT_T1T5.tStopRefresh)
# check responses
if key_FT_T1T5.keys in ['', [], None]:  # No response was made
    key_FT_T1T5.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T1T5.corr = 1;  # correct non-response
    else:
       key_FT_T1T5.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T5.keys',key_FT_T1T5.keys)
thisExp.addData('key_FT_T1T5.corr', key_FT_T1T5.corr)
if key_FT_T1T5.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T5.rt', key_FT_T1T5.rt)
thisExp.addData('key_FT_T1T5.started', key_FT_T1T5.tStartRefresh)
thisExp.addData('key_FT_T1T5.stopped', key_FT_T1T5.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T5.started', phases_FT_T1T5.tStartRefresh)
thisExp.addData('phases_FT_T1T5.stopped', phases_FT_T1T5.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T6"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththami7.setSound('Sounds/ththami.wav', hamming=True)
sound_ththami7.setVolume(1, log=False)
key_FT_T1T6.keys = []
key_FT_T1T6.rt = []
_key_FT_T1T6_allKeys = []
# keep track of which components have finished
FinalTestT1T6Components = [sound_ththami7, image_ththami9, text_FT_T1T6, key_FT_T1T6, phases_FT_T1T6]
for thisComponent in FinalTestT1T6Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T6"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T6Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T6Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththami7
    if sound_ththami7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththami7.frameNStart = frameN  # exact frame index
        sound_ththami7.tStart = t  # local t and not account for scr refresh
        sound_ththami7.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththami7.play(when=win)  # sync with win flip
    if sound_ththami7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththami7.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththami7.tStop = t  # not accounting for scr refresh
            sound_ththami7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththami7, 'tStopRefresh')  # time at next scr refresh
            sound_ththami7.stop()
    
    # *image_ththami9* updates
    if image_ththami9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami9.frameNStart = frameN  # exact frame index
        image_ththami9.tStart = t  # local t and not account for scr refresh
        image_ththami9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami9, 'tStartRefresh')  # time at next scr refresh
        image_ththami9.setAutoDraw(True)
    if image_ththami9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami9.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami9.tStop = t  # not accounting for scr refresh
            image_ththami9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami9, 'tStopRefresh')  # time at next scr refresh
            image_ththami9.setAutoDraw(False)
    
    # *text_FT_T1T6* updates
    if text_FT_T1T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T6.frameNStart = frameN  # exact frame index
        text_FT_T1T6.tStart = t  # local t and not account for scr refresh
        text_FT_T1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T6, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T6.setAutoDraw(True)
    if text_FT_T1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T6.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T6.tStop = t  # not accounting for scr refresh
            text_FT_T1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T6, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T6.setAutoDraw(False)
    
    # *key_FT_T1T6* updates
    waitOnFlip = False
    if key_FT_T1T6.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T6.frameNStart = frameN  # exact frame index
        key_FT_T1T6.tStart = t  # local t and not account for scr refresh
        key_FT_T1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T6, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T6.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T6.tStop = t  # not accounting for scr refresh
            key_FT_T1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T6, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T6.status = FINISHED
    if key_FT_T1T6.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T6.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T6_allKeys.extend(theseKeys)
        if len(_key_FT_T1T6_allKeys):
            key_FT_T1T6.keys = _key_FT_T1T6_allKeys[-1].name  # just the last key pressed
            key_FT_T1T6.rt = _key_FT_T1T6_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T6.keys == str('1')) or (key_FT_T1T6.keys == '1'):
                key_FT_T1T6.corr = 1
            else:
                key_FT_T1T6.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T6* updates
    if phases_FT_T1T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T6.frameNStart = frameN  # exact frame index
        phases_FT_T1T6.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T6, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T6.setAutoDraw(True)
    if phases_FT_T1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T6.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T6.tStop = t  # not accounting for scr refresh
            phases_FT_T1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T6, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T6.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T6Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T6"-------
for thisComponent in FinalTestT1T6Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththami7.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththami7.started', sound_ththami7.tStartRefresh)
thisExp.addData('sound_ththami7.stopped', sound_ththami7.tStopRefresh)
thisExp.addData('image_ththami9.started', image_ththami9.tStartRefresh)
thisExp.addData('image_ththami9.stopped', image_ththami9.tStopRefresh)
thisExp.addData('text_FT_T1T6.started', text_FT_T1T6.tStartRefresh)
thisExp.addData('text_FT_T1T6.stopped', text_FT_T1T6.tStopRefresh)
# check responses
if key_FT_T1T6.keys in ['', [], None]:  # No response was made
    key_FT_T1T6.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T1T6.corr = 1;  # correct non-response
    else:
       key_FT_T1T6.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T6.keys',key_FT_T1T6.keys)
thisExp.addData('key_FT_T1T6.corr', key_FT_T1T6.corr)
if key_FT_T1T6.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T6.rt', key_FT_T1T6.rt)
thisExp.addData('key_FT_T1T6.started', key_FT_T1T6.tStartRefresh)
thisExp.addData('key_FT_T1T6.stopped', key_FT_T1T6.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T6.started', phases_FT_T1T6.tStartRefresh)
thisExp.addData('phases_FT_T1T6.stopped', phases_FT_T1T6.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T7"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thami7.setSound('Sounds/thami.wav', hamming=True)
sound_thami7.setVolume(1, log=False)
key_FT_T1T7.keys = []
key_FT_T1T7.rt = []
_key_FT_T1T7_allKeys = []
# keep track of which components have finished
FinalTestT1T7Components = [sound_thami7, image_thami9, text_FT_T1T7, key_FT_T1T7, phases_FT_T1T7]
for thisComponent in FinalTestT1T7Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T7"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T7Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T7Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thami7
    if sound_thami7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thami7.frameNStart = frameN  # exact frame index
        sound_thami7.tStart = t  # local t and not account for scr refresh
        sound_thami7.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thami7.play(when=win)  # sync with win flip
    if sound_thami7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thami7.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thami7.tStop = t  # not accounting for scr refresh
            sound_thami7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thami7, 'tStopRefresh')  # time at next scr refresh
            sound_thami7.stop()
    
    # *image_thami9* updates
    if image_thami9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami9.frameNStart = frameN  # exact frame index
        image_thami9.tStart = t  # local t and not account for scr refresh
        image_thami9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami9, 'tStartRefresh')  # time at next scr refresh
        image_thami9.setAutoDraw(True)
    if image_thami9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami9.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami9.tStop = t  # not accounting for scr refresh
            image_thami9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami9, 'tStopRefresh')  # time at next scr refresh
            image_thami9.setAutoDraw(False)
    
    # *text_FT_T1T7* updates
    if text_FT_T1T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T7.frameNStart = frameN  # exact frame index
        text_FT_T1T7.tStart = t  # local t and not account for scr refresh
        text_FT_T1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T7, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T7.setAutoDraw(True)
    if text_FT_T1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T7.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T7.tStop = t  # not accounting for scr refresh
            text_FT_T1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T7, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T7.setAutoDraw(False)
    
    # *key_FT_T1T7* updates
    waitOnFlip = False
    if key_FT_T1T7.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T7.frameNStart = frameN  # exact frame index
        key_FT_T1T7.tStart = t  # local t and not account for scr refresh
        key_FT_T1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T7, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T7.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T7.tStop = t  # not accounting for scr refresh
            key_FT_T1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T7, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T7.status = FINISHED
    if key_FT_T1T7.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T7.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T7_allKeys.extend(theseKeys)
        if len(_key_FT_T1T7_allKeys):
            key_FT_T1T7.keys = _key_FT_T1T7_allKeys[-1].name  # just the last key pressed
            key_FT_T1T7.rt = _key_FT_T1T7_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T7.keys == str('1')) or (key_FT_T1T7.keys == '1'):
                key_FT_T1T7.corr = 1
            else:
                key_FT_T1T7.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T7* updates
    if phases_FT_T1T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T7.frameNStart = frameN  # exact frame index
        phases_FT_T1T7.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T7, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T7.setAutoDraw(True)
    if phases_FT_T1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T7.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T7.tStop = t  # not accounting for scr refresh
            phases_FT_T1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T7, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T7.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T7Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T7"-------
for thisComponent in FinalTestT1T7Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thami7.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thami7.started', sound_thami7.tStartRefresh)
thisExp.addData('sound_thami7.stopped', sound_thami7.tStopRefresh)
thisExp.addData('image_thami9.started', image_thami9.tStartRefresh)
thisExp.addData('image_thami9.stopped', image_thami9.tStopRefresh)
thisExp.addData('text_FT_T1T7.started', text_FT_T1T7.tStartRefresh)
thisExp.addData('text_FT_T1T7.stopped', text_FT_T1T7.tStopRefresh)
# check responses
if key_FT_T1T7.keys in ['', [], None]:  # No response was made
    key_FT_T1T7.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T1T7.corr = 1;  # correct non-response
    else:
       key_FT_T1T7.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T7.keys',key_FT_T1T7.keys)
thisExp.addData('key_FT_T1T7.corr', key_FT_T1T7.corr)
if key_FT_T1T7.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T7.rt', key_FT_T1T7.rt)
thisExp.addData('key_FT_T1T7.started', key_FT_T1T7.tStartRefresh)
thisExp.addData('key_FT_T1T7.stopped', key_FT_T1T7.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T7.started', phases_FT_T1T7.tStartRefresh)
thisExp.addData('phases_FT_T1T7.stopped', phases_FT_T1T7.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T8"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththano6.setSound('Sounds/ththano.wav', hamming=True)
sound_ththano6.setVolume(1, log=False)
key_FT_T1T8.keys = []
key_FT_T1T8.rt = []
_key_FT_T1T8_allKeys = []
# keep track of which components have finished
FinalTestT1T8Components = [sound_ththano6, image_thano9, text_FT_T1T8, key_FT_T1T8, phases_FT_T1T8]
for thisComponent in FinalTestT1T8Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T8"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T8Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T8Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththano6
    if sound_ththano6.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththano6.frameNStart = frameN  # exact frame index
        sound_ththano6.tStart = t  # local t and not account for scr refresh
        sound_ththano6.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththano6.play(when=win)  # sync with win flip
    if sound_ththano6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththano6.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththano6.tStop = t  # not accounting for scr refresh
            sound_ththano6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththano6, 'tStopRefresh')  # time at next scr refresh
            sound_ththano6.stop()
    
    # *image_thano9* updates
    if image_thano9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano9.frameNStart = frameN  # exact frame index
        image_thano9.tStart = t  # local t and not account for scr refresh
        image_thano9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano9, 'tStartRefresh')  # time at next scr refresh
        image_thano9.setAutoDraw(True)
    if image_thano9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano9.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano9.tStop = t  # not accounting for scr refresh
            image_thano9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano9, 'tStopRefresh')  # time at next scr refresh
            image_thano9.setAutoDraw(False)
    
    # *text_FT_T1T8* updates
    if text_FT_T1T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T8.frameNStart = frameN  # exact frame index
        text_FT_T1T8.tStart = t  # local t and not account for scr refresh
        text_FT_T1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T8, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T8.setAutoDraw(True)
    if text_FT_T1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T8.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T8.tStop = t  # not accounting for scr refresh
            text_FT_T1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T8, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T8.setAutoDraw(False)
    
    # *key_FT_T1T8* updates
    waitOnFlip = False
    if key_FT_T1T8.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T8.frameNStart = frameN  # exact frame index
        key_FT_T1T8.tStart = t  # local t and not account for scr refresh
        key_FT_T1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T8, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T8.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T8.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T8.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T8.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T8.tStop = t  # not accounting for scr refresh
            key_FT_T1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T8, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T8.status = FINISHED
    if key_FT_T1T8.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T8.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T8_allKeys.extend(theseKeys)
        if len(_key_FT_T1T8_allKeys):
            key_FT_T1T8.keys = _key_FT_T1T8_allKeys[-1].name  # just the last key pressed
            key_FT_T1T8.rt = _key_FT_T1T8_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T8.keys == str('0')) or (key_FT_T1T8.keys == '0'):
                key_FT_T1T8.corr = 1
            else:
                key_FT_T1T8.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T8* updates
    if phases_FT_T1T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T8.frameNStart = frameN  # exact frame index
        phases_FT_T1T8.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T8, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T8.setAutoDraw(True)
    if phases_FT_T1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T8.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T8.tStop = t  # not accounting for scr refresh
            phases_FT_T1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T8, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T8.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T8Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T8"-------
for thisComponent in FinalTestT1T8Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththano6.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththano6.started', sound_ththano6.tStartRefresh)
thisExp.addData('sound_ththano6.stopped', sound_ththano6.tStopRefresh)
thisExp.addData('image_thano9.started', image_thano9.tStartRefresh)
thisExp.addData('image_thano9.stopped', image_thano9.tStopRefresh)
thisExp.addData('text_FT_T1T8.started', text_FT_T1T8.tStartRefresh)
thisExp.addData('text_FT_T1T8.stopped', text_FT_T1T8.tStopRefresh)
# check responses
if key_FT_T1T8.keys in ['', [], None]:  # No response was made
    key_FT_T1T8.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T1T8.corr = 1;  # correct non-response
    else:
       key_FT_T1T8.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T8.keys',key_FT_T1T8.keys)
thisExp.addData('key_FT_T1T8.corr', key_FT_T1T8.corr)
if key_FT_T1T8.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T8.rt', key_FT_T1T8.rt)
thisExp.addData('key_FT_T1T8.started', key_FT_T1T8.tStartRefresh)
thisExp.addData('key_FT_T1T8.stopped', key_FT_T1T8.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T8.started', phases_FT_T1T8.tStartRefresh)
thisExp.addData('phases_FT_T1T8.stopped', phases_FT_T1T8.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T9"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththuri7.setSound('Sounds/ththuri.wav', hamming=True)
sound_ththuri7.setVolume(1, log=False)
key_FT_T1T9.keys = []
key_FT_T1T9.rt = []
_key_FT_T1T9_allKeys = []
# keep track of which components have finished
FinalTestT1T9Components = [sound_ththuri7, image_ththuri8, text_FT_T1T9, key_FT_T1T9, phases_FT_T1T9]
for thisComponent in FinalTestT1T9Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T9"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T9Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T9Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththuri7
    if sound_ththuri7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththuri7.frameNStart = frameN  # exact frame index
        sound_ththuri7.tStart = t  # local t and not account for scr refresh
        sound_ththuri7.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththuri7.play(when=win)  # sync with win flip
    if sound_ththuri7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththuri7.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththuri7.tStop = t  # not accounting for scr refresh
            sound_ththuri7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththuri7, 'tStopRefresh')  # time at next scr refresh
            sound_ththuri7.stop()
    
    # *image_ththuri8* updates
    if image_ththuri8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri8.frameNStart = frameN  # exact frame index
        image_ththuri8.tStart = t  # local t and not account for scr refresh
        image_ththuri8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri8, 'tStartRefresh')  # time at next scr refresh
        image_ththuri8.setAutoDraw(True)
    if image_ththuri8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri8.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri8.tStop = t  # not accounting for scr refresh
            image_ththuri8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri8, 'tStopRefresh')  # time at next scr refresh
            image_ththuri8.setAutoDraw(False)
    
    # *text_FT_T1T9* updates
    if text_FT_T1T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T9.frameNStart = frameN  # exact frame index
        text_FT_T1T9.tStart = t  # local t and not account for scr refresh
        text_FT_T1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T9, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T9.setAutoDraw(True)
    if text_FT_T1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T9.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T9.tStop = t  # not accounting for scr refresh
            text_FT_T1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T9, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T9.setAutoDraw(False)
    
    # *key_FT_T1T9* updates
    waitOnFlip = False
    if key_FT_T1T9.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T9.frameNStart = frameN  # exact frame index
        key_FT_T1T9.tStart = t  # local t and not account for scr refresh
        key_FT_T1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T9, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T9.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T9.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T9.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T9.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T9.tStop = t  # not accounting for scr refresh
            key_FT_T1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T9, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T9.status = FINISHED
    if key_FT_T1T9.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T9.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T9_allKeys.extend(theseKeys)
        if len(_key_FT_T1T9_allKeys):
            key_FT_T1T9.keys = _key_FT_T1T9_allKeys[-1].name  # just the last key pressed
            key_FT_T1T9.rt = _key_FT_T1T9_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T9.keys == str('1')) or (key_FT_T1T9.keys == '1'):
                key_FT_T1T9.corr = 1
            else:
                key_FT_T1T9.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T9* updates
    if phases_FT_T1T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T9.frameNStart = frameN  # exact frame index
        phases_FT_T1T9.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T9, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T9.setAutoDraw(True)
    if phases_FT_T1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T9.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T9.tStop = t  # not accounting for scr refresh
            phases_FT_T1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T9, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T9.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T9Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T9"-------
for thisComponent in FinalTestT1T9Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththuri7.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththuri7.started', sound_ththuri7.tStartRefresh)
thisExp.addData('sound_ththuri7.stopped', sound_ththuri7.tStopRefresh)
thisExp.addData('image_ththuri8.started', image_ththuri8.tStartRefresh)
thisExp.addData('image_ththuri8.stopped', image_ththuri8.tStopRefresh)
thisExp.addData('text_FT_T1T9.started', text_FT_T1T9.tStartRefresh)
thisExp.addData('text_FT_T1T9.stopped', text_FT_T1T9.tStopRefresh)
# check responses
if key_FT_T1T9.keys in ['', [], None]:  # No response was made
    key_FT_T1T9.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T1T9.corr = 1;  # correct non-response
    else:
       key_FT_T1T9.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T9.keys',key_FT_T1T9.keys)
thisExp.addData('key_FT_T1T9.corr', key_FT_T1T9.corr)
if key_FT_T1T9.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T9.rt', key_FT_T1T9.rt)
thisExp.addData('key_FT_T1T9.started', key_FT_T1T9.tStartRefresh)
thisExp.addData('key_FT_T1T9.stopped', key_FT_T1T9.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T9.started', phases_FT_T1T9.tStartRefresh)
thisExp.addData('phases_FT_T1T9.stopped', phases_FT_T1T9.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T10"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thano7.setSound('Sounds/thano.wav', hamming=True)
sound_thano7.setVolume(1, log=False)
key_FT_T1T10.keys = []
key_FT_T1T10.rt = []
_key_FT_T1T10_allKeys = []
# keep track of which components have finished
FinalTestT1T10Components = [sound_thano7, image_ththano8, text_FT_T1T10, key_FT_T1T10, phases_FT_T1T10]
for thisComponent in FinalTestT1T10Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T10"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T10Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T10Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thano7
    if sound_thano7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thano7.frameNStart = frameN  # exact frame index
        sound_thano7.tStart = t  # local t and not account for scr refresh
        sound_thano7.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thano7.play(when=win)  # sync with win flip
    if sound_thano7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thano7.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thano7.tStop = t  # not accounting for scr refresh
            sound_thano7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thano7, 'tStopRefresh')  # time at next scr refresh
            sound_thano7.stop()
    
    # *image_ththano8* updates
    if image_ththano8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano8.frameNStart = frameN  # exact frame index
        image_ththano8.tStart = t  # local t and not account for scr refresh
        image_ththano8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano8, 'tStartRefresh')  # time at next scr refresh
        image_ththano8.setAutoDraw(True)
    if image_ththano8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano8.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano8.tStop = t  # not accounting for scr refresh
            image_ththano8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano8, 'tStopRefresh')  # time at next scr refresh
            image_ththano8.setAutoDraw(False)
    
    # *text_FT_T1T10* updates
    if text_FT_T1T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T10.frameNStart = frameN  # exact frame index
        text_FT_T1T10.tStart = t  # local t and not account for scr refresh
        text_FT_T1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T10, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T10.setAutoDraw(True)
    if text_FT_T1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T10.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T10.tStop = t  # not accounting for scr refresh
            text_FT_T1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T10, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T10.setAutoDraw(False)
    
    # *key_FT_T1T10* updates
    waitOnFlip = False
    if key_FT_T1T10.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T10.frameNStart = frameN  # exact frame index
        key_FT_T1T10.tStart = t  # local t and not account for scr refresh
        key_FT_T1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T10, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T10.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T10.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T10.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T10.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T10.tStop = t  # not accounting for scr refresh
            key_FT_T1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T10, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T10.status = FINISHED
    if key_FT_T1T10.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T10.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T10_allKeys.extend(theseKeys)
        if len(_key_FT_T1T10_allKeys):
            key_FT_T1T10.keys = _key_FT_T1T10_allKeys[-1].name  # just the last key pressed
            key_FT_T1T10.rt = _key_FT_T1T10_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T10.keys == str('0')) or (key_FT_T1T10.keys == '0'):
                key_FT_T1T10.corr = 1
            else:
                key_FT_T1T10.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T10* updates
    if phases_FT_T1T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T10.frameNStart = frameN  # exact frame index
        phases_FT_T1T10.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T10, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T10.setAutoDraw(True)
    if phases_FT_T1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T10.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T10.tStop = t  # not accounting for scr refresh
            phases_FT_T1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T10, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T10.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T10Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T10"-------
for thisComponent in FinalTestT1T10Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thano7.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thano7.started', sound_thano7.tStartRefresh)
thisExp.addData('sound_thano7.stopped', sound_thano7.tStopRefresh)
thisExp.addData('image_ththano8.started', image_ththano8.tStartRefresh)
thisExp.addData('image_ththano8.stopped', image_ththano8.tStopRefresh)
thisExp.addData('text_FT_T1T10.started', text_FT_T1T10.tStartRefresh)
thisExp.addData('text_FT_T1T10.stopped', text_FT_T1T10.tStopRefresh)
# check responses
if key_FT_T1T10.keys in ['', [], None]:  # No response was made
    key_FT_T1T10.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T1T10.corr = 1;  # correct non-response
    else:
       key_FT_T1T10.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T10.keys',key_FT_T1T10.keys)
thisExp.addData('key_FT_T1T10.corr', key_FT_T1T10.corr)
if key_FT_T1T10.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T10.rt', key_FT_T1T10.rt)
thisExp.addData('key_FT_T1T10.started', key_FT_T1T10.tStartRefresh)
thisExp.addData('key_FT_T1T10.stopped', key_FT_T1T10.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T10.started', phases_FT_T1T10.tStartRefresh)
thisExp.addData('phases_FT_T1T10.stopped', phases_FT_T1T10.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T11"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thuri7.setSound('Sounds/thuri.wav', hamming=True)
sound_thuri7.setVolume(1, log=False)
key_FT_T1T11.keys = []
key_FT_T1T11.rt = []
_key_FT_T1T11_allKeys = []
# keep track of which components have finished
FinalTestT1T11Components = [sound_thuri7, image_ththuri9, text_FT_T1T11, key_FT_T1T11, phases_FT_T1T11]
for thisComponent in FinalTestT1T11Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T11"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T11Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T11Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thuri7
    if sound_thuri7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thuri7.frameNStart = frameN  # exact frame index
        sound_thuri7.tStart = t  # local t and not account for scr refresh
        sound_thuri7.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thuri7.play(when=win)  # sync with win flip
    if sound_thuri7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thuri7.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thuri7.tStop = t  # not accounting for scr refresh
            sound_thuri7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thuri7, 'tStopRefresh')  # time at next scr refresh
            sound_thuri7.stop()
    
    # *image_ththuri9* updates
    if image_ththuri9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri9.frameNStart = frameN  # exact frame index
        image_ththuri9.tStart = t  # local t and not account for scr refresh
        image_ththuri9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri9, 'tStartRefresh')  # time at next scr refresh
        image_ththuri9.setAutoDraw(True)
    if image_ththuri9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri9.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri9.tStop = t  # not accounting for scr refresh
            image_ththuri9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri9, 'tStopRefresh')  # time at next scr refresh
            image_ththuri9.setAutoDraw(False)
    
    # *text_FT_T1T11* updates
    if text_FT_T1T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T11.frameNStart = frameN  # exact frame index
        text_FT_T1T11.tStart = t  # local t and not account for scr refresh
        text_FT_T1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T11, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T11.setAutoDraw(True)
    if text_FT_T1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T11.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T11.tStop = t  # not accounting for scr refresh
            text_FT_T1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T11, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T11.setAutoDraw(False)
    
    # *key_FT_T1T11* updates
    waitOnFlip = False
    if key_FT_T1T11.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T11.frameNStart = frameN  # exact frame index
        key_FT_T1T11.tStart = t  # local t and not account for scr refresh
        key_FT_T1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T11, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T11.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T11.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T11.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T11.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T11.tStop = t  # not accounting for scr refresh
            key_FT_T1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T11, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T11.status = FINISHED
    if key_FT_T1T11.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T11.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T11_allKeys.extend(theseKeys)
        if len(_key_FT_T1T11_allKeys):
            key_FT_T1T11.keys = _key_FT_T1T11_allKeys[-1].name  # just the last key pressed
            key_FT_T1T11.rt = _key_FT_T1T11_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T11.keys == str('0')) or (key_FT_T1T11.keys == '0'):
                key_FT_T1T11.corr = 1
            else:
                key_FT_T1T11.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T11* updates
    if phases_FT_T1T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T11.frameNStart = frameN  # exact frame index
        phases_FT_T1T11.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T11, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T11.setAutoDraw(True)
    if phases_FT_T1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T11.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T11.tStop = t  # not accounting for scr refresh
            phases_FT_T1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T11, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T11.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T11Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T11"-------
for thisComponent in FinalTestT1T11Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thuri7.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thuri7.started', sound_thuri7.tStartRefresh)
thisExp.addData('sound_thuri7.stopped', sound_thuri7.tStopRefresh)
thisExp.addData('image_ththuri9.started', image_ththuri9.tStartRefresh)
thisExp.addData('image_ththuri9.stopped', image_ththuri9.tStopRefresh)
thisExp.addData('text_FT_T1T11.started', text_FT_T1T11.tStartRefresh)
thisExp.addData('text_FT_T1T11.stopped', text_FT_T1T11.tStopRefresh)
# check responses
if key_FT_T1T11.keys in ['', [], None]:  # No response was made
    key_FT_T1T11.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T1T11.corr = 1;  # correct non-response
    else:
       key_FT_T1T11.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T11.keys',key_FT_T1T11.keys)
thisExp.addData('key_FT_T1T11.corr', key_FT_T1T11.corr)
if key_FT_T1T11.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T11.rt', key_FT_T1T11.rt)
thisExp.addData('key_FT_T1T11.started', key_FT_T1T11.tStartRefresh)
thisExp.addData('key_FT_T1T11.stopped', key_FT_T1T11.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T11.started', phases_FT_T1T11.tStartRefresh)
thisExp.addData('phases_FT_T1T11.stopped', phases_FT_T1T11.tStopRefresh)

# ------Prepare to start Routine "FinalTestT1T12"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththano7.setSound('Sounds/ththano.wav', hamming=True)
sound_ththano7.setVolume(1, log=False)
key_FT_T1T12.keys = []
key_FT_T1T12.rt = []
_key_FT_T1T12_allKeys = []
# keep track of which components have finished
FinalTestT1T12Components = [sound_ththano7, image_ththano9, text_FT_T1T12, key_FT_T1T12, phases_FT_T1T12]
for thisComponent in FinalTestT1T12Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT1T12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT1T12"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT1T12Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT1T12Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththano7
    if sound_ththano7.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththano7.frameNStart = frameN  # exact frame index
        sound_ththano7.tStart = t  # local t and not account for scr refresh
        sound_ththano7.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththano7.play(when=win)  # sync with win flip
    if sound_ththano7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththano7.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththano7.tStop = t  # not accounting for scr refresh
            sound_ththano7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththano7, 'tStopRefresh')  # time at next scr refresh
            sound_ththano7.stop()
    
    # *image_ththano9* updates
    if image_ththano9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano9.frameNStart = frameN  # exact frame index
        image_ththano9.tStart = t  # local t and not account for scr refresh
        image_ththano9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano9, 'tStartRefresh')  # time at next scr refresh
        image_ththano9.setAutoDraw(True)
    if image_ththano9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano9.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano9.tStop = t  # not accounting for scr refresh
            image_ththano9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano9, 'tStopRefresh')  # time at next scr refresh
            image_ththano9.setAutoDraw(False)
    
    # *text_FT_T1T12* updates
    if text_FT_T1T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T1T12.frameNStart = frameN  # exact frame index
        text_FT_T1T12.tStart = t  # local t and not account for scr refresh
        text_FT_T1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T1T12, 'tStartRefresh')  # time at next scr refresh
        text_FT_T1T12.setAutoDraw(True)
    if text_FT_T1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T1T12.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T1T12.tStop = t  # not accounting for scr refresh
            text_FT_T1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T1T12, 'tStopRefresh')  # time at next scr refresh
            text_FT_T1T12.setAutoDraw(False)
    
    # *key_FT_T1T12* updates
    waitOnFlip = False
    if key_FT_T1T12.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T1T12.frameNStart = frameN  # exact frame index
        key_FT_T1T12.tStart = t  # local t and not account for scr refresh
        key_FT_T1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T1T12, 'tStartRefresh')  # time at next scr refresh
        key_FT_T1T12.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T1T12.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T1T12.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T1T12.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T1T12.tStop = t  # not accounting for scr refresh
            key_FT_T1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T1T12, 'tStopRefresh')  # time at next scr refresh
            key_FT_T1T12.status = FINISHED
    if key_FT_T1T12.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T1T12.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T1T12_allKeys.extend(theseKeys)
        if len(_key_FT_T1T12_allKeys):
            key_FT_T1T12.keys = _key_FT_T1T12_allKeys[-1].name  # just the last key pressed
            key_FT_T1T12.rt = _key_FT_T1T12_allKeys[-1].rt
            # was this correct?
            if (key_FT_T1T12.keys == str('1')) or (key_FT_T1T12.keys == '1'):
                key_FT_T1T12.corr = 1
            else:
                key_FT_T1T12.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T1T12* updates
    if phases_FT_T1T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T1T12.frameNStart = frameN  # exact frame index
        phases_FT_T1T12.tStart = t  # local t and not account for scr refresh
        phases_FT_T1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T1T12, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T1T12.setAutoDraw(True)
    if phases_FT_T1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T1T12.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T1T12.tStop = t  # not accounting for scr refresh
            phases_FT_T1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T1T12, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T1T12.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT1T12Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT1T12"-------
for thisComponent in FinalTestT1T12Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththano7.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththano7.started', sound_ththano7.tStartRefresh)
thisExp.addData('sound_ththano7.stopped', sound_ththano7.tStopRefresh)
thisExp.addData('image_ththano9.started', image_ththano9.tStartRefresh)
thisExp.addData('image_ththano9.stopped', image_ththano9.tStopRefresh)
thisExp.addData('text_FT_T1T12.started', text_FT_T1T12.tStartRefresh)
thisExp.addData('text_FT_T1T12.stopped', text_FT_T1T12.tStopRefresh)
# check responses
if key_FT_T1T12.keys in ['', [], None]:  # No response was made
    key_FT_T1T12.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T1T12.corr = 1;  # correct non-response
    else:
       key_FT_T1T12.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T1T12.keys',key_FT_T1T12.keys)
thisExp.addData('key_FT_T1T12.corr', key_FT_T1T12.corr)
if key_FT_T1T12.keys != None:  # we had a response
    thisExp.addData('key_FT_T1T12.rt', key_FT_T1T12.rt)
thisExp.addData('key_FT_T1T12.started', key_FT_T1T12.tStartRefresh)
thisExp.addData('key_FT_T1T12.stopped', key_FT_T1T12.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T1T12.started', phases_FT_T1T12.tStartRefresh)
thisExp.addData('phases_FT_T1T12.stopped', phases_FT_T1T12.tStopRefresh)

# ------Prepare to start Routine "Phase4Instructions2"-------
continueRoutine = True
# update component parameters for each repeat
key_FTinstructions2.keys = []
key_FTinstructions2.rt = []
_key_FTinstructions2_allKeys = []
# keep track of which components have finished
Phase4Instructions2Components = [text_FTinstructiosn2, key_FTinstructions2]
for thisComponent in Phase4Instructions2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase4Instructions2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase4Instructions2"-------
while continueRoutine:
    # get current time
    t = Phase4Instructions2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase4Instructions2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_FTinstructiosn2* updates
    if text_FTinstructiosn2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FTinstructiosn2.frameNStart = frameN  # exact frame index
        text_FTinstructiosn2.tStart = t  # local t and not account for scr refresh
        text_FTinstructiosn2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FTinstructiosn2, 'tStartRefresh')  # time at next scr refresh
        text_FTinstructiosn2.setAutoDraw(True)
    
    # *key_FTinstructions2* updates
    waitOnFlip = False
    if key_FTinstructions2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_FTinstructions2.frameNStart = frameN  # exact frame index
        key_FTinstructions2.tStart = t  # local t and not account for scr refresh
        key_FTinstructions2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FTinstructions2, 'tStartRefresh')  # time at next scr refresh
        key_FTinstructions2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FTinstructions2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FTinstructions2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FTinstructions2.status == STARTED and not waitOnFlip:
        theseKeys = key_FTinstructions2.getKeys(keyList=['space'], waitRelease=False)
        _key_FTinstructions2_allKeys.extend(theseKeys)
        if len(_key_FTinstructions2_allKeys):
            key_FTinstructions2.keys = _key_FTinstructions2_allKeys[-1].name  # just the last key pressed
            key_FTinstructions2.rt = _key_FTinstructions2_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase4Instructions2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase4Instructions2"-------
for thisComponent in Phase4Instructions2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_FTinstructiosn2.started', text_FTinstructiosn2.tStartRefresh)
thisExp.addData('text_FTinstructiosn2.stopped', text_FTinstructiosn2.tStopRefresh)
# check responses
if key_FTinstructions2.keys in ['', [], None]:  # No response was made
    key_FTinstructions2.keys = None
thisExp.addData('key_FTinstructions2.keys',key_FTinstructions2.keys)
if key_FTinstructions2.keys != None:  # we had a response
    thisExp.addData('key_FTinstructions2.rt', key_FTinstructions2.rt)
thisExp.addData('key_FTinstructions2.started', key_FTinstructions2.tStartRefresh)
thisExp.addData('key_FTinstructions2.stopped', key_FTinstructions2.tStopRefresh)
thisExp.nextEntry()
# the Routine "Phase4Instructions2" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "FinalTestT2T1"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththami8.setSound('Sounds/ththami.wav', hamming=True)
sound_ththami8.setVolume(1, log=False)
key_FT_T2T1.keys = []
key_FT_T2T1.rt = []
_key_FT_T2T1_allKeys = []
# keep track of which components have finished
FinalTestT2T1Components = [image_ththami10, image_thami10, text_FT_T2T1_1, text_FT_T2T1_0, sound_ththami8, text_FT_T2T1, key_FT_T2T1, phases_FT_T2T1]
for thisComponent in FinalTestT2T1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T1"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththami10* updates
    if image_ththami10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami10.frameNStart = frameN  # exact frame index
        image_ththami10.tStart = t  # local t and not account for scr refresh
        image_ththami10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami10, 'tStartRefresh')  # time at next scr refresh
        image_ththami10.setAutoDraw(True)
    if image_ththami10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami10.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami10.tStop = t  # not accounting for scr refresh
            image_ththami10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami10, 'tStopRefresh')  # time at next scr refresh
            image_ththami10.setAutoDraw(False)
    
    # *image_thami10* updates
    if image_thami10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami10.frameNStart = frameN  # exact frame index
        image_thami10.tStart = t  # local t and not account for scr refresh
        image_thami10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami10, 'tStartRefresh')  # time at next scr refresh
        image_thami10.setAutoDraw(True)
    if image_thami10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami10.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami10.tStop = t  # not accounting for scr refresh
            image_thami10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami10, 'tStopRefresh')  # time at next scr refresh
            image_thami10.setAutoDraw(False)
    
    # *text_FT_T2T1_1* updates
    if text_FT_T2T1_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T1_1.frameNStart = frameN  # exact frame index
        text_FT_T2T1_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T1_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T1_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T1_1.setAutoDraw(True)
    if text_FT_T2T1_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T1_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T1_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T1_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T1_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T1_1.setAutoDraw(False)
    
    # *text_FT_T2T1_0* updates
    if text_FT_T2T1_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T1_0.frameNStart = frameN  # exact frame index
        text_FT_T2T1_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T1_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T1_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T1_0.setAutoDraw(True)
    if text_FT_T2T1_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T1_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T1_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T1_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T1_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T1_0.setAutoDraw(False)
    # start/stop sound_ththami8
    if sound_ththami8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththami8.frameNStart = frameN  # exact frame index
        sound_ththami8.tStart = t  # local t and not account for scr refresh
        sound_ththami8.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththami8.play(when=win)  # sync with win flip
    if sound_ththami8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththami8.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththami8.tStop = t  # not accounting for scr refresh
            sound_ththami8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththami8, 'tStopRefresh')  # time at next scr refresh
            sound_ththami8.stop()
    
    # *text_FT_T2T1* updates
    if text_FT_T2T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T1.frameNStart = frameN  # exact frame index
        text_FT_T2T1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T1.setAutoDraw(True)
    if text_FT_T2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T1.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T1.tStop = t  # not accounting for scr refresh
            text_FT_T2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T1.setAutoDraw(False)
    
    # *key_FT_T2T1* updates
    waitOnFlip = False
    if key_FT_T2T1.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T1.frameNStart = frameN  # exact frame index
        key_FT_T2T1.tStart = t  # local t and not account for scr refresh
        key_FT_T2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T1, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T1.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T1.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T1.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T1.tStop = t  # not accounting for scr refresh
            key_FT_T2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T1, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T1.status = FINISHED
    if key_FT_T2T1.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T1.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T1_allKeys.extend(theseKeys)
        if len(_key_FT_T2T1_allKeys):
            key_FT_T2T1.keys = _key_FT_T2T1_allKeys[-1].name  # just the last key pressed
            key_FT_T2T1.rt = _key_FT_T2T1_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T1.keys == str('1')) or (key_FT_T2T1.keys == '1'):
                key_FT_T2T1.corr = 1
            else:
                key_FT_T2T1.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T1* updates
    if phases_FT_T2T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T1.frameNStart = frameN  # exact frame index
        phases_FT_T2T1.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T1, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T1.setAutoDraw(True)
    if phases_FT_T2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T1.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T1.tStop = t  # not accounting for scr refresh
            phases_FT_T2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T1, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T1.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T1"-------
for thisComponent in FinalTestT2T1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththami10.started', image_ththami10.tStartRefresh)
thisExp.addData('image_ththami10.stopped', image_ththami10.tStopRefresh)
thisExp.addData('image_thami10.started', image_thami10.tStartRefresh)
thisExp.addData('image_thami10.stopped', image_thami10.tStopRefresh)
thisExp.addData('text_FT_T2T1_1.started', text_FT_T2T1_1.tStartRefresh)
thisExp.addData('text_FT_T2T1_1.stopped', text_FT_T2T1_1.tStopRefresh)
thisExp.addData('text_FT_T2T1_0.started', text_FT_T2T1_0.tStartRefresh)
thisExp.addData('text_FT_T2T1_0.stopped', text_FT_T2T1_0.tStopRefresh)
sound_ththami8.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththami8.started', sound_ththami8.tStartRefresh)
thisExp.addData('sound_ththami8.stopped', sound_ththami8.tStopRefresh)
thisExp.addData('text_FT_T2T1.started', text_FT_T2T1.tStartRefresh)
thisExp.addData('text_FT_T2T1.stopped', text_FT_T2T1.tStopRefresh)
# check responses
if key_FT_T2T1.keys in ['', [], None]:  # No response was made
    key_FT_T2T1.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T2T1.corr = 1;  # correct non-response
    else:
       key_FT_T2T1.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T1.keys',key_FT_T2T1.keys)
thisExp.addData('key_FT_T2T1.corr', key_FT_T2T1.corr)
if key_FT_T2T1.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T1.rt', key_FT_T2T1.rt)
thisExp.addData('key_FT_T2T1.started', key_FT_T2T1.tStartRefresh)
thisExp.addData('key_FT_T2T1.stopped', key_FT_T2T1.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T1.started', phases_FT_T2T1.tStartRefresh)
thisExp.addData('phases_FT_T2T1.stopped', phases_FT_T2T1.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T2"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thano8.setSound('Sounds/thano.wav', hamming=True)
sound_thano8.setVolume(1, log=False)
key_FT_T2T2.keys = []
key_FT_T2T2.rt = []
_key_FT_T2T2_allKeys = []
# keep track of which components have finished
FinalTestT2T2Components = [image_thano10, image_ththano10, text_FT_T2T2_1, text_FT_T2T2_0, sound_thano8, text_FT_T2T2, key_FT_T2T2, phases_FT_T2T2]
for thisComponent in FinalTestT2T2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T2"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_thano10* updates
    if image_thano10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano10.frameNStart = frameN  # exact frame index
        image_thano10.tStart = t  # local t and not account for scr refresh
        image_thano10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano10, 'tStartRefresh')  # time at next scr refresh
        image_thano10.setAutoDraw(True)
    if image_thano10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano10.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano10.tStop = t  # not accounting for scr refresh
            image_thano10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano10, 'tStopRefresh')  # time at next scr refresh
            image_thano10.setAutoDraw(False)
    
    # *image_ththano10* updates
    if image_ththano10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano10.frameNStart = frameN  # exact frame index
        image_ththano10.tStart = t  # local t and not account for scr refresh
        image_ththano10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano10, 'tStartRefresh')  # time at next scr refresh
        image_ththano10.setAutoDraw(True)
    if image_ththano10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano10.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano10.tStop = t  # not accounting for scr refresh
            image_ththano10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano10, 'tStopRefresh')  # time at next scr refresh
            image_ththano10.setAutoDraw(False)
    
    # *text_FT_T2T2_1* updates
    if text_FT_T2T2_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T2_1.frameNStart = frameN  # exact frame index
        text_FT_T2T2_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T2_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T2_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T2_1.setAutoDraw(True)
    if text_FT_T2T2_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T2_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T2_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T2_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T2_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T2_1.setAutoDraw(False)
    
    # *text_FT_T2T2_0* updates
    if text_FT_T2T2_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T2_0.frameNStart = frameN  # exact frame index
        text_FT_T2T2_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T2_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T2_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T2_0.setAutoDraw(True)
    if text_FT_T2T2_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T2_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T2_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T2_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T2_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T2_0.setAutoDraw(False)
    # start/stop sound_thano8
    if sound_thano8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thano8.frameNStart = frameN  # exact frame index
        sound_thano8.tStart = t  # local t and not account for scr refresh
        sound_thano8.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thano8.play(when=win)  # sync with win flip
    if sound_thano8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thano8.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thano8.tStop = t  # not accounting for scr refresh
            sound_thano8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thano8, 'tStopRefresh')  # time at next scr refresh
            sound_thano8.stop()
    
    # *text_FT_T2T2* updates
    if text_FT_T2T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T2.frameNStart = frameN  # exact frame index
        text_FT_T2T2.tStart = t  # local t and not account for scr refresh
        text_FT_T2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T2, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T2.setAutoDraw(True)
    if text_FT_T2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T2.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T2.tStop = t  # not accounting for scr refresh
            text_FT_T2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T2, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T2.setAutoDraw(False)
    
    # *key_FT_T2T2* updates
    waitOnFlip = False
    if key_FT_T2T2.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T2.frameNStart = frameN  # exact frame index
        key_FT_T2T2.tStart = t  # local t and not account for scr refresh
        key_FT_T2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T2, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T2.tStop = t  # not accounting for scr refresh
            key_FT_T2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T2, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T2.status = FINISHED
    if key_FT_T2T2.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T2.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T2_allKeys.extend(theseKeys)
        if len(_key_FT_T2T2_allKeys):
            key_FT_T2T2.keys = _key_FT_T2T2_allKeys[-1].name  # just the last key pressed
            key_FT_T2T2.rt = _key_FT_T2T2_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T2.keys == str('1')) or (key_FT_T2T2.keys == '1'):
                key_FT_T2T2.corr = 1
            else:
                key_FT_T2T2.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T2* updates
    if phases_FT_T2T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T2.frameNStart = frameN  # exact frame index
        phases_FT_T2T2.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T2, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T2.setAutoDraw(True)
    if phases_FT_T2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T2.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T2.tStop = t  # not accounting for scr refresh
            phases_FT_T2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T2, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T2.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T2"-------
for thisComponent in FinalTestT2T2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_thano10.started', image_thano10.tStartRefresh)
thisExp.addData('image_thano10.stopped', image_thano10.tStopRefresh)
thisExp.addData('image_ththano10.started', image_ththano10.tStartRefresh)
thisExp.addData('image_ththano10.stopped', image_ththano10.tStopRefresh)
thisExp.addData('text_FT_T2T2_1.started', text_FT_T2T2_1.tStartRefresh)
thisExp.addData('text_FT_T2T2_1.stopped', text_FT_T2T2_1.tStopRefresh)
thisExp.addData('text_FT_T2T2_0.started', text_FT_T2T2_0.tStartRefresh)
thisExp.addData('text_FT_T2T2_0.stopped', text_FT_T2T2_0.tStopRefresh)
sound_thano8.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thano8.started', sound_thano8.tStartRefresh)
thisExp.addData('sound_thano8.stopped', sound_thano8.tStopRefresh)
thisExp.addData('text_FT_T2T2.started', text_FT_T2T2.tStartRefresh)
thisExp.addData('text_FT_T2T2.stopped', text_FT_T2T2.tStopRefresh)
# check responses
if key_FT_T2T2.keys in ['', [], None]:  # No response was made
    key_FT_T2T2.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T2T2.corr = 1;  # correct non-response
    else:
       key_FT_T2T2.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T2.keys',key_FT_T2T2.keys)
thisExp.addData('key_FT_T2T2.corr', key_FT_T2T2.corr)
if key_FT_T2T2.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T2.rt', key_FT_T2T2.rt)
thisExp.addData('key_FT_T2T2.started', key_FT_T2T2.tStartRefresh)
thisExp.addData('key_FT_T2T2.stopped', key_FT_T2T2.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T2.started', phases_FT_T2T2.tStartRefresh)
thisExp.addData('phases_FT_T2T2.stopped', phases_FT_T2T2.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T3"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thuri8.setSound('Sounds/thuri.wav', hamming=True)
sound_thuri8.setVolume(1, log=False)
key_FT_T2T3.keys = []
key_FT_T2T3.rt = []
_key_FT_T2T3_allKeys = []
# keep track of which components have finished
FinalTestT2T3Components = [image_ththuri10, image_thuri10, text_FT_T2T3_1, text_FT_T2T3_0, sound_thuri8, text_FT_T2T3, key_FT_T2T3, phases_FT_T2T3]
for thisComponent in FinalTestT2T3Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T3"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T3Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T3Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththuri10* updates
    if image_ththuri10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri10.frameNStart = frameN  # exact frame index
        image_ththuri10.tStart = t  # local t and not account for scr refresh
        image_ththuri10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri10, 'tStartRefresh')  # time at next scr refresh
        image_ththuri10.setAutoDraw(True)
    if image_ththuri10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri10.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri10.tStop = t  # not accounting for scr refresh
            image_ththuri10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri10, 'tStopRefresh')  # time at next scr refresh
            image_ththuri10.setAutoDraw(False)
    
    # *image_thuri10* updates
    if image_thuri10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri10.frameNStart = frameN  # exact frame index
        image_thuri10.tStart = t  # local t and not account for scr refresh
        image_thuri10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri10, 'tStartRefresh')  # time at next scr refresh
        image_thuri10.setAutoDraw(True)
    if image_thuri10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri10.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri10.tStop = t  # not accounting for scr refresh
            image_thuri10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri10, 'tStopRefresh')  # time at next scr refresh
            image_thuri10.setAutoDraw(False)
    
    # *text_FT_T2T3_1* updates
    if text_FT_T2T3_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T3_1.frameNStart = frameN  # exact frame index
        text_FT_T2T3_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T3_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T3_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T3_1.setAutoDraw(True)
    if text_FT_T2T3_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T3_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T3_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T3_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T3_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T3_1.setAutoDraw(False)
    
    # *text_FT_T2T3_0* updates
    if text_FT_T2T3_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T3_0.frameNStart = frameN  # exact frame index
        text_FT_T2T3_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T3_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T3_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T3_0.setAutoDraw(True)
    if text_FT_T2T3_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T3_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T3_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T3_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T3_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T3_0.setAutoDraw(False)
    # start/stop sound_thuri8
    if sound_thuri8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thuri8.frameNStart = frameN  # exact frame index
        sound_thuri8.tStart = t  # local t and not account for scr refresh
        sound_thuri8.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thuri8.play(when=win)  # sync with win flip
    if sound_thuri8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thuri8.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thuri8.tStop = t  # not accounting for scr refresh
            sound_thuri8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thuri8, 'tStopRefresh')  # time at next scr refresh
            sound_thuri8.stop()
    
    # *text_FT_T2T3* updates
    if text_FT_T2T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T3.frameNStart = frameN  # exact frame index
        text_FT_T2T3.tStart = t  # local t and not account for scr refresh
        text_FT_T2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T3, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T3.setAutoDraw(True)
    if text_FT_T2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T3.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T3.tStop = t  # not accounting for scr refresh
            text_FT_T2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T3, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T3.setAutoDraw(False)
    
    # *key_FT_T2T3* updates
    waitOnFlip = False
    if key_FT_T2T3.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T3.frameNStart = frameN  # exact frame index
        key_FT_T2T3.tStart = t  # local t and not account for scr refresh
        key_FT_T2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T3, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T3.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T3.tStop = t  # not accounting for scr refresh
            key_FT_T2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T3, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T3.status = FINISHED
    if key_FT_T2T3.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T3.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T3_allKeys.extend(theseKeys)
        if len(_key_FT_T2T3_allKeys):
            key_FT_T2T3.keys = _key_FT_T2T3_allKeys[-1].name  # just the last key pressed
            key_FT_T2T3.rt = _key_FT_T2T3_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T3.keys == str('0')) or (key_FT_T2T3.keys == '0'):
                key_FT_T2T3.corr = 1
            else:
                key_FT_T2T3.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T3* updates
    if phases_FT_T2T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T3.frameNStart = frameN  # exact frame index
        phases_FT_T2T3.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T3, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T3.setAutoDraw(True)
    if phases_FT_T2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T3.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T3.tStop = t  # not accounting for scr refresh
            phases_FT_T2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T3, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T3.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T3Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T3"-------
for thisComponent in FinalTestT2T3Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththuri10.started', image_ththuri10.tStartRefresh)
thisExp.addData('image_ththuri10.stopped', image_ththuri10.tStopRefresh)
thisExp.addData('image_thuri10.started', image_thuri10.tStartRefresh)
thisExp.addData('image_thuri10.stopped', image_thuri10.tStopRefresh)
thisExp.addData('text_FT_T2T3_1.started', text_FT_T2T3_1.tStartRefresh)
thisExp.addData('text_FT_T2T3_1.stopped', text_FT_T2T3_1.tStopRefresh)
thisExp.addData('text_FT_T2T3_0.started', text_FT_T2T3_0.tStartRefresh)
thisExp.addData('text_FT_T2T3_0.stopped', text_FT_T2T3_0.tStopRefresh)
sound_thuri8.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thuri8.started', sound_thuri8.tStartRefresh)
thisExp.addData('sound_thuri8.stopped', sound_thuri8.tStopRefresh)
thisExp.addData('text_FT_T2T3.started', text_FT_T2T3.tStartRefresh)
thisExp.addData('text_FT_T2T3.stopped', text_FT_T2T3.tStopRefresh)
# check responses
if key_FT_T2T3.keys in ['', [], None]:  # No response was made
    key_FT_T2T3.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T2T3.corr = 1;  # correct non-response
    else:
       key_FT_T2T3.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T3.keys',key_FT_T2T3.keys)
thisExp.addData('key_FT_T2T3.corr', key_FT_T2T3.corr)
if key_FT_T2T3.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T3.rt', key_FT_T2T3.rt)
thisExp.addData('key_FT_T2T3.started', key_FT_T2T3.tStartRefresh)
thisExp.addData('key_FT_T2T3.stopped', key_FT_T2T3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T3.started', phases_FT_T2T3.tStartRefresh)
thisExp.addData('phases_FT_T2T3.stopped', phases_FT_T2T3.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T4"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thami8.setSound('Sounds/thami.wav', hamming=True)
sound_thami8.setVolume(1, log=False)
key_FT_T2T4.keys = []
key_FT_T2T4.rt = []
_key_FT_T2T4_allKeys = []
# keep track of which components have finished
FinalTestT2T4Components = [image_thami11, image_ththami11, text_FT_T2T4_1, text_FT_T2T4_0, sound_thami8, text_FT_T2T4, key_FT_T2T4, phases_FT_T2T4]
for thisComponent in FinalTestT2T4Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T4"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T4Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T4Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_thami11* updates
    if image_thami11.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami11.frameNStart = frameN  # exact frame index
        image_thami11.tStart = t  # local t and not account for scr refresh
        image_thami11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami11, 'tStartRefresh')  # time at next scr refresh
        image_thami11.setAutoDraw(True)
    if image_thami11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami11.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami11.tStop = t  # not accounting for scr refresh
            image_thami11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami11, 'tStopRefresh')  # time at next scr refresh
            image_thami11.setAutoDraw(False)
    
    # *image_ththami11* updates
    if image_ththami11.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami11.frameNStart = frameN  # exact frame index
        image_ththami11.tStart = t  # local t and not account for scr refresh
        image_ththami11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami11, 'tStartRefresh')  # time at next scr refresh
        image_ththami11.setAutoDraw(True)
    if image_ththami11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami11.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami11.tStop = t  # not accounting for scr refresh
            image_ththami11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami11, 'tStopRefresh')  # time at next scr refresh
            image_ththami11.setAutoDraw(False)
    
    # *text_FT_T2T4_1* updates
    if text_FT_T2T4_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T4_1.frameNStart = frameN  # exact frame index
        text_FT_T2T4_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T4_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T4_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T4_1.setAutoDraw(True)
    if text_FT_T2T4_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T4_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T4_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T4_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T4_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T4_1.setAutoDraw(False)
    
    # *text_FT_T2T4_0* updates
    if text_FT_T2T4_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T4_0.frameNStart = frameN  # exact frame index
        text_FT_T2T4_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T4_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T4_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T4_0.setAutoDraw(True)
    if text_FT_T2T4_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T4_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T4_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T4_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T4_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T4_0.setAutoDraw(False)
    # start/stop sound_thami8
    if sound_thami8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thami8.frameNStart = frameN  # exact frame index
        sound_thami8.tStart = t  # local t and not account for scr refresh
        sound_thami8.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thami8.play(when=win)  # sync with win flip
    if sound_thami8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thami8.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thami8.tStop = t  # not accounting for scr refresh
            sound_thami8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thami8, 'tStopRefresh')  # time at next scr refresh
            sound_thami8.stop()
    
    # *text_FT_T2T4* updates
    if text_FT_T2T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T4.frameNStart = frameN  # exact frame index
        text_FT_T2T4.tStart = t  # local t and not account for scr refresh
        text_FT_T2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T4, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T4.setAutoDraw(True)
    if text_FT_T2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T4.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T4.tStop = t  # not accounting for scr refresh
            text_FT_T2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T4, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T4.setAutoDraw(False)
    
    # *key_FT_T2T4* updates
    waitOnFlip = False
    if key_FT_T2T4.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T4.frameNStart = frameN  # exact frame index
        key_FT_T2T4.tStart = t  # local t and not account for scr refresh
        key_FT_T2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T4, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T4.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T4.tStop = t  # not accounting for scr refresh
            key_FT_T2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T4, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T4.status = FINISHED
    if key_FT_T2T4.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T4.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T4_allKeys.extend(theseKeys)
        if len(_key_FT_T2T4_allKeys):
            key_FT_T2T4.keys = _key_FT_T2T4_allKeys[-1].name  # just the last key pressed
            key_FT_T2T4.rt = _key_FT_T2T4_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T4.keys == str('1')) or (key_FT_T2T4.keys == '1'):
                key_FT_T2T4.corr = 1
            else:
                key_FT_T2T4.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T4* updates
    if phases_FT_T2T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T4.frameNStart = frameN  # exact frame index
        phases_FT_T2T4.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T4, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T4.setAutoDraw(True)
    if phases_FT_T2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T4.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T4.tStop = t  # not accounting for scr refresh
            phases_FT_T2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T4, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T4.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T4Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T4"-------
for thisComponent in FinalTestT2T4Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_thami11.started', image_thami11.tStartRefresh)
thisExp.addData('image_thami11.stopped', image_thami11.tStopRefresh)
thisExp.addData('image_ththami11.started', image_ththami11.tStartRefresh)
thisExp.addData('image_ththami11.stopped', image_ththami11.tStopRefresh)
thisExp.addData('text_FT_T2T4_1.started', text_FT_T2T4_1.tStartRefresh)
thisExp.addData('text_FT_T2T4_1.stopped', text_FT_T2T4_1.tStopRefresh)
thisExp.addData('text_FT_T2T4_0.started', text_FT_T2T4_0.tStartRefresh)
thisExp.addData('text_FT_T2T4_0.stopped', text_FT_T2T4_0.tStopRefresh)
sound_thami8.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thami8.started', sound_thami8.tStartRefresh)
thisExp.addData('sound_thami8.stopped', sound_thami8.tStopRefresh)
thisExp.addData('text_FT_T2T4.started', text_FT_T2T4.tStartRefresh)
thisExp.addData('text_FT_T2T4.stopped', text_FT_T2T4.tStopRefresh)
# check responses
if key_FT_T2T4.keys in ['', [], None]:  # No response was made
    key_FT_T2T4.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T2T4.corr = 1;  # correct non-response
    else:
       key_FT_T2T4.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T4.keys',key_FT_T2T4.keys)
thisExp.addData('key_FT_T2T4.corr', key_FT_T2T4.corr)
if key_FT_T2T4.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T4.rt', key_FT_T2T4.rt)
thisExp.addData('key_FT_T2T4.started', key_FT_T2T4.tStartRefresh)
thisExp.addData('key_FT_T2T4.stopped', key_FT_T2T4.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T4.started', phases_FT_T2T4.tStartRefresh)
thisExp.addData('phases_FT_T2T4.stopped', phases_FT_T2T4.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T5"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thano9.setSound('Sounds/thano.wav', hamming=True)
sound_thano9.setVolume(0, log=False)
key_FT_T2T5.keys = []
key_FT_T2T5.rt = []
_key_FT_T2T5_allKeys = []
# keep track of which components have finished
FinalTestT2T5Components = [image_ththano11, image_thano11, text_FT_T2T5_1, text_FT_T2T5_0, sound_thano9, text_FT_T2T5, key_FT_T2T5, phases_FT_T2T5]
for thisComponent in FinalTestT2T5Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T5"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T5Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T5Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththano11* updates
    if image_ththano11.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano11.frameNStart = frameN  # exact frame index
        image_ththano11.tStart = t  # local t and not account for scr refresh
        image_ththano11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano11, 'tStartRefresh')  # time at next scr refresh
        image_ththano11.setAutoDraw(True)
    if image_ththano11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano11.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano11.tStop = t  # not accounting for scr refresh
            image_ththano11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano11, 'tStopRefresh')  # time at next scr refresh
            image_ththano11.setAutoDraw(False)
    
    # *image_thano11* updates
    if image_thano11.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano11.frameNStart = frameN  # exact frame index
        image_thano11.tStart = t  # local t and not account for scr refresh
        image_thano11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano11, 'tStartRefresh')  # time at next scr refresh
        image_thano11.setAutoDraw(True)
    if image_thano11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano11.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano11.tStop = t  # not accounting for scr refresh
            image_thano11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano11, 'tStopRefresh')  # time at next scr refresh
            image_thano11.setAutoDraw(False)
    
    # *text_FT_T2T5_1* updates
    if text_FT_T2T5_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T5_1.frameNStart = frameN  # exact frame index
        text_FT_T2T5_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T5_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T5_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T5_1.setAutoDraw(True)
    if text_FT_T2T5_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T5_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T5_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T5_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T5_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T5_1.setAutoDraw(False)
    
    # *text_FT_T2T5_0* updates
    if text_FT_T2T5_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T5_0.frameNStart = frameN  # exact frame index
        text_FT_T2T5_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T5_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T5_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T5_0.setAutoDraw(True)
    if text_FT_T2T5_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T5_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T5_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T5_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T5_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T5_0.setAutoDraw(False)
    # start/stop sound_thano9
    if sound_thano9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thano9.frameNStart = frameN  # exact frame index
        sound_thano9.tStart = t  # local t and not account for scr refresh
        sound_thano9.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thano9.play(when=win)  # sync with win flip
    if sound_thano9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thano9.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thano9.tStop = t  # not accounting for scr refresh
            sound_thano9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thano9, 'tStopRefresh')  # time at next scr refresh
            sound_thano9.stop()
    
    # *text_FT_T2T5* updates
    if text_FT_T2T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T5.frameNStart = frameN  # exact frame index
        text_FT_T2T5.tStart = t  # local t and not account for scr refresh
        text_FT_T2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T5, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T5.setAutoDraw(True)
    if text_FT_T2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T5.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T5.tStop = t  # not accounting for scr refresh
            text_FT_T2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T5, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T5.setAutoDraw(False)
    
    # *key_FT_T2T5* updates
    waitOnFlip = False
    if key_FT_T2T5.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T5.frameNStart = frameN  # exact frame index
        key_FT_T2T5.tStart = t  # local t and not account for scr refresh
        key_FT_T2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T5, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T5.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T5.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T5.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T5.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T5.tStop = t  # not accounting for scr refresh
            key_FT_T2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T5, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T5.status = FINISHED
    if key_FT_T2T5.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T5.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T5_allKeys.extend(theseKeys)
        if len(_key_FT_T2T5_allKeys):
            key_FT_T2T5.keys = _key_FT_T2T5_allKeys[-1].name  # just the last key pressed
            key_FT_T2T5.rt = _key_FT_T2T5_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T5.keys == str('0')) or (key_FT_T2T5.keys == '0'):
                key_FT_T2T5.corr = 1
            else:
                key_FT_T2T5.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T5* updates
    if phases_FT_T2T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T5.frameNStart = frameN  # exact frame index
        phases_FT_T2T5.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T5, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T5.setAutoDraw(True)
    if phases_FT_T2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T5.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T5.tStop = t  # not accounting for scr refresh
            phases_FT_T2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T5, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T5.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T5Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T5"-------
for thisComponent in FinalTestT2T5Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththano11.started', image_ththano11.tStartRefresh)
thisExp.addData('image_ththano11.stopped', image_ththano11.tStopRefresh)
thisExp.addData('image_thano11.started', image_thano11.tStartRefresh)
thisExp.addData('image_thano11.stopped', image_thano11.tStopRefresh)
thisExp.addData('text_FT_T2T5_1.started', text_FT_T2T5_1.tStartRefresh)
thisExp.addData('text_FT_T2T5_1.stopped', text_FT_T2T5_1.tStopRefresh)
thisExp.addData('text_FT_T2T5_0.started', text_FT_T2T5_0.tStartRefresh)
thisExp.addData('text_FT_T2T5_0.stopped', text_FT_T2T5_0.tStopRefresh)
sound_thano9.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thano9.started', sound_thano9.tStartRefresh)
thisExp.addData('sound_thano9.stopped', sound_thano9.tStopRefresh)
thisExp.addData('text_FT_T2T5.started', text_FT_T2T5.tStartRefresh)
thisExp.addData('text_FT_T2T5.stopped', text_FT_T2T5.tStopRefresh)
# check responses
if key_FT_T2T5.keys in ['', [], None]:  # No response was made
    key_FT_T2T5.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T2T5.corr = 1;  # correct non-response
    else:
       key_FT_T2T5.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T5.keys',key_FT_T2T5.keys)
thisExp.addData('key_FT_T2T5.corr', key_FT_T2T5.corr)
if key_FT_T2T5.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T5.rt', key_FT_T2T5.rt)
thisExp.addData('key_FT_T2T5.started', key_FT_T2T5.tStartRefresh)
thisExp.addData('key_FT_T2T5.stopped', key_FT_T2T5.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T5.started', phases_FT_T2T5.tStartRefresh)
thisExp.addData('phases_FT_T2T5.stopped', phases_FT_T2T5.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T6"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththuri8.setSound('Sounds/ththuri.wav', hamming=True)
sound_ththuri8.setVolume(0, log=False)
key_FT_T2T6.keys = []
key_FT_T2T6.rt = []
_key_FT_T2T6_allKeys = []
# keep track of which components have finished
FinalTestT2T6Components = [image_thuri11, image_ththuri11, text_FT_T2T6_1, text_FT_T2T6_0, sound_ththuri8, text_FT_T2T6, key_FT_T2T6, phases_FT_T2T6]
for thisComponent in FinalTestT2T6Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T6"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T6Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T6Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_thuri11* updates
    if image_thuri11.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri11.frameNStart = frameN  # exact frame index
        image_thuri11.tStart = t  # local t and not account for scr refresh
        image_thuri11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri11, 'tStartRefresh')  # time at next scr refresh
        image_thuri11.setAutoDraw(True)
    if image_thuri11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri11.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri11.tStop = t  # not accounting for scr refresh
            image_thuri11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri11, 'tStopRefresh')  # time at next scr refresh
            image_thuri11.setAutoDraw(False)
    
    # *image_ththuri11* updates
    if image_ththuri11.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri11.frameNStart = frameN  # exact frame index
        image_ththuri11.tStart = t  # local t and not account for scr refresh
        image_ththuri11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri11, 'tStartRefresh')  # time at next scr refresh
        image_ththuri11.setAutoDraw(True)
    if image_ththuri11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri11.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri11.tStop = t  # not accounting for scr refresh
            image_ththuri11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri11, 'tStopRefresh')  # time at next scr refresh
            image_ththuri11.setAutoDraw(False)
    
    # *text_FT_T2T6_1* updates
    if text_FT_T2T6_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T6_1.frameNStart = frameN  # exact frame index
        text_FT_T2T6_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T6_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T6_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T6_1.setAutoDraw(True)
    if text_FT_T2T6_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T6_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T6_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T6_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T6_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T6_1.setAutoDraw(False)
    
    # *text_FT_T2T6_0* updates
    if text_FT_T2T6_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T6_0.frameNStart = frameN  # exact frame index
        text_FT_T2T6_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T6_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T6_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T6_0.setAutoDraw(True)
    if text_FT_T2T6_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T6_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T6_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T6_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T6_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T6_0.setAutoDraw(False)
    # start/stop sound_ththuri8
    if sound_ththuri8.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththuri8.frameNStart = frameN  # exact frame index
        sound_ththuri8.tStart = t  # local t and not account for scr refresh
        sound_ththuri8.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththuri8.play(when=win)  # sync with win flip
    if sound_ththuri8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththuri8.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththuri8.tStop = t  # not accounting for scr refresh
            sound_ththuri8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththuri8, 'tStopRefresh')  # time at next scr refresh
            sound_ththuri8.stop()
    
    # *text_FT_T2T6* updates
    if text_FT_T2T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T6.frameNStart = frameN  # exact frame index
        text_FT_T2T6.tStart = t  # local t and not account for scr refresh
        text_FT_T2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T6, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T6.setAutoDraw(True)
    if text_FT_T2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T6.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T6.tStop = t  # not accounting for scr refresh
            text_FT_T2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T6, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T6.setAutoDraw(False)
    
    # *key_FT_T2T6* updates
    waitOnFlip = False
    if key_FT_T2T6.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T6.frameNStart = frameN  # exact frame index
        key_FT_T2T6.tStart = t  # local t and not account for scr refresh
        key_FT_T2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T6, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T6.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T6.tStop = t  # not accounting for scr refresh
            key_FT_T2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T6, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T6.status = FINISHED
    if key_FT_T2T6.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T6.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T6_allKeys.extend(theseKeys)
        if len(_key_FT_T2T6_allKeys):
            key_FT_T2T6.keys = _key_FT_T2T6_allKeys[-1].name  # just the last key pressed
            key_FT_T2T6.rt = _key_FT_T2T6_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T6* updates
    if phases_FT_T2T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T6.frameNStart = frameN  # exact frame index
        phases_FT_T2T6.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T6, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T6.setAutoDraw(True)
    if phases_FT_T2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T6.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T6.tStop = t  # not accounting for scr refresh
            phases_FT_T2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T6, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T6.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T6Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T6"-------
for thisComponent in FinalTestT2T6Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_thuri11.started', image_thuri11.tStartRefresh)
thisExp.addData('image_thuri11.stopped', image_thuri11.tStopRefresh)
thisExp.addData('image_ththuri11.started', image_ththuri11.tStartRefresh)
thisExp.addData('image_ththuri11.stopped', image_ththuri11.tStopRefresh)
thisExp.addData('text_FT_T2T6_1.started', text_FT_T2T6_1.tStartRefresh)
thisExp.addData('text_FT_T2T6_1.stopped', text_FT_T2T6_1.tStopRefresh)
thisExp.addData('text_FT_T2T6_0.started', text_FT_T2T6_0.tStartRefresh)
thisExp.addData('text_FT_T2T6_0.stopped', text_FT_T2T6_0.tStopRefresh)
sound_ththuri8.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththuri8.started', sound_ththuri8.tStartRefresh)
thisExp.addData('sound_ththuri8.stopped', sound_ththuri8.tStopRefresh)
thisExp.addData('text_FT_T2T6.started', text_FT_T2T6.tStartRefresh)
thisExp.addData('text_FT_T2T6.stopped', text_FT_T2T6.tStopRefresh)
# check responses
if key_FT_T2T6.keys in ['', [], None]:  # No response was made
    key_FT_T2T6.keys = None
thisExp.addData('key_FT_T2T6.keys',key_FT_T2T6.keys)
if key_FT_T2T6.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T6.rt', key_FT_T2T6.rt)
thisExp.addData('key_FT_T2T6.started', key_FT_T2T6.tStartRefresh)
thisExp.addData('key_FT_T2T6.stopped', key_FT_T2T6.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T6.started', phases_FT_T2T6.tStartRefresh)
thisExp.addData('phases_FT_T2T6.stopped', phases_FT_T2T6.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T7"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththano9.setSound('Sounds/ththano.wav', hamming=True)
sound_ththano9.setVolume(1, log=False)
key_FT_T2T7.keys = []
key_FT_T2T7.rt = []
_key_FT_T2T7_allKeys = []
# keep track of which components have finished
FinalTestT2T7Components = [image_ththano12, image_thano12, text_FT_T2T7_1, text_FT_T2T7_0, sound_ththano9, text_FT_T2T7, key_FT_T2T7, phases_FT_T2T7]
for thisComponent in FinalTestT2T7Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T7"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T7Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T7Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththano12* updates
    if image_ththano12.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano12.frameNStart = frameN  # exact frame index
        image_ththano12.tStart = t  # local t and not account for scr refresh
        image_ththano12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano12, 'tStartRefresh')  # time at next scr refresh
        image_ththano12.setAutoDraw(True)
    if image_ththano12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano12.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano12.tStop = t  # not accounting for scr refresh
            image_ththano12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano12, 'tStopRefresh')  # time at next scr refresh
            image_ththano12.setAutoDraw(False)
    
    # *image_thano12* updates
    if image_thano12.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano12.frameNStart = frameN  # exact frame index
        image_thano12.tStart = t  # local t and not account for scr refresh
        image_thano12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano12, 'tStartRefresh')  # time at next scr refresh
        image_thano12.setAutoDraw(True)
    if image_thano12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano12.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano12.tStop = t  # not accounting for scr refresh
            image_thano12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano12, 'tStopRefresh')  # time at next scr refresh
            image_thano12.setAutoDraw(False)
    
    # *text_FT_T2T7_1* updates
    if text_FT_T2T7_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T7_1.frameNStart = frameN  # exact frame index
        text_FT_T2T7_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T7_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T7_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T7_1.setAutoDraw(True)
    if text_FT_T2T7_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T7_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T7_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T7_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T7_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T7_1.setAutoDraw(False)
    
    # *text_FT_T2T7_0* updates
    if text_FT_T2T7_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T7_0.frameNStart = frameN  # exact frame index
        text_FT_T2T7_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T7_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T7_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T7_0.setAutoDraw(True)
    if text_FT_T2T7_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T7_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T7_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T7_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T7_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T7_0.setAutoDraw(False)
    # start/stop sound_ththano9
    if sound_ththano9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththano9.frameNStart = frameN  # exact frame index
        sound_ththano9.tStart = t  # local t and not account for scr refresh
        sound_ththano9.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththano9.play(when=win)  # sync with win flip
    if sound_ththano9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththano9.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththano9.tStop = t  # not accounting for scr refresh
            sound_ththano9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththano9, 'tStopRefresh')  # time at next scr refresh
            sound_ththano9.stop()
    
    # *text_FT_T2T7* updates
    if text_FT_T2T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T7.frameNStart = frameN  # exact frame index
        text_FT_T2T7.tStart = t  # local t and not account for scr refresh
        text_FT_T2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T7, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T7.setAutoDraw(True)
    if text_FT_T2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T7.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T7.tStop = t  # not accounting for scr refresh
            text_FT_T2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T7, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T7.setAutoDraw(False)
    
    # *key_FT_T2T7* updates
    waitOnFlip = False
    if key_FT_T2T7.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T7.frameNStart = frameN  # exact frame index
        key_FT_T2T7.tStart = t  # local t and not account for scr refresh
        key_FT_T2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T7, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T7.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T7.tStop = t  # not accounting for scr refresh
            key_FT_T2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T7, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T7.status = FINISHED
    if key_FT_T2T7.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T7.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T7_allKeys.extend(theseKeys)
        if len(_key_FT_T2T7_allKeys):
            key_FT_T2T7.keys = _key_FT_T2T7_allKeys[-1].name  # just the last key pressed
            key_FT_T2T7.rt = _key_FT_T2T7_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T7.keys == str('1')) or (key_FT_T2T7.keys == '1'):
                key_FT_T2T7.corr = 1
            else:
                key_FT_T2T7.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T7* updates
    if phases_FT_T2T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T7.frameNStart = frameN  # exact frame index
        phases_FT_T2T7.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T7, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T7.setAutoDraw(True)
    if phases_FT_T2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T7.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T7.tStop = t  # not accounting for scr refresh
            phases_FT_T2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T7, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T7.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T7Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T7"-------
for thisComponent in FinalTestT2T7Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththano12.started', image_ththano12.tStartRefresh)
thisExp.addData('image_ththano12.stopped', image_ththano12.tStopRefresh)
thisExp.addData('image_thano12.started', image_thano12.tStartRefresh)
thisExp.addData('image_thano12.stopped', image_thano12.tStopRefresh)
thisExp.addData('text_FT_T2T7_1.started', text_FT_T2T7_1.tStartRefresh)
thisExp.addData('text_FT_T2T7_1.stopped', text_FT_T2T7_1.tStopRefresh)
thisExp.addData('text_FT_T2T7_0.started', text_FT_T2T7_0.tStartRefresh)
thisExp.addData('text_FT_T2T7_0.stopped', text_FT_T2T7_0.tStopRefresh)
sound_ththano9.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththano9.started', sound_ththano9.tStartRefresh)
thisExp.addData('sound_ththano9.stopped', sound_ththano9.tStopRefresh)
thisExp.addData('text_FT_T2T7.started', text_FT_T2T7.tStartRefresh)
thisExp.addData('text_FT_T2T7.stopped', text_FT_T2T7.tStopRefresh)
# check responses
if key_FT_T2T7.keys in ['', [], None]:  # No response was made
    key_FT_T2T7.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T2T7.corr = 1;  # correct non-response
    else:
       key_FT_T2T7.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T7.keys',key_FT_T2T7.keys)
thisExp.addData('key_FT_T2T7.corr', key_FT_T2T7.corr)
if key_FT_T2T7.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T7.rt', key_FT_T2T7.rt)
thisExp.addData('key_FT_T2T7.started', key_FT_T2T7.tStartRefresh)
thisExp.addData('key_FT_T2T7.stopped', key_FT_T2T7.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T7.started', phases_FT_T2T7.tStartRefresh)
thisExp.addData('phases_FT_T2T7.stopped', phases_FT_T2T7.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T8"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thami9.setSound('Sounds/thami.wav', hamming=True)
sound_thami9.setVolume(1, log=False)
key_FT_T2T8.keys = []
key_FT_T2T8.rt = []
_key_FT_T2T8_allKeys = []
# keep track of which components have finished
FinalTestT2T8Components = [image_ththami12, image_thami12, text_FT_T2T8_1, text_FT_T2T8_0, sound_thami9, text_FT_T2T8, key_FT_T2T8, phases_FT_T2T8]
for thisComponent in FinalTestT2T8Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T8"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T8Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T8Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththami12* updates
    if image_ththami12.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami12.frameNStart = frameN  # exact frame index
        image_ththami12.tStart = t  # local t and not account for scr refresh
        image_ththami12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami12, 'tStartRefresh')  # time at next scr refresh
        image_ththami12.setAutoDraw(True)
    if image_ththami12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami12.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami12.tStop = t  # not accounting for scr refresh
            image_ththami12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami12, 'tStopRefresh')  # time at next scr refresh
            image_ththami12.setAutoDraw(False)
    
    # *image_thami12* updates
    if image_thami12.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami12.frameNStart = frameN  # exact frame index
        image_thami12.tStart = t  # local t and not account for scr refresh
        image_thami12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami12, 'tStartRefresh')  # time at next scr refresh
        image_thami12.setAutoDraw(True)
    if image_thami12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami12.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami12.tStop = t  # not accounting for scr refresh
            image_thami12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami12, 'tStopRefresh')  # time at next scr refresh
            image_thami12.setAutoDraw(False)
    
    # *text_FT_T2T8_1* updates
    if text_FT_T2T8_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T8_1.frameNStart = frameN  # exact frame index
        text_FT_T2T8_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T8_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T8_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T8_1.setAutoDraw(True)
    if text_FT_T2T8_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T8_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T8_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T8_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T8_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T8_1.setAutoDraw(False)
    
    # *text_FT_T2T8_0* updates
    if text_FT_T2T8_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T8_0.frameNStart = frameN  # exact frame index
        text_FT_T2T8_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T8_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T8_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T8_0.setAutoDraw(True)
    if text_FT_T2T8_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T8_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T8_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T8_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T8_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T8_0.setAutoDraw(False)
    # start/stop sound_thami9
    if sound_thami9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thami9.frameNStart = frameN  # exact frame index
        sound_thami9.tStart = t  # local t and not account for scr refresh
        sound_thami9.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thami9.play(when=win)  # sync with win flip
    if sound_thami9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thami9.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thami9.tStop = t  # not accounting for scr refresh
            sound_thami9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thami9, 'tStopRefresh')  # time at next scr refresh
            sound_thami9.stop()
    
    # *text_FT_T2T8* updates
    if text_FT_T2T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T8.frameNStart = frameN  # exact frame index
        text_FT_T2T8.tStart = t  # local t and not account for scr refresh
        text_FT_T2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T8, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T8.setAutoDraw(True)
    if text_FT_T2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T8.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T8.tStop = t  # not accounting for scr refresh
            text_FT_T2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T8, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T8.setAutoDraw(False)
    
    # *key_FT_T2T8* updates
    waitOnFlip = False
    if key_FT_T2T8.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T8.frameNStart = frameN  # exact frame index
        key_FT_T2T8.tStart = t  # local t and not account for scr refresh
        key_FT_T2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T8, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T8.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T8.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T8.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T8.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T8.tStop = t  # not accounting for scr refresh
            key_FT_T2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T8, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T8.status = FINISHED
    if key_FT_T2T8.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T8.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T8_allKeys.extend(theseKeys)
        if len(_key_FT_T2T8_allKeys):
            key_FT_T2T8.keys = _key_FT_T2T8_allKeys[-1].name  # just the last key pressed
            key_FT_T2T8.rt = _key_FT_T2T8_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T8.keys == str('0')) or (key_FT_T2T8.keys == '0'):
                key_FT_T2T8.corr = 1
            else:
                key_FT_T2T8.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T8* updates
    if phases_FT_T2T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T8.frameNStart = frameN  # exact frame index
        phases_FT_T2T8.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T8, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T8.setAutoDraw(True)
    if phases_FT_T2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T8.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T8.tStop = t  # not accounting for scr refresh
            phases_FT_T2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T8, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T8.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T8Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T8"-------
for thisComponent in FinalTestT2T8Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththami12.started', image_ththami12.tStartRefresh)
thisExp.addData('image_ththami12.stopped', image_ththami12.tStopRefresh)
thisExp.addData('image_thami12.started', image_thami12.tStartRefresh)
thisExp.addData('image_thami12.stopped', image_thami12.tStopRefresh)
thisExp.addData('text_FT_T2T8_1.started', text_FT_T2T8_1.tStartRefresh)
thisExp.addData('text_FT_T2T8_1.stopped', text_FT_T2T8_1.tStopRefresh)
thisExp.addData('text_FT_T2T8_0.started', text_FT_T2T8_0.tStartRefresh)
thisExp.addData('text_FT_T2T8_0.stopped', text_FT_T2T8_0.tStopRefresh)
sound_thami9.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thami9.started', sound_thami9.tStartRefresh)
thisExp.addData('sound_thami9.stopped', sound_thami9.tStopRefresh)
thisExp.addData('text_FT_T2T8.started', text_FT_T2T8.tStartRefresh)
thisExp.addData('text_FT_T2T8.stopped', text_FT_T2T8.tStopRefresh)
# check responses
if key_FT_T2T8.keys in ['', [], None]:  # No response was made
    key_FT_T2T8.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T2T8.corr = 1;  # correct non-response
    else:
       key_FT_T2T8.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T8.keys',key_FT_T2T8.keys)
thisExp.addData('key_FT_T2T8.corr', key_FT_T2T8.corr)
if key_FT_T2T8.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T8.rt', key_FT_T2T8.rt)
thisExp.addData('key_FT_T2T8.started', key_FT_T2T8.tStartRefresh)
thisExp.addData('key_FT_T2T8.stopped', key_FT_T2T8.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T8.started', phases_FT_T2T8.tStartRefresh)
thisExp.addData('phases_FT_T2T8.stopped', phases_FT_T2T8.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T9"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_thuri9.setSound('Sounds/thuri.wav', hamming=True)
sound_thuri9.setVolume(1, log=False)
key_FT_T2T9.keys = []
key_FT_T2T9.rt = []
_key_FT_T2T9_allKeys = []
# keep track of which components have finished
FinalTestT2T9Components = [image_thuri12, image_ththuri12, text_FT_T2T9_1, text_FT_T2T9_0, sound_thuri9, text_FT_T2T9, key_FT_T2T9, phases_FT_T2T9]
for thisComponent in FinalTestT2T9Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T9"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T9Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T9Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_thuri12* updates
    if image_thuri12.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri12.frameNStart = frameN  # exact frame index
        image_thuri12.tStart = t  # local t and not account for scr refresh
        image_thuri12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri12, 'tStartRefresh')  # time at next scr refresh
        image_thuri12.setAutoDraw(True)
    if image_thuri12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri12.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri12.tStop = t  # not accounting for scr refresh
            image_thuri12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri12, 'tStopRefresh')  # time at next scr refresh
            image_thuri12.setAutoDraw(False)
    
    # *image_ththuri12* updates
    if image_ththuri12.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri12.frameNStart = frameN  # exact frame index
        image_ththuri12.tStart = t  # local t and not account for scr refresh
        image_ththuri12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri12, 'tStartRefresh')  # time at next scr refresh
        image_ththuri12.setAutoDraw(True)
    if image_ththuri12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri12.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri12.tStop = t  # not accounting for scr refresh
            image_ththuri12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri12, 'tStopRefresh')  # time at next scr refresh
            image_ththuri12.setAutoDraw(False)
    
    # *text_FT_T2T9_1* updates
    if text_FT_T2T9_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T9_1.frameNStart = frameN  # exact frame index
        text_FT_T2T9_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T9_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T9_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T9_1.setAutoDraw(True)
    if text_FT_T2T9_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T9_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T9_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T9_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T9_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T9_1.setAutoDraw(False)
    
    # *text_FT_T2T9_0* updates
    if text_FT_T2T9_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T9_0.frameNStart = frameN  # exact frame index
        text_FT_T2T9_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T9_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T9_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T9_0.setAutoDraw(True)
    if text_FT_T2T9_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T9_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T9_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T9_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T9_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T9_0.setAutoDraw(False)
    # start/stop sound_thuri9
    if sound_thuri9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thuri9.frameNStart = frameN  # exact frame index
        sound_thuri9.tStart = t  # local t and not account for scr refresh
        sound_thuri9.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thuri9.play(when=win)  # sync with win flip
    if sound_thuri9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thuri9.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_thuri9.tStop = t  # not accounting for scr refresh
            sound_thuri9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thuri9, 'tStopRefresh')  # time at next scr refresh
            sound_thuri9.stop()
    
    # *text_FT_T2T9* updates
    if text_FT_T2T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T9.frameNStart = frameN  # exact frame index
        text_FT_T2T9.tStart = t  # local t and not account for scr refresh
        text_FT_T2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T9, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T9.setAutoDraw(True)
    if text_FT_T2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T9.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T9.tStop = t  # not accounting for scr refresh
            text_FT_T2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T9, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T9.setAutoDraw(False)
    
    # *key_FT_T2T9* updates
    waitOnFlip = False
    if key_FT_T2T9.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T9.frameNStart = frameN  # exact frame index
        key_FT_T2T9.tStart = t  # local t and not account for scr refresh
        key_FT_T2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T9, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T9.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T9.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T9.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T9.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T9.tStop = t  # not accounting for scr refresh
            key_FT_T2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T9, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T9.status = FINISHED
    if key_FT_T2T9.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T9.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T9_allKeys.extend(theseKeys)
        if len(_key_FT_T2T9_allKeys):
            key_FT_T2T9.keys = _key_FT_T2T9_allKeys[-1].name  # just the last key pressed
            key_FT_T2T9.rt = _key_FT_T2T9_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T9.keys == str('1')) or (key_FT_T2T9.keys == '1'):
                key_FT_T2T9.corr = 1
            else:
                key_FT_T2T9.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T9* updates
    if phases_FT_T2T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T9.frameNStart = frameN  # exact frame index
        phases_FT_T2T9.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T9, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T9.setAutoDraw(True)
    if phases_FT_T2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T9.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T9.tStop = t  # not accounting for scr refresh
            phases_FT_T2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T9, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T9.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T9Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T9"-------
for thisComponent in FinalTestT2T9Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_thuri12.started', image_thuri12.tStartRefresh)
thisExp.addData('image_thuri12.stopped', image_thuri12.tStopRefresh)
thisExp.addData('image_ththuri12.started', image_ththuri12.tStartRefresh)
thisExp.addData('image_ththuri12.stopped', image_ththuri12.tStopRefresh)
thisExp.addData('text_FT_T2T9_1.started', text_FT_T2T9_1.tStartRefresh)
thisExp.addData('text_FT_T2T9_1.stopped', text_FT_T2T9_1.tStopRefresh)
thisExp.addData('text_FT_T2T9_0.started', text_FT_T2T9_0.tStartRefresh)
thisExp.addData('text_FT_T2T9_0.stopped', text_FT_T2T9_0.tStopRefresh)
sound_thuri9.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thuri9.started', sound_thuri9.tStartRefresh)
thisExp.addData('sound_thuri9.stopped', sound_thuri9.tStopRefresh)
thisExp.addData('text_FT_T2T9.started', text_FT_T2T9.tStartRefresh)
thisExp.addData('text_FT_T2T9.stopped', text_FT_T2T9.tStopRefresh)
# check responses
if key_FT_T2T9.keys in ['', [], None]:  # No response was made
    key_FT_T2T9.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T2T9.corr = 1;  # correct non-response
    else:
       key_FT_T2T9.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T9.keys',key_FT_T2T9.keys)
thisExp.addData('key_FT_T2T9.corr', key_FT_T2T9.corr)
if key_FT_T2T9.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T9.rt', key_FT_T2T9.rt)
thisExp.addData('key_FT_T2T9.started', key_FT_T2T9.tStartRefresh)
thisExp.addData('key_FT_T2T9.stopped', key_FT_T2T9.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T9.started', phases_FT_T2T9.tStartRefresh)
thisExp.addData('phases_FT_T2T9.stopped', phases_FT_T2T9.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T10"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththami9.setSound('Sounds/ththami.wav', hamming=True)
sound_ththami9.setVolume(1, log=False)
key_FT_T2T10.keys = []
key_FT_T2T10.rt = []
_key_FT_T2T10_allKeys = []
# keep track of which components have finished
FinalTestT2T10Components = [image_thami13, image_ththami13, text_FT_T2T10_1, text_FT_T2T10_0, sound_ththami9, text_FT_T2T10, key_FT_T2T10, phases_FT_T2T10]
for thisComponent in FinalTestT2T10Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T10"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T10Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T10Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_thami13* updates
    if image_thami13.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thami13.frameNStart = frameN  # exact frame index
        image_thami13.tStart = t  # local t and not account for scr refresh
        image_thami13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thami13, 'tStartRefresh')  # time at next scr refresh
        image_thami13.setAutoDraw(True)
    if image_thami13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thami13.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thami13.tStop = t  # not accounting for scr refresh
            image_thami13.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thami13, 'tStopRefresh')  # time at next scr refresh
            image_thami13.setAutoDraw(False)
    
    # *image_ththami13* updates
    if image_ththami13.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththami13.frameNStart = frameN  # exact frame index
        image_ththami13.tStart = t  # local t and not account for scr refresh
        image_ththami13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththami13, 'tStartRefresh')  # time at next scr refresh
        image_ththami13.setAutoDraw(True)
    if image_ththami13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththami13.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththami13.tStop = t  # not accounting for scr refresh
            image_ththami13.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththami13, 'tStopRefresh')  # time at next scr refresh
            image_ththami13.setAutoDraw(False)
    
    # *text_FT_T2T10_1* updates
    if text_FT_T2T10_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T10_1.frameNStart = frameN  # exact frame index
        text_FT_T2T10_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T10_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T10_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T10_1.setAutoDraw(True)
    if text_FT_T2T10_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T10_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T10_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T10_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T10_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T10_1.setAutoDraw(False)
    
    # *text_FT_T2T10_0* updates
    if text_FT_T2T10_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T10_0.frameNStart = frameN  # exact frame index
        text_FT_T2T10_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T10_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T10_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T10_0.setAutoDraw(True)
    if text_FT_T2T10_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T10_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T10_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T10_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T10_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T10_0.setAutoDraw(False)
    # start/stop sound_ththami9
    if sound_ththami9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththami9.frameNStart = frameN  # exact frame index
        sound_ththami9.tStart = t  # local t and not account for scr refresh
        sound_ththami9.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththami9.play(when=win)  # sync with win flip
    if sound_ththami9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththami9.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththami9.tStop = t  # not accounting for scr refresh
            sound_ththami9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththami9, 'tStopRefresh')  # time at next scr refresh
            sound_ththami9.stop()
    
    # *text_FT_T2T10* updates
    if text_FT_T2T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T10.frameNStart = frameN  # exact frame index
        text_FT_T2T10.tStart = t  # local t and not account for scr refresh
        text_FT_T2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T10, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T10.setAutoDraw(True)
    if text_FT_T2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T10.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T10.tStop = t  # not accounting for scr refresh
            text_FT_T2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T10, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T10.setAutoDraw(False)
    
    # *key_FT_T2T10* updates
    waitOnFlip = False
    if key_FT_T2T10.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T10.frameNStart = frameN  # exact frame index
        key_FT_T2T10.tStart = t  # local t and not account for scr refresh
        key_FT_T2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T10, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T10.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T10.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T10.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T10.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T10.tStop = t  # not accounting for scr refresh
            key_FT_T2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T10, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T10.status = FINISHED
    if key_FT_T2T10.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T10.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T10_allKeys.extend(theseKeys)
        if len(_key_FT_T2T10_allKeys):
            key_FT_T2T10.keys = _key_FT_T2T10_allKeys[-1].name  # just the last key pressed
            key_FT_T2T10.rt = _key_FT_T2T10_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T10.keys == str('0')) or (key_FT_T2T10.keys == '0'):
                key_FT_T2T10.corr = 1
            else:
                key_FT_T2T10.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T10* updates
    if phases_FT_T2T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T10.frameNStart = frameN  # exact frame index
        phases_FT_T2T10.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T10, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T10.setAutoDraw(True)
    if phases_FT_T2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T10.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T10.tStop = t  # not accounting for scr refresh
            phases_FT_T2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T10, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T10.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T10Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T10"-------
for thisComponent in FinalTestT2T10Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_thami13.started', image_thami13.tStartRefresh)
thisExp.addData('image_thami13.stopped', image_thami13.tStopRefresh)
thisExp.addData('image_ththami13.started', image_ththami13.tStartRefresh)
thisExp.addData('image_ththami13.stopped', image_ththami13.tStopRefresh)
thisExp.addData('text_FT_T2T10_1.started', text_FT_T2T10_1.tStartRefresh)
thisExp.addData('text_FT_T2T10_1.stopped', text_FT_T2T10_1.tStopRefresh)
thisExp.addData('text_FT_T2T10_0.started', text_FT_T2T10_0.tStartRefresh)
thisExp.addData('text_FT_T2T10_0.stopped', text_FT_T2T10_0.tStopRefresh)
sound_ththami9.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththami9.started', sound_ththami9.tStartRefresh)
thisExp.addData('sound_ththami9.stopped', sound_ththami9.tStopRefresh)
thisExp.addData('text_FT_T2T10.started', text_FT_T2T10.tStartRefresh)
thisExp.addData('text_FT_T2T10.stopped', text_FT_T2T10.tStopRefresh)
# check responses
if key_FT_T2T10.keys in ['', [], None]:  # No response was made
    key_FT_T2T10.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T2T10.corr = 1;  # correct non-response
    else:
       key_FT_T2T10.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T10.keys',key_FT_T2T10.keys)
thisExp.addData('key_FT_T2T10.corr', key_FT_T2T10.corr)
if key_FT_T2T10.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T10.rt', key_FT_T2T10.rt)
thisExp.addData('key_FT_T2T10.started', key_FT_T2T10.tStartRefresh)
thisExp.addData('key_FT_T2T10.stopped', key_FT_T2T10.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T10.started', phases_FT_T2T10.tStartRefresh)
thisExp.addData('phases_FT_T2T10.stopped', phases_FT_T2T10.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T11"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththano10.setSound('Sounds/ththano.wav', hamming=True)
sound_ththano10.setVolume(1, log=False)
key_FT_T2T11.keys = []
key_FT_T2T11.rt = []
_key_FT_T2T11_allKeys = []
# keep track of which components have finished
FinalTestT2T11Components = [image_thano13, image_ththano13, text_FT_T2T11_1, text_FT_T2T11_0, sound_ththano10, text_FT_T2T11, key_FT_T2T11, phases_FT_T2T11]
for thisComponent in FinalTestT2T11Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T11"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T11Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T11Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_thano13* updates
    if image_thano13.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thano13.frameNStart = frameN  # exact frame index
        image_thano13.tStart = t  # local t and not account for scr refresh
        image_thano13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thano13, 'tStartRefresh')  # time at next scr refresh
        image_thano13.setAutoDraw(True)
    if image_thano13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thano13.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thano13.tStop = t  # not accounting for scr refresh
            image_thano13.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thano13, 'tStopRefresh')  # time at next scr refresh
            image_thano13.setAutoDraw(False)
    
    # *image_ththano13* updates
    if image_ththano13.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththano13.frameNStart = frameN  # exact frame index
        image_ththano13.tStart = t  # local t and not account for scr refresh
        image_ththano13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththano13, 'tStartRefresh')  # time at next scr refresh
        image_ththano13.setAutoDraw(True)
    if image_ththano13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththano13.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththano13.tStop = t  # not accounting for scr refresh
            image_ththano13.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththano13, 'tStopRefresh')  # time at next scr refresh
            image_ththano13.setAutoDraw(False)
    
    # *text_FT_T2T11_1* updates
    if text_FT_T2T11_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T11_1.frameNStart = frameN  # exact frame index
        text_FT_T2T11_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T11_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T11_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T11_1.setAutoDraw(True)
    if text_FT_T2T11_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T11_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T11_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T11_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T11_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T11_1.setAutoDraw(False)
    
    # *text_FT_T2T11_0* updates
    if text_FT_T2T11_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T11_0.frameNStart = frameN  # exact frame index
        text_FT_T2T11_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T11_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T11_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T11_0.setAutoDraw(True)
    if text_FT_T2T11_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T11_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T11_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T11_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T11_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T11_0.setAutoDraw(False)
    # start/stop sound_ththano10
    if sound_ththano10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththano10.frameNStart = frameN  # exact frame index
        sound_ththano10.tStart = t  # local t and not account for scr refresh
        sound_ththano10.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththano10.play(when=win)  # sync with win flip
    if sound_ththano10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththano10.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththano10.tStop = t  # not accounting for scr refresh
            sound_ththano10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththano10, 'tStopRefresh')  # time at next scr refresh
            sound_ththano10.stop()
    
    # *text_FT_T2T11* updates
    if text_FT_T2T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T11.frameNStart = frameN  # exact frame index
        text_FT_T2T11.tStart = t  # local t and not account for scr refresh
        text_FT_T2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T11, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T11.setAutoDraw(True)
    if text_FT_T2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T11.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T11.tStop = t  # not accounting for scr refresh
            text_FT_T2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T11, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T11.setAutoDraw(False)
    
    # *key_FT_T2T11* updates
    waitOnFlip = False
    if key_FT_T2T11.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T11.frameNStart = frameN  # exact frame index
        key_FT_T2T11.tStart = t  # local t and not account for scr refresh
        key_FT_T2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T11, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T11.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T11.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T11.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T11.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T11.tStop = t  # not accounting for scr refresh
            key_FT_T2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T11, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T11.status = FINISHED
    if key_FT_T2T11.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T11.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T11_allKeys.extend(theseKeys)
        if len(_key_FT_T2T11_allKeys):
            key_FT_T2T11.keys = _key_FT_T2T11_allKeys[-1].name  # just the last key pressed
            key_FT_T2T11.rt = _key_FT_T2T11_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T11.keys == str('0')) or (key_FT_T2T11.keys == '0'):
                key_FT_T2T11.corr = 1
            else:
                key_FT_T2T11.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T11* updates
    if phases_FT_T2T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T11.frameNStart = frameN  # exact frame index
        phases_FT_T2T11.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T11, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T11.setAutoDraw(True)
    if phases_FT_T2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T11.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T11.tStop = t  # not accounting for scr refresh
            phases_FT_T2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T11, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T11.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T11Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T11"-------
for thisComponent in FinalTestT2T11Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_thano13.started', image_thano13.tStartRefresh)
thisExp.addData('image_thano13.stopped', image_thano13.tStopRefresh)
thisExp.addData('image_ththano13.started', image_ththano13.tStartRefresh)
thisExp.addData('image_ththano13.stopped', image_ththano13.tStopRefresh)
thisExp.addData('text_FT_T2T11_1.started', text_FT_T2T11_1.tStartRefresh)
thisExp.addData('text_FT_T2T11_1.stopped', text_FT_T2T11_1.tStopRefresh)
thisExp.addData('text_FT_T2T11_0.started', text_FT_T2T11_0.tStartRefresh)
thisExp.addData('text_FT_T2T11_0.stopped', text_FT_T2T11_0.tStopRefresh)
sound_ththano10.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththano10.started', sound_ththano10.tStartRefresh)
thisExp.addData('sound_ththano10.stopped', sound_ththano10.tStopRefresh)
thisExp.addData('text_FT_T2T11.started', text_FT_T2T11.tStartRefresh)
thisExp.addData('text_FT_T2T11.stopped', text_FT_T2T11.tStopRefresh)
# check responses
if key_FT_T2T11.keys in ['', [], None]:  # No response was made
    key_FT_T2T11.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_FT_T2T11.corr = 1;  # correct non-response
    else:
       key_FT_T2T11.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T11.keys',key_FT_T2T11.keys)
thisExp.addData('key_FT_T2T11.corr', key_FT_T2T11.corr)
if key_FT_T2T11.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T11.rt', key_FT_T2T11.rt)
thisExp.addData('key_FT_T2T11.started', key_FT_T2T11.tStartRefresh)
thisExp.addData('key_FT_T2T11.stopped', key_FT_T2T11.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T11.started', phases_FT_T2T11.tStartRefresh)
thisExp.addData('phases_FT_T2T11.stopped', phases_FT_T2T11.tStopRefresh)

# ------Prepare to start Routine "FinalTestT2T12"-------
continueRoutine = True
routineTimer.add(9.200000)
# update component parameters for each repeat
sound_ththuri9.setSound('Sounds/ththuri.wav', hamming=True)
sound_ththuri9.setVolume(1, log=False)
key_FT_T2T12.keys = []
key_FT_T2T12.rt = []
_key_FT_T2T12_allKeys = []
# keep track of which components have finished
FinalTestT2T12Components = [image_ththuri13, image_thuri13, text_FT_T2T12_1, text_FT_T2T12_0, sound_ththuri9, text_FT_T2T12, key_FT_T2T12, phases_FT_T2T12]
for thisComponent in FinalTestT2T12Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FinalTestT2T12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FinalTestT2T12"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = FinalTestT2T12Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FinalTestT2T12Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *image_ththuri13* updates
    if image_ththuri13.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_ththuri13.frameNStart = frameN  # exact frame index
        image_ththuri13.tStart = t  # local t and not account for scr refresh
        image_ththuri13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_ththuri13, 'tStartRefresh')  # time at next scr refresh
        image_ththuri13.setAutoDraw(True)
    if image_ththuri13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_ththuri13.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_ththuri13.tStop = t  # not accounting for scr refresh
            image_ththuri13.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_ththuri13, 'tStopRefresh')  # time at next scr refresh
            image_ththuri13.setAutoDraw(False)
    
    # *image_thuri13* updates
    if image_thuri13.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        image_thuri13.frameNStart = frameN  # exact frame index
        image_thuri13.tStart = t  # local t and not account for scr refresh
        image_thuri13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(image_thuri13, 'tStartRefresh')  # time at next scr refresh
        image_thuri13.setAutoDraw(True)
    if image_thuri13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > image_thuri13.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            image_thuri13.tStop = t  # not accounting for scr refresh
            image_thuri13.frameNStop = frameN  # exact frame index
            win.timeOnFlip(image_thuri13, 'tStopRefresh')  # time at next scr refresh
            image_thuri13.setAutoDraw(False)
    
    # *text_FT_T2T12_1* updates
    if text_FT_T2T12_1.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T12_1.frameNStart = frameN  # exact frame index
        text_FT_T2T12_1.tStart = t  # local t and not account for scr refresh
        text_FT_T2T12_1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T12_1, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T12_1.setAutoDraw(True)
    if text_FT_T2T12_1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T12_1.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T12_1.tStop = t  # not accounting for scr refresh
            text_FT_T2T12_1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T12_1, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T12_1.setAutoDraw(False)
    
    # *text_FT_T2T12_0* updates
    if text_FT_T2T12_0.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T12_0.frameNStart = frameN  # exact frame index
        text_FT_T2T12_0.tStart = t  # local t and not account for scr refresh
        text_FT_T2T12_0.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T12_0, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T12_0.setAutoDraw(True)
    if text_FT_T2T12_0.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T12_0.tStartRefresh + 9-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T12_0.tStop = t  # not accounting for scr refresh
            text_FT_T2T12_0.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T12_0, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T12_0.setAutoDraw(False)
    # start/stop sound_ththuri9
    if sound_ththuri9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththuri9.frameNStart = frameN  # exact frame index
        sound_ththuri9.tStart = t  # local t and not account for scr refresh
        sound_ththuri9.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththuri9.play(when=win)  # sync with win flip
    if sound_ththuri9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththuri9.tStartRefresh + 4-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththuri9.tStop = t  # not accounting for scr refresh
            sound_ththuri9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththuri9, 'tStopRefresh')  # time at next scr refresh
            sound_ththuri9.stop()
    
    # *text_FT_T2T12* updates
    if text_FT_T2T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FT_T2T12.frameNStart = frameN  # exact frame index
        text_FT_T2T12.tStart = t  # local t and not account for scr refresh
        text_FT_T2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FT_T2T12, 'tStartRefresh')  # time at next scr refresh
        text_FT_T2T12.setAutoDraw(True)
    if text_FT_T2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_FT_T2T12.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            text_FT_T2T12.tStop = t  # not accounting for scr refresh
            text_FT_T2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_FT_T2T12, 'tStopRefresh')  # time at next scr refresh
            text_FT_T2T12.setAutoDraw(False)
    
    # *key_FT_T2T12* updates
    waitOnFlip = False
    if key_FT_T2T12.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_FT_T2T12.frameNStart = frameN  # exact frame index
        key_FT_T2T12.tStart = t  # local t and not account for scr refresh
        key_FT_T2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FT_T2T12, 'tStartRefresh')  # time at next scr refresh
        key_FT_T2T12.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FT_T2T12.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FT_T2T12.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FT_T2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_FT_T2T12.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            key_FT_T2T12.tStop = t  # not accounting for scr refresh
            key_FT_T2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_FT_T2T12, 'tStopRefresh')  # time at next scr refresh
            key_FT_T2T12.status = FINISHED
    if key_FT_T2T12.status == STARTED and not waitOnFlip:
        theseKeys = key_FT_T2T12.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_FT_T2T12_allKeys.extend(theseKeys)
        if len(_key_FT_T2T12_allKeys):
            key_FT_T2T12.keys = _key_FT_T2T12_allKeys[-1].name  # just the last key pressed
            key_FT_T2T12.rt = _key_FT_T2T12_allKeys[-1].rt
            # was this correct?
            if (key_FT_T2T12.keys == str('1')) or (key_FT_T2T12.keys == '1'):
                key_FT_T2T12.corr = 1
            else:
                key_FT_T2T12.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *phases_FT_T2T12* updates
    if phases_FT_T2T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_FT_T2T12.frameNStart = frameN  # exact frame index
        phases_FT_T2T12.tStart = t  # local t and not account for scr refresh
        phases_FT_T2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_FT_T2T12, 'tStartRefresh')  # time at next scr refresh
        phases_FT_T2T12.setAutoDraw(True)
    if phases_FT_T2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_FT_T2T12.tStartRefresh + 9.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_FT_T2T12.tStop = t  # not accounting for scr refresh
            phases_FT_T2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_FT_T2T12, 'tStopRefresh')  # time at next scr refresh
            phases_FT_T2T12.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FinalTestT2T12Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FinalTestT2T12"-------
for thisComponent in FinalTestT2T12Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('image_ththuri13.started', image_ththuri13.tStartRefresh)
thisExp.addData('image_ththuri13.stopped', image_ththuri13.tStopRefresh)
thisExp.addData('image_thuri13.started', image_thuri13.tStartRefresh)
thisExp.addData('image_thuri13.stopped', image_thuri13.tStopRefresh)
thisExp.addData('text_FT_T2T12_1.started', text_FT_T2T12_1.tStartRefresh)
thisExp.addData('text_FT_T2T12_1.stopped', text_FT_T2T12_1.tStopRefresh)
thisExp.addData('text_FT_T2T12_0.started', text_FT_T2T12_0.tStartRefresh)
thisExp.addData('text_FT_T2T12_0.stopped', text_FT_T2T12_0.tStopRefresh)
sound_ththuri9.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththuri9.started', sound_ththuri9.tStartRefresh)
thisExp.addData('sound_ththuri9.stopped', sound_ththuri9.tStopRefresh)
thisExp.addData('text_FT_T2T12.started', text_FT_T2T12.tStartRefresh)
thisExp.addData('text_FT_T2T12.stopped', text_FT_T2T12.tStopRefresh)
# check responses
if key_FT_T2T12.keys in ['', [], None]:  # No response was made
    key_FT_T2T12.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_FT_T2T12.corr = 1;  # correct non-response
    else:
       key_FT_T2T12.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_FT_T2T12.keys',key_FT_T2T12.keys)
thisExp.addData('key_FT_T2T12.corr', key_FT_T2T12.corr)
if key_FT_T2T12.keys != None:  # we had a response
    thisExp.addData('key_FT_T2T12.rt', key_FT_T2T12.rt)
thisExp.addData('key_FT_T2T12.started', key_FT_T2T12.tStartRefresh)
thisExp.addData('key_FT_T2T12.stopped', key_FT_T2T12.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_FT_T2T12.started', phases_FT_T2T12.tStartRefresh)
thisExp.addData('phases_FT_T2T12.stopped', phases_FT_T2T12.tStopRefresh)

# ------Prepare to start Routine "EndPhase4"-------
continueRoutine = True
# update component parameters for each repeat
key_FTEng.keys = []
key_FTEng.rt = []
_key_FTEng_allKeys = []
# keep track of which components have finished
EndPhase4Components = [text_EndFT, key_FTEng, phases_endFT]
for thisComponent in EndPhase4Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
EndPhase4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "EndPhase4"-------
while continueRoutine:
    # get current time
    t = EndPhase4Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=EndPhase4Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_EndFT* updates
    if text_EndFT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_EndFT.frameNStart = frameN  # exact frame index
        text_EndFT.tStart = t  # local t and not account for scr refresh
        text_EndFT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_EndFT, 'tStartRefresh')  # time at next scr refresh
        text_EndFT.setAutoDraw(True)
    
    # *key_FTEng* updates
    waitOnFlip = False
    if key_FTEng.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_FTEng.frameNStart = frameN  # exact frame index
        key_FTEng.tStart = t  # local t and not account for scr refresh
        key_FTEng.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FTEng, 'tStartRefresh')  # time at next scr refresh
        key_FTEng.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FTEng.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FTEng.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FTEng.status == STARTED and not waitOnFlip:
        theseKeys = key_FTEng.getKeys(keyList=['space'], waitRelease=False)
        _key_FTEng_allKeys.extend(theseKeys)
        if len(_key_FTEng_allKeys):
            key_FTEng.keys = _key_FTEng_allKeys[-1].name  # just the last key pressed
            key_FTEng.rt = _key_FTEng_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # *phases_endFT* updates
    if phases_endFT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_endFT.frameNStart = frameN  # exact frame index
        phases_endFT.tStart = t  # local t and not account for scr refresh
        phases_endFT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_endFT, 'tStartRefresh')  # time at next scr refresh
        phases_endFT.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in EndPhase4Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "EndPhase4"-------
for thisComponent in EndPhase4Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_EndFT.started', text_EndFT.tStartRefresh)
thisExp.addData('text_EndFT.stopped', text_EndFT.tStopRefresh)
# check responses
if key_FTEng.keys in ['', [], None]:  # No response was made
    key_FTEng.keys = None
thisExp.addData('key_FTEng.keys',key_FTEng.keys)
if key_FTEng.keys != None:  # we had a response
    thisExp.addData('key_FTEng.rt', key_FTEng.rt)
thisExp.addData('key_FTEng.started', key_FTEng.tStartRefresh)
thisExp.addData('key_FTEng.stopped', key_FTEng.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_endFT.started', phases_endFT.tStartRefresh)
thisExp.addData('phases_endFT.stopped', phases_endFT.tStopRefresh)
# the Routine "EndPhase4" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Phase5Instructions1"-------
continueRoutine = True
# update component parameters for each repeat
key_SRpos_instructions.keys = []
key_SRpos_instructions.rt = []
_key_SRpos_instructions_allKeys = []
# keep track of which components have finished
Phase5Instructions1Components = [text_SRpos_tinstructions1, key_SRpos_instructions]
for thisComponent in Phase5Instructions1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5Instructions1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5Instructions1"-------
while continueRoutine:
    # get current time
    t = Phase5Instructions1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5Instructions1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_SRpos_tinstructions1* updates
    if text_SRpos_tinstructions1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_SRpos_tinstructions1.frameNStart = frameN  # exact frame index
        text_SRpos_tinstructions1.tStart = t  # local t and not account for scr refresh
        text_SRpos_tinstructions1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_SRpos_tinstructions1, 'tStartRefresh')  # time at next scr refresh
        text_SRpos_tinstructions1.setAutoDraw(True)
    
    # *key_SRpos_instructions* updates
    waitOnFlip = False
    if key_SRpos_instructions.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_SRpos_instructions.frameNStart = frameN  # exact frame index
        key_SRpos_instructions.tStart = t  # local t and not account for scr refresh
        key_SRpos_instructions.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_SRpos_instructions, 'tStartRefresh')  # time at next scr refresh
        key_SRpos_instructions.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_SRpos_instructions.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_SRpos_instructions.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_SRpos_instructions.status == STARTED and not waitOnFlip:
        theseKeys = key_SRpos_instructions.getKeys(keyList=['space'], waitRelease=False)
        _key_SRpos_instructions_allKeys.extend(theseKeys)
        if len(_key_SRpos_instructions_allKeys):
            key_SRpos_instructions.keys = _key_SRpos_instructions_allKeys[-1].name  # just the last key pressed
            key_SRpos_instructions.rt = _key_SRpos_instructions_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5Instructions1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5Instructions1"-------
for thisComponent in Phase5Instructions1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_SRpos_tinstructions1.started', text_SRpos_tinstructions1.tStartRefresh)
thisExp.addData('text_SRpos_tinstructions1.stopped', text_SRpos_tinstructions1.tStopRefresh)
# check responses
if key_SRpos_instructions.keys in ['', [], None]:  # No response was made
    key_SRpos_instructions.keys = None
thisExp.addData('key_SRpos_instructions.keys',key_SRpos_instructions.keys)
if key_SRpos_instructions.keys != None:  # we had a response
    thisExp.addData('key_SRpos_instructions.rt', key_SRpos_instructions.rt)
thisExp.addData('key_SRpos_instructions.started', key_SRpos_instructions.tStartRefresh)
thisExp.addData('key_SRpos_instructions.stopped', key_SRpos_instructions.tStopRefresh)
thisExp.nextEntry()
# the Routine "Phase5Instructions1" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Phase5T1T1"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_thth9.setSound('Sounds/thth.wav', hamming=True)
sound_thth9.setVolume(1, log=False)
sound_th6.setSound('Sounds/th.wav', hamming=True)
sound_th6.setVolume(1, log=False)
key_Ph5T1T1.keys = []
key_Ph5T1T1.rt = []
_key_Ph5T1T1_allKeys = []
# keep track of which components have finished
Phase5T1T1Components = [sound_thth9, sound_th6, key_Ph5T1T1, text_Ph5T1T1, phases_Ph5T1T1]
for thisComponent in Phase5T1T1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T1"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thth9
    if sound_thth9.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thth9.frameNStart = frameN  # exact frame index
        sound_thth9.tStart = t  # local t and not account for scr refresh
        sound_thth9.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth9.play(when=win)  # sync with win flip
    if sound_thth9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth9.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth9.tStop = t  # not accounting for scr refresh
            sound_thth9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth9, 'tStopRefresh')  # time at next scr refresh
            sound_thth9.stop()
    # start/stop sound_th6
    if sound_th6.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_th6.frameNStart = frameN  # exact frame index
        sound_th6.tStart = t  # local t and not account for scr refresh
        sound_th6.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th6.play(when=win)  # sync with win flip
    if sound_th6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th6.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th6.tStop = t  # not accounting for scr refresh
            sound_th6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th6, 'tStopRefresh')  # time at next scr refresh
            sound_th6.stop()
    
    # *key_Ph5T1T1* updates
    waitOnFlip = False
    if key_Ph5T1T1.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T1.frameNStart = frameN  # exact frame index
        key_Ph5T1T1.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T1, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T1.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T1.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T1.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T1.tStop = t  # not accounting for scr refresh
            key_Ph5T1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T1, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T1.status = FINISHED
    if key_Ph5T1T1.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T1.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T1_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T1_allKeys):
            key_Ph5T1T1.keys = _key_Ph5T1T1_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T1.rt = _key_Ph5T1T1_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T1.keys == str('0')) or (key_Ph5T1T1.keys == '0'):
                key_Ph5T1T1.corr = 1
            else:
                key_Ph5T1T1.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T1* updates
    if text_Ph5T1T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T1.frameNStart = frameN  # exact frame index
        text_Ph5T1T1.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T1, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T1.setAutoDraw(True)
    if text_Ph5T1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T1.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T1.tStop = t  # not accounting for scr refresh
            text_Ph5T1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T1, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T1.setAutoDraw(False)
    
    # *phases_Ph5T1T1* updates
    if phases_Ph5T1T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T1.frameNStart = frameN  # exact frame index
        phases_Ph5T1T1.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T1, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T1.setAutoDraw(True)
    if phases_Ph5T1T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T1.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T1.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T1, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T1.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T1"-------
for thisComponent in Phase5T1T1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thth9.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth9.started', sound_thth9.tStartRefresh)
thisExp.addData('sound_thth9.stopped', sound_thth9.tStopRefresh)
sound_th6.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th6.started', sound_th6.tStartRefresh)
thisExp.addData('sound_th6.stopped', sound_th6.tStopRefresh)
# check responses
if key_Ph5T1T1.keys in ['', [], None]:  # No response was made
    key_Ph5T1T1.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T1T1.corr = 1;  # correct non-response
    else:
       key_Ph5T1T1.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T1.keys',key_Ph5T1T1.keys)
thisExp.addData('key_Ph5T1T1.corr', key_Ph5T1T1.corr)
if key_Ph5T1T1.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T1.rt', key_Ph5T1T1.rt)
thisExp.addData('key_Ph5T1T1.started', key_Ph5T1T1.tStartRefresh)
thisExp.addData('key_Ph5T1T1.stopped', key_Ph5T1T1.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T1.started', text_Ph5T1T1.tStartRefresh)
thisExp.addData('text_Ph5T1T1.stopped', text_Ph5T1T1.tStopRefresh)
thisExp.addData('phases_Ph5T1T1.started', phases_Ph5T1T1.tStartRefresh)
thisExp.addData('phases_Ph5T1T1.stopped', phases_Ph5T1T1.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T2"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_thth10.setSound('Sounds/thth.wav', hamming=True)
sound_thth10.setVolume(1, log=False)
sound_thth11.setSound('Sounds/thth.wav', hamming=True)
sound_thth11.setVolume(1, log=False)
key_Ph5T1T2.keys = []
key_Ph5T1T2.rt = []
_key_Ph5T1T2_allKeys = []
# keep track of which components have finished
Phase5T1T2Components = [sound_thth10, sound_thth11, key_Ph5T1T2, text_Ph5T1T2, phases_Ph5T1T2]
for thisComponent in Phase5T1T2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T2"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thth10
    if sound_thth10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thth10.frameNStart = frameN  # exact frame index
        sound_thth10.tStart = t  # local t and not account for scr refresh
        sound_thth10.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth10.play(when=win)  # sync with win flip
    if sound_thth10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth10.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth10.tStop = t  # not accounting for scr refresh
            sound_thth10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth10, 'tStopRefresh')  # time at next scr refresh
            sound_thth10.stop()
    # start/stop sound_thth11
    if sound_thth11.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_thth11.frameNStart = frameN  # exact frame index
        sound_thth11.tStart = t  # local t and not account for scr refresh
        sound_thth11.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth11.play(when=win)  # sync with win flip
    if sound_thth11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth11.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth11.tStop = t  # not accounting for scr refresh
            sound_thth11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth11, 'tStopRefresh')  # time at next scr refresh
            sound_thth11.stop()
    
    # *key_Ph5T1T2* updates
    waitOnFlip = False
    if key_Ph5T1T2.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T2.frameNStart = frameN  # exact frame index
        key_Ph5T1T2.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T2, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T2.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T2.tStop = t  # not accounting for scr refresh
            key_Ph5T1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T2, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T2.status = FINISHED
    if key_Ph5T1T2.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T2.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T2_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T2_allKeys):
            key_Ph5T1T2.keys = _key_Ph5T1T2_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T2.rt = _key_Ph5T1T2_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T2.keys == str('1')) or (key_Ph5T1T2.keys == '1'):
                key_Ph5T1T2.corr = 1
            else:
                key_Ph5T1T2.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T2* updates
    if text_Ph5T1T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T2.frameNStart = frameN  # exact frame index
        text_Ph5T1T2.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T2, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T2.setAutoDraw(True)
    if text_Ph5T1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T2.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T2.tStop = t  # not accounting for scr refresh
            text_Ph5T1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T2, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T2.setAutoDraw(False)
    
    # *phases_Ph5T1T2* updates
    if phases_Ph5T1T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T2.frameNStart = frameN  # exact frame index
        phases_Ph5T1T2.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T2, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T2.setAutoDraw(True)
    if phases_Ph5T1T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T2.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T2.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T2, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T2.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T2"-------
for thisComponent in Phase5T1T2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thth10.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth10.started', sound_thth10.tStartRefresh)
thisExp.addData('sound_thth10.stopped', sound_thth10.tStopRefresh)
sound_thth11.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth11.started', sound_thth11.tStartRefresh)
thisExp.addData('sound_thth11.stopped', sound_thth11.tStopRefresh)
# check responses
if key_Ph5T1T2.keys in ['', [], None]:  # No response was made
    key_Ph5T1T2.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T1T2.corr = 1;  # correct non-response
    else:
       key_Ph5T1T2.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T2.keys',key_Ph5T1T2.keys)
thisExp.addData('key_Ph5T1T2.corr', key_Ph5T1T2.corr)
if key_Ph5T1T2.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T2.rt', key_Ph5T1T2.rt)
thisExp.addData('key_Ph5T1T2.started', key_Ph5T1T2.tStartRefresh)
thisExp.addData('key_Ph5T1T2.stopped', key_Ph5T1T2.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T2.started', text_Ph5T1T2.tStartRefresh)
thisExp.addData('text_Ph5T1T2.stopped', text_Ph5T1T2.tStopRefresh)
thisExp.addData('phases_Ph5T1T2.started', phases_Ph5T1T2.tStartRefresh)
thisExp.addData('phases_Ph5T1T2.stopped', phases_Ph5T1T2.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T3"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_thth12.setSound('Sounds/thth.wav', hamming=True)
sound_thth12.setVolume(1, log=False)
sound_sh9.setSound('Sounds/sh.wav', hamming=True)
sound_sh9.setVolume(1, log=False)
key_Ph5T1T3.keys = []
key_Ph5T1T3.rt = []
_key_Ph5T1T3_allKeys = []
# keep track of which components have finished
Phase5T1T3Components = [sound_thth12, sound_sh9, key_Ph5T1T3, text_Ph5T1T3, phases_Ph5T1T3]
for thisComponent in Phase5T1T3Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T3"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T3Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T3Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thth12
    if sound_thth12.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thth12.frameNStart = frameN  # exact frame index
        sound_thth12.tStart = t  # local t and not account for scr refresh
        sound_thth12.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth12.play(when=win)  # sync with win flip
    if sound_thth12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth12.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth12.tStop = t  # not accounting for scr refresh
            sound_thth12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth12, 'tStopRefresh')  # time at next scr refresh
            sound_thth12.stop()
    # start/stop sound_sh9
    if sound_sh9.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_sh9.frameNStart = frameN  # exact frame index
        sound_sh9.tStart = t  # local t and not account for scr refresh
        sound_sh9.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh9.play(when=win)  # sync with win flip
    if sound_sh9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh9.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh9.tStop = t  # not accounting for scr refresh
            sound_sh9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh9, 'tStopRefresh')  # time at next scr refresh
            sound_sh9.stop()
    
    # *key_Ph5T1T3* updates
    waitOnFlip = False
    if key_Ph5T1T3.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T3.frameNStart = frameN  # exact frame index
        key_Ph5T1T3.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T3, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T3.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T3.tStop = t  # not accounting for scr refresh
            key_Ph5T1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T3, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T3.status = FINISHED
    if key_Ph5T1T3.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T3.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T3_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T3_allKeys):
            key_Ph5T1T3.keys = _key_Ph5T1T3_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T3.rt = _key_Ph5T1T3_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T3.keys == str('0')) or (key_Ph5T1T3.keys == '0'):
                key_Ph5T1T3.corr = 1
            else:
                key_Ph5T1T3.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T3* updates
    if text_Ph5T1T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T3.frameNStart = frameN  # exact frame index
        text_Ph5T1T3.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T3, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T3.setAutoDraw(True)
    if text_Ph5T1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T3.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T3.tStop = t  # not accounting for scr refresh
            text_Ph5T1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T3, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T3.setAutoDraw(False)
    
    # *phases_Ph5T1T3* updates
    if phases_Ph5T1T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T3.frameNStart = frameN  # exact frame index
        phases_Ph5T1T3.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T3, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T3.setAutoDraw(True)
    if phases_Ph5T1T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T3.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T3.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T3, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T3.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T3Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T3"-------
for thisComponent in Phase5T1T3Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thth12.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth12.started', sound_thth12.tStartRefresh)
thisExp.addData('sound_thth12.stopped', sound_thth12.tStopRefresh)
sound_sh9.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh9.started', sound_sh9.tStartRefresh)
thisExp.addData('sound_sh9.stopped', sound_sh9.tStopRefresh)
# check responses
if key_Ph5T1T3.keys in ['', [], None]:  # No response was made
    key_Ph5T1T3.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T1T3.corr = 1;  # correct non-response
    else:
       key_Ph5T1T3.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T3.keys',key_Ph5T1T3.keys)
thisExp.addData('key_Ph5T1T3.corr', key_Ph5T1T3.corr)
if key_Ph5T1T3.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T3.rt', key_Ph5T1T3.rt)
thisExp.addData('key_Ph5T1T3.started', key_Ph5T1T3.tStartRefresh)
thisExp.addData('key_Ph5T1T3.stopped', key_Ph5T1T3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T3.started', text_Ph5T1T3.tStartRefresh)
thisExp.addData('text_Ph5T1T3.stopped', text_Ph5T1T3.tStopRefresh)
thisExp.addData('phases_Ph5T1T3.started', phases_Ph5T1T3.tStartRefresh)
thisExp.addData('phases_Ph5T1T3.stopped', phases_Ph5T1T3.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T4"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_thth13.setSound('Sounds/thth.wav', hamming=True)
sound_thth13.setVolume(1, log=False)
sound_thth14.setSound('Sounds/thth.wav', hamming=True)
sound_thth14.setVolume(1, log=False)
key_Ph5T1T4.keys = []
key_Ph5T1T4.rt = []
_key_Ph5T1T4_allKeys = []
# keep track of which components have finished
Phase5T1T4Components = [sound_thth13, sound_thth14, key_Ph5T1T4, text_Ph5T1T4, phases_Ph5T1T4]
for thisComponent in Phase5T1T4Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T4"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T4Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T4Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thth13
    if sound_thth13.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thth13.frameNStart = frameN  # exact frame index
        sound_thth13.tStart = t  # local t and not account for scr refresh
        sound_thth13.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth13.play(when=win)  # sync with win flip
    if sound_thth13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth13.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth13.tStop = t  # not accounting for scr refresh
            sound_thth13.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth13, 'tStopRefresh')  # time at next scr refresh
            sound_thth13.stop()
    # start/stop sound_thth14
    if sound_thth14.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_thth14.frameNStart = frameN  # exact frame index
        sound_thth14.tStart = t  # local t and not account for scr refresh
        sound_thth14.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth14.play(when=win)  # sync with win flip
    if sound_thth14.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth14.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth14.tStop = t  # not accounting for scr refresh
            sound_thth14.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth14, 'tStopRefresh')  # time at next scr refresh
            sound_thth14.stop()
    
    # *key_Ph5T1T4* updates
    waitOnFlip = False
    if key_Ph5T1T4.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T4.frameNStart = frameN  # exact frame index
        key_Ph5T1T4.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T4, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T4.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T4.tStop = t  # not accounting for scr refresh
            key_Ph5T1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T4, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T4.status = FINISHED
    if key_Ph5T1T4.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T4.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T4_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T4_allKeys):
            key_Ph5T1T4.keys = _key_Ph5T1T4_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T4.rt = _key_Ph5T1T4_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T4.keys == str('1')) or (key_Ph5T1T4.keys == '1'):
                key_Ph5T1T4.corr = 1
            else:
                key_Ph5T1T4.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T4* updates
    if text_Ph5T1T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T4.frameNStart = frameN  # exact frame index
        text_Ph5T1T4.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T4, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T4.setAutoDraw(True)
    if text_Ph5T1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T4.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T4.tStop = t  # not accounting for scr refresh
            text_Ph5T1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T4, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T4.setAutoDraw(False)
    
    # *phases_Ph5T1T4* updates
    if phases_Ph5T1T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T4.frameNStart = frameN  # exact frame index
        phases_Ph5T1T4.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T4, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T4.setAutoDraw(True)
    if phases_Ph5T1T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T4.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T4.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T4, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T4.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T4Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T4"-------
for thisComponent in Phase5T1T4Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thth13.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth13.started', sound_thth13.tStartRefresh)
thisExp.addData('sound_thth13.stopped', sound_thth13.tStopRefresh)
sound_thth14.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth14.started', sound_thth14.tStartRefresh)
thisExp.addData('sound_thth14.stopped', sound_thth14.tStopRefresh)
# check responses
if key_Ph5T1T4.keys in ['', [], None]:  # No response was made
    key_Ph5T1T4.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T1T4.corr = 1;  # correct non-response
    else:
       key_Ph5T1T4.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T4.keys',key_Ph5T1T4.keys)
thisExp.addData('key_Ph5T1T4.corr', key_Ph5T1T4.corr)
if key_Ph5T1T4.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T4.rt', key_Ph5T1T4.rt)
thisExp.addData('key_Ph5T1T4.started', key_Ph5T1T4.tStartRefresh)
thisExp.addData('key_Ph5T1T4.stopped', key_Ph5T1T4.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T4.started', text_Ph5T1T4.tStartRefresh)
thisExp.addData('text_Ph5T1T4.stopped', text_Ph5T1T4.tStopRefresh)
thisExp.addData('phases_Ph5T1T4.started', phases_Ph5T1T4.tStartRefresh)
thisExp.addData('phases_Ph5T1T4.stopped', phases_Ph5T1T4.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T5"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_th10.setSound('Sounds/th.wav', hamming=True)
sound_th10.setVolume(1, log=False)
sound_thth15.setSound('Sounds/thth.wav', hamming=True)
sound_thth15.setVolume(1, log=False)
key_Ph5T1T5.keys = []
key_Ph5T1T5.rt = []
_key_Ph5T1T5_allKeys = []
# keep track of which components have finished
Phase5T1T5Components = [sound_th10, sound_thth15, key_Ph5T1T5, text_Ph5T1T5, phases_Ph5T1T5]
for thisComponent in Phase5T1T5Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T5"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T5Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T5Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_th10
    if sound_th10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_th10.frameNStart = frameN  # exact frame index
        sound_th10.tStart = t  # local t and not account for scr refresh
        sound_th10.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th10.play(when=win)  # sync with win flip
    if sound_th10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th10.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th10.tStop = t  # not accounting for scr refresh
            sound_th10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th10, 'tStopRefresh')  # time at next scr refresh
            sound_th10.stop()
    # start/stop sound_thth15
    if sound_thth15.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_thth15.frameNStart = frameN  # exact frame index
        sound_thth15.tStart = t  # local t and not account for scr refresh
        sound_thth15.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth15.play(when=win)  # sync with win flip
    if sound_thth15.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth15.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth15.tStop = t  # not accounting for scr refresh
            sound_thth15.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth15, 'tStopRefresh')  # time at next scr refresh
            sound_thth15.stop()
    
    # *key_Ph5T1T5* updates
    waitOnFlip = False
    if key_Ph5T1T5.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T5.frameNStart = frameN  # exact frame index
        key_Ph5T1T5.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T5, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T5.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T5.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T5.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T5.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T5.tStop = t  # not accounting for scr refresh
            key_Ph5T1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T5, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T5.status = FINISHED
    if key_Ph5T1T5.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T5.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T5_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T5_allKeys):
            key_Ph5T1T5.keys = _key_Ph5T1T5_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T5.rt = _key_Ph5T1T5_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T5.keys == str('0')) or (key_Ph5T1T5.keys == '0'):
                key_Ph5T1T5.corr = 1
            else:
                key_Ph5T1T5.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T5* updates
    if text_Ph5T1T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T5.frameNStart = frameN  # exact frame index
        text_Ph5T1T5.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T5, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T5.setAutoDraw(True)
    if text_Ph5T1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T5.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T5.tStop = t  # not accounting for scr refresh
            text_Ph5T1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T5, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T5.setAutoDraw(False)
    
    # *phases_Ph5T1T5* updates
    if phases_Ph5T1T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T5.frameNStart = frameN  # exact frame index
        phases_Ph5T1T5.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T5, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T5.setAutoDraw(True)
    if phases_Ph5T1T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T5.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T5.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T5, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T5.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T5Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T5"-------
for thisComponent in Phase5T1T5Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_th10.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th10.started', sound_th10.tStartRefresh)
thisExp.addData('sound_th10.stopped', sound_th10.tStopRefresh)
sound_thth15.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth15.started', sound_thth15.tStartRefresh)
thisExp.addData('sound_thth15.stopped', sound_thth15.tStopRefresh)
# check responses
if key_Ph5T1T5.keys in ['', [], None]:  # No response was made
    key_Ph5T1T5.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T1T5.corr = 1;  # correct non-response
    else:
       key_Ph5T1T5.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T5.keys',key_Ph5T1T5.keys)
thisExp.addData('key_Ph5T1T5.corr', key_Ph5T1T5.corr)
if key_Ph5T1T5.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T5.rt', key_Ph5T1T5.rt)
thisExp.addData('key_Ph5T1T5.started', key_Ph5T1T5.tStartRefresh)
thisExp.addData('key_Ph5T1T5.stopped', key_Ph5T1T5.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T5.started', text_Ph5T1T5.tStartRefresh)
thisExp.addData('text_Ph5T1T5.stopped', text_Ph5T1T5.tStopRefresh)
thisExp.addData('phases_Ph5T1T5.started', phases_Ph5T1T5.tStartRefresh)
thisExp.addData('phases_Ph5T1T5.stopped', phases_Ph5T1T5.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T6"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_th11.setSound('Sounds/th.wav', hamming=True)
sound_th11.setVolume(1, log=False)
sound_th12.setSound('Sounds/th.wav', hamming=True)
sound_th12.setVolume(1, log=False)
key_Ph5T1T6.keys = []
key_Ph5T1T6.rt = []
_key_Ph5T1T6_allKeys = []
# keep track of which components have finished
Phase5T1T6Components = [sound_th11, sound_th12, key_Ph5T1T6, text_Ph5T1T6, phases_Ph5T1T6]
for thisComponent in Phase5T1T6Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T6"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T6Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T6Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_th11
    if sound_th11.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_th11.frameNStart = frameN  # exact frame index
        sound_th11.tStart = t  # local t and not account for scr refresh
        sound_th11.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th11.play(when=win)  # sync with win flip
    if sound_th11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th11.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th11.tStop = t  # not accounting for scr refresh
            sound_th11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th11, 'tStopRefresh')  # time at next scr refresh
            sound_th11.stop()
    # start/stop sound_th12
    if sound_th12.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_th12.frameNStart = frameN  # exact frame index
        sound_th12.tStart = t  # local t and not account for scr refresh
        sound_th12.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th12.play(when=win)  # sync with win flip
    if sound_th12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th12.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th12.tStop = t  # not accounting for scr refresh
            sound_th12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th12, 'tStopRefresh')  # time at next scr refresh
            sound_th12.stop()
    
    # *key_Ph5T1T6* updates
    waitOnFlip = False
    if key_Ph5T1T6.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T6.frameNStart = frameN  # exact frame index
        key_Ph5T1T6.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T6, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T6.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T6.tStop = t  # not accounting for scr refresh
            key_Ph5T1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T6, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T6.status = FINISHED
    if key_Ph5T1T6.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T6.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T6_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T6_allKeys):
            key_Ph5T1T6.keys = _key_Ph5T1T6_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T6.rt = _key_Ph5T1T6_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T6.keys == str('1')) or (key_Ph5T1T6.keys == '1'):
                key_Ph5T1T6.corr = 1
            else:
                key_Ph5T1T6.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T6* updates
    if text_Ph5T1T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T6.frameNStart = frameN  # exact frame index
        text_Ph5T1T6.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T6, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T6.setAutoDraw(True)
    if text_Ph5T1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T6.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T6.tStop = t  # not accounting for scr refresh
            text_Ph5T1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T6, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T6.setAutoDraw(False)
    
    # *phases_Ph5T1T6* updates
    if phases_Ph5T1T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T6.frameNStart = frameN  # exact frame index
        phases_Ph5T1T6.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T6, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T6.setAutoDraw(True)
    if phases_Ph5T1T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T6.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T6.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T6, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T6.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T6Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T6"-------
for thisComponent in Phase5T1T6Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_th11.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th11.started', sound_th11.tStartRefresh)
thisExp.addData('sound_th11.stopped', sound_th11.tStopRefresh)
sound_th12.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th12.started', sound_th12.tStartRefresh)
thisExp.addData('sound_th12.stopped', sound_th12.tStopRefresh)
# check responses
if key_Ph5T1T6.keys in ['', [], None]:  # No response was made
    key_Ph5T1T6.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T1T6.corr = 1;  # correct non-response
    else:
       key_Ph5T1T6.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T6.keys',key_Ph5T1T6.keys)
thisExp.addData('key_Ph5T1T6.corr', key_Ph5T1T6.corr)
if key_Ph5T1T6.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T6.rt', key_Ph5T1T6.rt)
thisExp.addData('key_Ph5T1T6.started', key_Ph5T1T6.tStartRefresh)
thisExp.addData('key_Ph5T1T6.stopped', key_Ph5T1T6.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T6.started', text_Ph5T1T6.tStartRefresh)
thisExp.addData('text_Ph5T1T6.stopped', text_Ph5T1T6.tStopRefresh)
thisExp.addData('phases_Ph5T1T6.started', phases_Ph5T1T6.tStartRefresh)
thisExp.addData('phases_Ph5T1T6.stopped', phases_Ph5T1T6.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T7"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_th13.setSound('Sounds/th.wav', hamming=True)
sound_th13.setVolume(1, log=False)
sound_sh10.setSound('Sounds/sh.wav', hamming=True)
sound_sh10.setVolume(1, log=False)
key_Ph5T1T7.keys = []
key_Ph5T1T7.rt = []
_key_Ph5T1T7_allKeys = []
# keep track of which components have finished
Phase5T1T7Components = [sound_th13, sound_sh10, key_Ph5T1T7, text_Ph5T1T7, phases_Ph5T1T7]
for thisComponent in Phase5T1T7Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T7"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T7Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T7Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_th13
    if sound_th13.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_th13.frameNStart = frameN  # exact frame index
        sound_th13.tStart = t  # local t and not account for scr refresh
        sound_th13.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th13.play(when=win)  # sync with win flip
    if sound_th13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th13.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th13.tStop = t  # not accounting for scr refresh
            sound_th13.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th13, 'tStopRefresh')  # time at next scr refresh
            sound_th13.stop()
    # start/stop sound_sh10
    if sound_sh10.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_sh10.frameNStart = frameN  # exact frame index
        sound_sh10.tStart = t  # local t and not account for scr refresh
        sound_sh10.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh10.play(when=win)  # sync with win flip
    if sound_sh10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh10.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh10.tStop = t  # not accounting for scr refresh
            sound_sh10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh10, 'tStopRefresh')  # time at next scr refresh
            sound_sh10.stop()
    
    # *key_Ph5T1T7* updates
    waitOnFlip = False
    if key_Ph5T1T7.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T7.frameNStart = frameN  # exact frame index
        key_Ph5T1T7.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T7, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T7.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T7.tStop = t  # not accounting for scr refresh
            key_Ph5T1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T7, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T7.status = FINISHED
    if key_Ph5T1T7.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T7.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T7_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T7_allKeys):
            key_Ph5T1T7.keys = _key_Ph5T1T7_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T7.rt = _key_Ph5T1T7_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T7.keys == str('0')) or (key_Ph5T1T7.keys == '0'):
                key_Ph5T1T7.corr = 1
            else:
                key_Ph5T1T7.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T7* updates
    if text_Ph5T1T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T7.frameNStart = frameN  # exact frame index
        text_Ph5T1T7.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T7, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T7.setAutoDraw(True)
    if text_Ph5T1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T7.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T7.tStop = t  # not accounting for scr refresh
            text_Ph5T1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T7, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T7.setAutoDraw(False)
    
    # *phases_Ph5T1T7* updates
    if phases_Ph5T1T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T7.frameNStart = frameN  # exact frame index
        phases_Ph5T1T7.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T7, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T7.setAutoDraw(True)
    if phases_Ph5T1T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T7.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T7.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T7, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T7.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T7Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T7"-------
for thisComponent in Phase5T1T7Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_th13.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th13.started', sound_th13.tStartRefresh)
thisExp.addData('sound_th13.stopped', sound_th13.tStopRefresh)
sound_sh10.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh10.started', sound_sh10.tStartRefresh)
thisExp.addData('sound_sh10.stopped', sound_sh10.tStopRefresh)
# check responses
if key_Ph5T1T7.keys in ['', [], None]:  # No response was made
    key_Ph5T1T7.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T1T7.corr = 1;  # correct non-response
    else:
       key_Ph5T1T7.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T7.keys',key_Ph5T1T7.keys)
thisExp.addData('key_Ph5T1T7.corr', key_Ph5T1T7.corr)
if key_Ph5T1T7.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T7.rt', key_Ph5T1T7.rt)
thisExp.addData('key_Ph5T1T7.started', key_Ph5T1T7.tStartRefresh)
thisExp.addData('key_Ph5T1T7.stopped', key_Ph5T1T7.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T7.started', text_Ph5T1T7.tStartRefresh)
thisExp.addData('text_Ph5T1T7.stopped', text_Ph5T1T7.tStopRefresh)
thisExp.addData('phases_Ph5T1T7.started', phases_Ph5T1T7.tStartRefresh)
thisExp.addData('phases_Ph5T1T7.stopped', phases_Ph5T1T7.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T8"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_th14.setSound('Sounds/th.wav', hamming=True)
sound_th14.setVolume(1, log=False)
sound_th15.setSound('Sounds/th.wav', hamming=True)
sound_th15.setVolume(1, log=False)
key_Ph5T1T8.keys = []
key_Ph5T1T8.rt = []
_key_Ph5T1T8_allKeys = []
# keep track of which components have finished
Phase5T1T8Components = [sound_th14, sound_th15, key_Ph5T1T8, text_Ph5T1T8, phases_Ph5T1T8]
for thisComponent in Phase5T1T8Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T8"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T8Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T8Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_th14
    if sound_th14.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_th14.frameNStart = frameN  # exact frame index
        sound_th14.tStart = t  # local t and not account for scr refresh
        sound_th14.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th14.play(when=win)  # sync with win flip
    if sound_th14.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th14.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th14.tStop = t  # not accounting for scr refresh
            sound_th14.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th14, 'tStopRefresh')  # time at next scr refresh
            sound_th14.stop()
    # start/stop sound_th15
    if sound_th15.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_th15.frameNStart = frameN  # exact frame index
        sound_th15.tStart = t  # local t and not account for scr refresh
        sound_th15.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th15.play(when=win)  # sync with win flip
    if sound_th15.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th15.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th15.tStop = t  # not accounting for scr refresh
            sound_th15.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th15, 'tStopRefresh')  # time at next scr refresh
            sound_th15.stop()
    
    # *key_Ph5T1T8* updates
    waitOnFlip = False
    if key_Ph5T1T8.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T8.frameNStart = frameN  # exact frame index
        key_Ph5T1T8.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T8, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T8.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T8.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T8.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T8.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T8.tStop = t  # not accounting for scr refresh
            key_Ph5T1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T8, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T8.status = FINISHED
    if key_Ph5T1T8.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T8.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T8_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T8_allKeys):
            key_Ph5T1T8.keys = _key_Ph5T1T8_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T8.rt = _key_Ph5T1T8_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T8.keys == str('0')) or (key_Ph5T1T8.keys == '0'):
                key_Ph5T1T8.corr = 1
            else:
                key_Ph5T1T8.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T8* updates
    if text_Ph5T1T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T8.frameNStart = frameN  # exact frame index
        text_Ph5T1T8.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T8, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T8.setAutoDraw(True)
    if text_Ph5T1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T8.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T8.tStop = t  # not accounting for scr refresh
            text_Ph5T1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T8, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T8.setAutoDraw(False)
    
    # *phases_Ph5T1T8* updates
    if phases_Ph5T1T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T8.frameNStart = frameN  # exact frame index
        phases_Ph5T1T8.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T8, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T8.setAutoDraw(True)
    if phases_Ph5T1T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T8.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T8.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T8, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T8.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T8Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T8"-------
for thisComponent in Phase5T1T8Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_th14.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th14.started', sound_th14.tStartRefresh)
thisExp.addData('sound_th14.stopped', sound_th14.tStopRefresh)
sound_th15.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th15.started', sound_th15.tStartRefresh)
thisExp.addData('sound_th15.stopped', sound_th15.tStopRefresh)
# check responses
if key_Ph5T1T8.keys in ['', [], None]:  # No response was made
    key_Ph5T1T8.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T1T8.corr = 1;  # correct non-response
    else:
       key_Ph5T1T8.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T8.keys',key_Ph5T1T8.keys)
thisExp.addData('key_Ph5T1T8.corr', key_Ph5T1T8.corr)
if key_Ph5T1T8.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T8.rt', key_Ph5T1T8.rt)
thisExp.addData('key_Ph5T1T8.started', key_Ph5T1T8.tStartRefresh)
thisExp.addData('key_Ph5T1T8.stopped', key_Ph5T1T8.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T8.started', text_Ph5T1T8.tStartRefresh)
thisExp.addData('text_Ph5T1T8.stopped', text_Ph5T1T8.tStopRefresh)
thisExp.addData('phases_Ph5T1T8.started', phases_Ph5T1T8.tStartRefresh)
thisExp.addData('phases_Ph5T1T8.stopped', phases_Ph5T1T8.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T9"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_sh11.setSound('Sounds/sh.wav', hamming=True)
sound_sh11.setVolume(1, log=False)
sound_thth16.setSound('Sounds/thth.wav', hamming=True)
sound_thth16.setVolume(1, log=False)
key_Ph5T1T9.keys = []
key_Ph5T1T9.rt = []
_key_Ph5T1T9_allKeys = []
# keep track of which components have finished
Phase5T1T9Components = [sound_sh11, sound_thth16, key_Ph5T1T9, text_Ph5T1T9, phases_Ph5T1T9]
for thisComponent in Phase5T1T9Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T9"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T9Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T9Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_sh11
    if sound_sh11.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_sh11.frameNStart = frameN  # exact frame index
        sound_sh11.tStart = t  # local t and not account for scr refresh
        sound_sh11.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh11.play(when=win)  # sync with win flip
    if sound_sh11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh11.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh11.tStop = t  # not accounting for scr refresh
            sound_sh11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh11, 'tStopRefresh')  # time at next scr refresh
            sound_sh11.stop()
    # start/stop sound_thth16
    if sound_thth16.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_thth16.frameNStart = frameN  # exact frame index
        sound_thth16.tStart = t  # local t and not account for scr refresh
        sound_thth16.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thth16.play(when=win)  # sync with win flip
    if sound_thth16.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thth16.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thth16.tStop = t  # not accounting for scr refresh
            sound_thth16.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thth16, 'tStopRefresh')  # time at next scr refresh
            sound_thth16.stop()
    
    # *key_Ph5T1T9* updates
    waitOnFlip = False
    if key_Ph5T1T9.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T9.frameNStart = frameN  # exact frame index
        key_Ph5T1T9.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T9, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T9.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T9.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T9.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T9.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T9.tStop = t  # not accounting for scr refresh
            key_Ph5T1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T9, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T9.status = FINISHED
    if key_Ph5T1T9.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T9.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T9_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T9_allKeys):
            key_Ph5T1T9.keys = _key_Ph5T1T9_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T9.rt = _key_Ph5T1T9_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T9.keys == str('0')) or (key_Ph5T1T9.keys == '0'):
                key_Ph5T1T9.corr = 1
            else:
                key_Ph5T1T9.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T9* updates
    if text_Ph5T1T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T9.frameNStart = frameN  # exact frame index
        text_Ph5T1T9.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T9, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T9.setAutoDraw(True)
    if text_Ph5T1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T9.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T9.tStop = t  # not accounting for scr refresh
            text_Ph5T1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T9, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T9.setAutoDraw(False)
    
    # *phases_Ph5T1T9* updates
    if phases_Ph5T1T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T9.frameNStart = frameN  # exact frame index
        phases_Ph5T1T9.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T9, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T9.setAutoDraw(True)
    if phases_Ph5T1T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T9.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T9.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T9, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T9.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T9Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T9"-------
for thisComponent in Phase5T1T9Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_sh11.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh11.started', sound_sh11.tStartRefresh)
thisExp.addData('sound_sh11.stopped', sound_sh11.tStopRefresh)
sound_thth16.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thth16.started', sound_thth16.tStartRefresh)
thisExp.addData('sound_thth16.stopped', sound_thth16.tStopRefresh)
# check responses
if key_Ph5T1T9.keys in ['', [], None]:  # No response was made
    key_Ph5T1T9.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T1T9.corr = 1;  # correct non-response
    else:
       key_Ph5T1T9.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T9.keys',key_Ph5T1T9.keys)
thisExp.addData('key_Ph5T1T9.corr', key_Ph5T1T9.corr)
if key_Ph5T1T9.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T9.rt', key_Ph5T1T9.rt)
thisExp.addData('key_Ph5T1T9.started', key_Ph5T1T9.tStartRefresh)
thisExp.addData('key_Ph5T1T9.stopped', key_Ph5T1T9.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T9.started', text_Ph5T1T9.tStartRefresh)
thisExp.addData('text_Ph5T1T9.stopped', text_Ph5T1T9.tStopRefresh)
thisExp.addData('phases_Ph5T1T9.started', phases_Ph5T1T9.tStartRefresh)
thisExp.addData('phases_Ph5T1T9.stopped', phases_Ph5T1T9.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T10"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_sh12.setSound('Sounds/sh.wav', hamming=True)
sound_sh12.setVolume(1, log=False)
sound_th16.setSound('Sounds/th.wav', hamming=True)
sound_th16.setVolume(1, log=False)
key_Ph5T1T10.keys = []
key_Ph5T1T10.rt = []
_key_Ph5T1T10_allKeys = []
# keep track of which components have finished
Phase5T1T10Components = [sound_sh12, sound_th16, key_Ph5T1T10, text_Ph5T1T10, phases_Ph5T1T10]
for thisComponent in Phase5T1T10Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T10"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T10Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T10Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_sh12
    if sound_sh12.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_sh12.frameNStart = frameN  # exact frame index
        sound_sh12.tStart = t  # local t and not account for scr refresh
        sound_sh12.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh12.play(when=win)  # sync with win flip
    if sound_sh12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh12.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh12.tStop = t  # not accounting for scr refresh
            sound_sh12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh12, 'tStopRefresh')  # time at next scr refresh
            sound_sh12.stop()
    # start/stop sound_th16
    if sound_th16.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_th16.frameNStart = frameN  # exact frame index
        sound_th16.tStart = t  # local t and not account for scr refresh
        sound_th16.tStartRefresh = tThisFlipGlobal  # on global time
        sound_th16.play(when=win)  # sync with win flip
    if sound_th16.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_th16.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_th16.tStop = t  # not accounting for scr refresh
            sound_th16.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_th16, 'tStopRefresh')  # time at next scr refresh
            sound_th16.stop()
    
    # *key_Ph5T1T10* updates
    waitOnFlip = False
    if key_Ph5T1T10.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T10.frameNStart = frameN  # exact frame index
        key_Ph5T1T10.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T10, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T10.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T10.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T10.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T10.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T10.tStop = t  # not accounting for scr refresh
            key_Ph5T1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T10, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T10.status = FINISHED
    if key_Ph5T1T10.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T10.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T10_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T10_allKeys):
            key_Ph5T1T10.keys = _key_Ph5T1T10_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T10.rt = _key_Ph5T1T10_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T10.keys == str('0')) or (key_Ph5T1T10.keys == '0'):
                key_Ph5T1T10.corr = 1
            else:
                key_Ph5T1T10.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T10* updates
    if text_Ph5T1T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T10.frameNStart = frameN  # exact frame index
        text_Ph5T1T10.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T10, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T10.setAutoDraw(True)
    if text_Ph5T1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T10.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T10.tStop = t  # not accounting for scr refresh
            text_Ph5T1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T10, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T10.setAutoDraw(False)
    
    # *phases_Ph5T1T10* updates
    if phases_Ph5T1T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T10.frameNStart = frameN  # exact frame index
        phases_Ph5T1T10.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T10, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T10.setAutoDraw(True)
    if phases_Ph5T1T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T10.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T10.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T10, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T10.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T10Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T10"-------
for thisComponent in Phase5T1T10Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_sh12.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh12.started', sound_sh12.tStartRefresh)
thisExp.addData('sound_sh12.stopped', sound_sh12.tStopRefresh)
sound_th16.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_th16.started', sound_th16.tStartRefresh)
thisExp.addData('sound_th16.stopped', sound_th16.tStopRefresh)
# check responses
if key_Ph5T1T10.keys in ['', [], None]:  # No response was made
    key_Ph5T1T10.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T1T10.corr = 1;  # correct non-response
    else:
       key_Ph5T1T10.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T10.keys',key_Ph5T1T10.keys)
thisExp.addData('key_Ph5T1T10.corr', key_Ph5T1T10.corr)
if key_Ph5T1T10.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T10.rt', key_Ph5T1T10.rt)
thisExp.addData('key_Ph5T1T10.started', key_Ph5T1T10.tStartRefresh)
thisExp.addData('key_Ph5T1T10.stopped', key_Ph5T1T10.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T10.started', text_Ph5T1T10.tStartRefresh)
thisExp.addData('text_Ph5T1T10.stopped', text_Ph5T1T10.tStopRefresh)
thisExp.addData('phases_Ph5T1T10.started', phases_Ph5T1T10.tStartRefresh)
thisExp.addData('phases_Ph5T1T10.stopped', phases_Ph5T1T10.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T11"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_sh13.setSound('Sounds/sh.wav', hamming=True)
sound_sh13.setVolume(1, log=False)
sound_sh14.setSound('Sounds/sh.wav', hamming=True)
sound_sh14.setVolume(1, log=False)
key_Ph5T1T11.keys = []
key_Ph5T1T11.rt = []
_key_Ph5T1T11_allKeys = []
# keep track of which components have finished
Phase5T1T11Components = [sound_sh13, sound_sh14, key_Ph5T1T11, text_Ph5T1T11, phases_Ph5T1T11]
for thisComponent in Phase5T1T11Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T11"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T11Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T11Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_sh13
    if sound_sh13.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_sh13.frameNStart = frameN  # exact frame index
        sound_sh13.tStart = t  # local t and not account for scr refresh
        sound_sh13.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh13.play(when=win)  # sync with win flip
    if sound_sh13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh13.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh13.tStop = t  # not accounting for scr refresh
            sound_sh13.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh13, 'tStopRefresh')  # time at next scr refresh
            sound_sh13.stop()
    # start/stop sound_sh14
    if sound_sh14.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_sh14.frameNStart = frameN  # exact frame index
        sound_sh14.tStart = t  # local t and not account for scr refresh
        sound_sh14.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh14.play(when=win)  # sync with win flip
    if sound_sh14.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh14.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh14.tStop = t  # not accounting for scr refresh
            sound_sh14.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh14, 'tStopRefresh')  # time at next scr refresh
            sound_sh14.stop()
    
    # *key_Ph5T1T11* updates
    waitOnFlip = False
    if key_Ph5T1T11.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T11.frameNStart = frameN  # exact frame index
        key_Ph5T1T11.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T11, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T11.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T11.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T11.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T11.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T11.tStop = t  # not accounting for scr refresh
            key_Ph5T1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T11, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T11.status = FINISHED
    if key_Ph5T1T11.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T11.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T11_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T11_allKeys):
            key_Ph5T1T11.keys = _key_Ph5T1T11_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T11.rt = _key_Ph5T1T11_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T11.keys == str('1')) or (key_Ph5T1T11.keys == '1'):
                key_Ph5T1T11.corr = 1
            else:
                key_Ph5T1T11.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T11* updates
    if text_Ph5T1T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T11.frameNStart = frameN  # exact frame index
        text_Ph5T1T11.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T11, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T11.setAutoDraw(True)
    if text_Ph5T1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T11.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T11.tStop = t  # not accounting for scr refresh
            text_Ph5T1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T11, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T11.setAutoDraw(False)
    
    # *phases_Ph5T1T11* updates
    if phases_Ph5T1T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T11.frameNStart = frameN  # exact frame index
        phases_Ph5T1T11.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T11, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T11.setAutoDraw(True)
    if phases_Ph5T1T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T11.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T11.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T11, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T11.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T11Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T11"-------
for thisComponent in Phase5T1T11Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_sh13.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh13.started', sound_sh13.tStartRefresh)
thisExp.addData('sound_sh13.stopped', sound_sh13.tStopRefresh)
sound_sh14.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh14.started', sound_sh14.tStartRefresh)
thisExp.addData('sound_sh14.stopped', sound_sh14.tStopRefresh)
# check responses
if key_Ph5T1T11.keys in ['', [], None]:  # No response was made
    key_Ph5T1T11.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T1T11.corr = 1;  # correct non-response
    else:
       key_Ph5T1T11.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T11.keys',key_Ph5T1T11.keys)
thisExp.addData('key_Ph5T1T11.corr', key_Ph5T1T11.corr)
if key_Ph5T1T11.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T11.rt', key_Ph5T1T11.rt)
thisExp.addData('key_Ph5T1T11.started', key_Ph5T1T11.tStartRefresh)
thisExp.addData('key_Ph5T1T11.stopped', key_Ph5T1T11.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T11.started', text_Ph5T1T11.tStartRefresh)
thisExp.addData('text_Ph5T1T11.stopped', text_Ph5T1T11.tStopRefresh)
thisExp.addData('phases_Ph5T1T11.started', phases_Ph5T1T11.tStartRefresh)
thisExp.addData('phases_Ph5T1T11.stopped', phases_Ph5T1T11.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T1T12"-------
continueRoutine = True
routineTimer.add(14.500000)
# update component parameters for each repeat
sound_sh15.setSound('Sounds/sh.wav', hamming=True)
sound_sh15.setVolume(1, log=False)
sound_sh16.setSound('Sounds/sh.wav', hamming=True)
sound_sh16.setVolume(1, log=False)
key_Ph5T1T12.keys = []
key_Ph5T1T12.rt = []
_key_Ph5T1T12_allKeys = []
# keep track of which components have finished
Phase5T1T12Components = [sound_sh15, sound_sh16, key_Ph5T1T12, text_Ph5T1T12, phases_Ph5T1T12]
for thisComponent in Phase5T1T12Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T1T12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T1T12"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T1T12Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T1T12Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_sh15
    if sound_sh15.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_sh15.frameNStart = frameN  # exact frame index
        sound_sh15.tStart = t  # local t and not account for scr refresh
        sound_sh15.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh15.play(when=win)  # sync with win flip
    if sound_sh15.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh15.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh15.tStop = t  # not accounting for scr refresh
            sound_sh15.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh15, 'tStopRefresh')  # time at next scr refresh
            sound_sh15.stop()
    # start/stop sound_sh16
    if sound_sh16.status == NOT_STARTED and tThisFlip >= 4.5-frameTolerance:
        # keep track of start time/frame for later
        sound_sh16.frameNStart = frameN  # exact frame index
        sound_sh16.tStart = t  # local t and not account for scr refresh
        sound_sh16.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh16.play(when=win)  # sync with win flip
    if sound_sh16.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh16.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh16.tStop = t  # not accounting for scr refresh
            sound_sh16.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh16, 'tStopRefresh')  # time at next scr refresh
            sound_sh16.stop()
    
    # *key_Ph5T1T12* updates
    waitOnFlip = False
    if key_Ph5T1T12.status == NOT_STARTED and tThisFlip >= 8-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T1T12.frameNStart = frameN  # exact frame index
        key_Ph5T1T12.tStart = t  # local t and not account for scr refresh
        key_Ph5T1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T1T12, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T1T12.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T1T12.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T1T12.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T1T12.tStartRefresh + 6.5-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T1T12.tStop = t  # not accounting for scr refresh
            key_Ph5T1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T1T12, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T1T12.status = FINISHED
    if key_Ph5T1T12.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T1T12.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T1T12_allKeys.extend(theseKeys)
        if len(_key_Ph5T1T12_allKeys):
            key_Ph5T1T12.keys = _key_Ph5T1T12_allKeys[-1].name  # just the last key pressed
            key_Ph5T1T12.rt = _key_Ph5T1T12_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T1T12.keys == str('1')) or (key_Ph5T1T12.keys == '1'):
                key_Ph5T1T12.corr = 1
            else:
                key_Ph5T1T12.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T1T12* updates
    if text_Ph5T1T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T1T12.frameNStart = frameN  # exact frame index
        text_Ph5T1T12.tStart = t  # local t and not account for scr refresh
        text_Ph5T1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T1T12, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T1T12.setAutoDraw(True)
    if text_Ph5T1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T1T12.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T1T12.tStop = t  # not accounting for scr refresh
            text_Ph5T1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T1T12, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T1T12.setAutoDraw(False)
    
    # *phases_Ph5T1T12* updates
    if phases_Ph5T1T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T1T12.frameNStart = frameN  # exact frame index
        phases_Ph5T1T12.tStart = t  # local t and not account for scr refresh
        phases_Ph5T1T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T1T12, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T1T12.setAutoDraw(True)
    if phases_Ph5T1T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T1T12.tStartRefresh + 14.5-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T1T12.tStop = t  # not accounting for scr refresh
            phases_Ph5T1T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T1T12, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T1T12.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T1T12Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T1T12"-------
for thisComponent in Phase5T1T12Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_sh15.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh15.started', sound_sh15.tStartRefresh)
thisExp.addData('sound_sh15.stopped', sound_sh15.tStopRefresh)
sound_sh16.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh16.started', sound_sh16.tStartRefresh)
thisExp.addData('sound_sh16.stopped', sound_sh16.tStopRefresh)
# check responses
if key_Ph5T1T12.keys in ['', [], None]:  # No response was made
    key_Ph5T1T12.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T1T12.corr = 1;  # correct non-response
    else:
       key_Ph5T1T12.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T1T12.keys',key_Ph5T1T12.keys)
thisExp.addData('key_Ph5T1T12.corr', key_Ph5T1T12.corr)
if key_Ph5T1T12.keys != None:  # we had a response
    thisExp.addData('key_Ph5T1T12.rt', key_Ph5T1T12.rt)
thisExp.addData('key_Ph5T1T12.started', key_Ph5T1T12.tStartRefresh)
thisExp.addData('key_Ph5T1T12.stopped', key_Ph5T1T12.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T1T12.started', text_Ph5T1T12.tStartRefresh)
thisExp.addData('text_Ph5T1T12.stopped', text_Ph5T1T12.tStopRefresh)
thisExp.addData('phases_Ph5T1T12.started', phases_Ph5T1T12.tStartRefresh)
thisExp.addData('phases_Ph5T1T12.stopped', phases_Ph5T1T12.tStopRefresh)

# ------Prepare to start Routine "Phase1instructions2"-------
continueRoutine = True
# update component parameters for each repeat
key_phase1_inst2.keys = []
key_phase1_inst2.rt = []
_key_phase1_inst2_allKeys = []
# keep track of which components have finished
Phase1instructions2Components = [text_phase1_inst2, key_phase1_inst2]
for thisComponent in Phase1instructions2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase1instructions2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase1instructions2"-------
while continueRoutine:
    # get current time
    t = Phase1instructions2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase1instructions2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_phase1_inst2* updates
    if text_phase1_inst2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_phase1_inst2.frameNStart = frameN  # exact frame index
        text_phase1_inst2.tStart = t  # local t and not account for scr refresh
        text_phase1_inst2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_phase1_inst2, 'tStartRefresh')  # time at next scr refresh
        text_phase1_inst2.setAutoDraw(True)
    
    # *key_phase1_inst2* updates
    waitOnFlip = False
    if key_phase1_inst2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_phase1_inst2.frameNStart = frameN  # exact frame index
        key_phase1_inst2.tStart = t  # local t and not account for scr refresh
        key_phase1_inst2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_phase1_inst2, 'tStartRefresh')  # time at next scr refresh
        key_phase1_inst2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_phase1_inst2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_phase1_inst2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_phase1_inst2.status == STARTED and not waitOnFlip:
        theseKeys = key_phase1_inst2.getKeys(keyList=['space'], waitRelease=False)
        _key_phase1_inst2_allKeys.extend(theseKeys)
        if len(_key_phase1_inst2_allKeys):
            key_phase1_inst2.keys = _key_phase1_inst2_allKeys[-1].name  # just the last key pressed
            key_phase1_inst2.rt = _key_phase1_inst2_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase1instructions2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase1instructions2"-------
for thisComponent in Phase1instructions2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_phase1_inst2.started', text_phase1_inst2.tStartRefresh)
thisExp.addData('text_phase1_inst2.stopped', text_phase1_inst2.tStopRefresh)
# check responses
if key_phase1_inst2.keys in ['', [], None]:  # No response was made
    key_phase1_inst2.keys = None
thisExp.addData('key_phase1_inst2.keys',key_phase1_inst2.keys)
if key_phase1_inst2.keys != None:  # we had a response
    thisExp.addData('key_phase1_inst2.rt', key_phase1_inst2.rt)
thisExp.addData('key_phase1_inst2.started', key_phase1_inst2.tStartRefresh)
thisExp.addData('key_phase1_inst2.stopped', key_phase1_inst2.tStopRefresh)
thisExp.nextEntry()
# the Routine "Phase1instructions2" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Phase5T2T1"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_thrwa_thrwa2.setSound('Sounds/thrwa-thrwa.wav', hamming=True)
sound_thrwa_thrwa2.setVolume(1, log=False)
key_Ph5T2T1.keys = []
key_Ph5T2T1.rt = []
_key_Ph5T2T1_allKeys = []
# keep track of which components have finished
Phase5T2T1Components = [sound_thrwa_thrwa2, key_Ph5T2T1, text_2, phases_Ph5T2T1]
for thisComponent in Phase5T2T1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T1"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thrwa_thrwa2
    if sound_thrwa_thrwa2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thrwa_thrwa2.frameNStart = frameN  # exact frame index
        sound_thrwa_thrwa2.tStart = t  # local t and not account for scr refresh
        sound_thrwa_thrwa2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thrwa_thrwa2.play(when=win)  # sync with win flip
    if sound_thrwa_thrwa2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thrwa_thrwa2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thrwa_thrwa2.tStop = t  # not accounting for scr refresh
            sound_thrwa_thrwa2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thrwa_thrwa2, 'tStopRefresh')  # time at next scr refresh
            sound_thrwa_thrwa2.stop()
    
    # *key_Ph5T2T1* updates
    waitOnFlip = False
    if key_Ph5T2T1.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T1.frameNStart = frameN  # exact frame index
        key_Ph5T2T1.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T1, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T1.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T1.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T1.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T1.tStop = t  # not accounting for scr refresh
            key_Ph5T2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T1, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T1.status = FINISHED
    if key_Ph5T2T1.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T1.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T1_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T1_allKeys):
            key_Ph5T2T1.keys = _key_Ph5T2T1_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T1.rt = _key_Ph5T2T1_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T1.keys == str('1')) or (key_Ph5T2T1.keys == '1'):
                key_Ph5T2T1.corr = 1
            else:
                key_Ph5T2T1.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_2* updates
    if text_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_2.frameNStart = frameN  # exact frame index
        text_2.tStart = t  # local t and not account for scr refresh
        text_2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_2, 'tStartRefresh')  # time at next scr refresh
        text_2.setAutoDraw(True)
    if text_2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_2.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_2.tStop = t  # not accounting for scr refresh
            text_2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_2, 'tStopRefresh')  # time at next scr refresh
            text_2.setAutoDraw(False)
    
    # *phases_Ph5T2T1* updates
    if phases_Ph5T2T1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T1.frameNStart = frameN  # exact frame index
        phases_Ph5T2T1.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T1, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T1.setAutoDraw(True)
    if phases_Ph5T2T1.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T1.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T1.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T1.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T1, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T1.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T1"-------
for thisComponent in Phase5T2T1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thrwa_thrwa2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thrwa_thrwa2.started', sound_thrwa_thrwa2.tStartRefresh)
thisExp.addData('sound_thrwa_thrwa2.stopped', sound_thrwa_thrwa2.tStopRefresh)
# check responses
if key_Ph5T2T1.keys in ['', [], None]:  # No response was made
    key_Ph5T2T1.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T2T1.corr = 1;  # correct non-response
    else:
       key_Ph5T2T1.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T1.keys',key_Ph5T2T1.keys)
thisExp.addData('key_Ph5T2T1.corr', key_Ph5T2T1.corr)
if key_Ph5T2T1.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T1.rt', key_Ph5T2T1.rt)
thisExp.addData('key_Ph5T2T1.started', key_Ph5T2T1.tStartRefresh)
thisExp.addData('key_Ph5T2T1.stopped', key_Ph5T2T1.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_2.started', text_2.tStartRefresh)
thisExp.addData('text_2.stopped', text_2.tStopRefresh)
thisExp.addData('phases_Ph5T2T1.started', phases_Ph5T2T1.tStartRefresh)
thisExp.addData('phases_Ph5T2T1.stopped', phases_Ph5T2T1.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T2"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_ththm_thm2.setSound('Sounds/ththm-thm.wav', hamming=True)
sound_ththm_thm2.setVolume(1, log=False)
key_Ph5T2T2.keys = []
key_Ph5T2T2.rt = []
_key_Ph5T2T2_allKeys = []
# keep track of which components have finished
Phase5T2T2Components = [sound_ththm_thm2, key_Ph5T2T2, text_Ph5T2T2, phases_Ph5T2T2]
for thisComponent in Phase5T2T2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T2"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththm_thm2
    if sound_ththm_thm2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththm_thm2.frameNStart = frameN  # exact frame index
        sound_ththm_thm2.tStart = t  # local t and not account for scr refresh
        sound_ththm_thm2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththm_thm2.play(when=win)  # sync with win flip
    if sound_ththm_thm2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththm_thm2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththm_thm2.tStop = t  # not accounting for scr refresh
            sound_ththm_thm2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththm_thm2, 'tStopRefresh')  # time at next scr refresh
            sound_ththm_thm2.stop()
    
    # *key_Ph5T2T2* updates
    waitOnFlip = False
    if key_Ph5T2T2.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T2.frameNStart = frameN  # exact frame index
        key_Ph5T2T2.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T2, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T2.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T2.tStop = t  # not accounting for scr refresh
            key_Ph5T2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T2, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T2.status = FINISHED
    if key_Ph5T2T2.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T2.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T2_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T2_allKeys):
            key_Ph5T2T2.keys = _key_Ph5T2T2_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T2.rt = _key_Ph5T2T2_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T2.keys == str('0')) or (key_Ph5T2T2.keys == '0'):
                key_Ph5T2T2.corr = 1
            else:
                key_Ph5T2T2.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T2* updates
    if text_Ph5T2T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T2.frameNStart = frameN  # exact frame index
        text_Ph5T2T2.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T2, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T2.setAutoDraw(True)
    if text_Ph5T2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T2.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T2.tStop = t  # not accounting for scr refresh
            text_Ph5T2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T2, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T2.setAutoDraw(False)
    
    # *phases_Ph5T2T2* updates
    if phases_Ph5T2T2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T2.frameNStart = frameN  # exact frame index
        phases_Ph5T2T2.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T2, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T2.setAutoDraw(True)
    if phases_Ph5T2T2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T2.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T2.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T2, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T2.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T2"-------
for thisComponent in Phase5T2T2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththm_thm2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththm_thm2.started', sound_ththm_thm2.tStartRefresh)
thisExp.addData('sound_ththm_thm2.stopped', sound_ththm_thm2.tStopRefresh)
# check responses
if key_Ph5T2T2.keys in ['', [], None]:  # No response was made
    key_Ph5T2T2.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T2T2.corr = 1;  # correct non-response
    else:
       key_Ph5T2T2.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T2.keys',key_Ph5T2T2.keys)
thisExp.addData('key_Ph5T2T2.corr', key_Ph5T2T2.corr)
if key_Ph5T2T2.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T2.rt', key_Ph5T2T2.rt)
thisExp.addData('key_Ph5T2T2.started', key_Ph5T2T2.tStartRefresh)
thisExp.addData('key_Ph5T2T2.stopped', key_Ph5T2T2.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T2.started', text_Ph5T2T2.tStartRefresh)
thisExp.addData('text_Ph5T2T2.stopped', text_Ph5T2T2.tStopRefresh)
thisExp.addData('phases_Ph5T2T2.started', phases_Ph5T2T2.tStartRefresh)
thisExp.addData('phases_Ph5T2T2.stopped', phases_Ph5T2T2.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T3"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_ththab_shab2.setSound('Sounds/ththab-shab.wav', hamming=True)
sound_ththab_shab2.setVolume(1, log=False)
key_Ph5T2T3.keys = []
key_Ph5T2T3.rt = []
_key_Ph5T2T3_allKeys = []
# keep track of which components have finished
Phase5T2T3Components = [sound_ththab_shab2, key_Ph5T2T3, text_Ph5T2T3, phases_Ph5T2T3]
for thisComponent in Phase5T2T3Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T3"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T3Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T3Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththab_shab2
    if sound_ththab_shab2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththab_shab2.frameNStart = frameN  # exact frame index
        sound_ththab_shab2.tStart = t  # local t and not account for scr refresh
        sound_ththab_shab2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththab_shab2.play(when=win)  # sync with win flip
    if sound_ththab_shab2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththab_shab2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththab_shab2.tStop = t  # not accounting for scr refresh
            sound_ththab_shab2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththab_shab2, 'tStopRefresh')  # time at next scr refresh
            sound_ththab_shab2.stop()
    
    # *key_Ph5T2T3* updates
    waitOnFlip = False
    if key_Ph5T2T3.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T3.frameNStart = frameN  # exact frame index
        key_Ph5T2T3.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T3, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T3.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T3.tStop = t  # not accounting for scr refresh
            key_Ph5T2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T3, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T3.status = FINISHED
    if key_Ph5T2T3.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T3.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T3_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T3_allKeys):
            key_Ph5T2T3.keys = _key_Ph5T2T3_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T3.rt = _key_Ph5T2T3_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T3.keys == str('0')) or (key_Ph5T2T3.keys == '0'):
                key_Ph5T2T3.corr = 1
            else:
                key_Ph5T2T3.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T3* updates
    if text_Ph5T2T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T3.frameNStart = frameN  # exact frame index
        text_Ph5T2T3.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T3, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T3.setAutoDraw(True)
    if text_Ph5T2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T3.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T3.tStop = t  # not accounting for scr refresh
            text_Ph5T2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T3, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T3.setAutoDraw(False)
    
    # *phases_Ph5T2T3* updates
    if phases_Ph5T2T3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T3.frameNStart = frameN  # exact frame index
        phases_Ph5T2T3.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T3, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T3.setAutoDraw(True)
    if phases_Ph5T2T3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T3.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T3.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T3, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T3.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T3Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T3"-------
for thisComponent in Phase5T2T3Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththab_shab2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththab_shab2.started', sound_ththab_shab2.tStartRefresh)
thisExp.addData('sound_ththab_shab2.stopped', sound_ththab_shab2.tStopRefresh)
# check responses
if key_Ph5T2T3.keys in ['', [], None]:  # No response was made
    key_Ph5T2T3.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T2T3.corr = 1;  # correct non-response
    else:
       key_Ph5T2T3.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T3.keys',key_Ph5T2T3.keys)
thisExp.addData('key_Ph5T2T3.corr', key_Ph5T2T3.corr)
if key_Ph5T2T3.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T3.rt', key_Ph5T2T3.rt)
thisExp.addData('key_Ph5T2T3.started', key_Ph5T2T3.tStartRefresh)
thisExp.addData('key_Ph5T2T3.stopped', key_Ph5T2T3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T3.started', text_Ph5T2T3.tStartRefresh)
thisExp.addData('text_Ph5T2T3.stopped', text_Ph5T2T3.tStopRefresh)
thisExp.addData('phases_Ph5T2T3.started', phases_Ph5T2T3.tStartRefresh)
thisExp.addData('phases_Ph5T2T3.stopped', phases_Ph5T2T3.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T4"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_ththna_ththna2.setSound('Sounds/ththna-ththna.wav', hamming=True)
sound_ththna_ththna2.setVolume(1, log=False)
key_Ph5T2T4.keys = []
key_Ph5T2T4.rt = []
_key_Ph5T2T4_allKeys = []
# keep track of which components have finished
Phase5T2T4Components = [sound_ththna_ththna2, key_Ph5T2T4, text_Ph5T2T4, phases_Ph5T2T4]
for thisComponent in Phase5T2T4Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T4"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T4Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T4Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_ththna_ththna2
    if sound_ththna_ththna2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_ththna_ththna2.frameNStart = frameN  # exact frame index
        sound_ththna_ththna2.tStart = t  # local t and not account for scr refresh
        sound_ththna_ththna2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_ththna_ththna2.play(when=win)  # sync with win flip
    if sound_ththna_ththna2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_ththna_ththna2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_ththna_ththna2.tStop = t  # not accounting for scr refresh
            sound_ththna_ththna2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_ththna_ththna2, 'tStopRefresh')  # time at next scr refresh
            sound_ththna_ththna2.stop()
    
    # *key_Ph5T2T4* updates
    waitOnFlip = False
    if key_Ph5T2T4.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T4.frameNStart = frameN  # exact frame index
        key_Ph5T2T4.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T4, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T4.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T4.tStop = t  # not accounting for scr refresh
            key_Ph5T2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T4, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T4.status = FINISHED
    if key_Ph5T2T4.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T4.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T4_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T4_allKeys):
            key_Ph5T2T4.keys = _key_Ph5T2T4_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T4.rt = _key_Ph5T2T4_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T4.keys == str('1')) or (key_Ph5T2T4.keys == '1'):
                key_Ph5T2T4.corr = 1
            else:
                key_Ph5T2T4.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T4* updates
    if text_Ph5T2T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T4.frameNStart = frameN  # exact frame index
        text_Ph5T2T4.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T4, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T4.setAutoDraw(True)
    if text_Ph5T2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T4.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T4.tStop = t  # not accounting for scr refresh
            text_Ph5T2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T4, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T4.setAutoDraw(False)
    
    # *phases_Ph5T2T4* updates
    if phases_Ph5T2T4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T4.frameNStart = frameN  # exact frame index
        phases_Ph5T2T4.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T4, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T4.setAutoDraw(True)
    if phases_Ph5T2T4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T4.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T4.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T4.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T4, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T4.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T4Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T4"-------
for thisComponent in Phase5T2T4Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_ththna_ththna2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_ththna_ththna2.started', sound_ththna_ththna2.tStartRefresh)
thisExp.addData('sound_ththna_ththna2.stopped', sound_ththna_ththna2.tStopRefresh)
# check responses
if key_Ph5T2T4.keys in ['', [], None]:  # No response was made
    key_Ph5T2T4.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T2T4.corr = 1;  # correct non-response
    else:
       key_Ph5T2T4.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T4.keys',key_Ph5T2T4.keys)
thisExp.addData('key_Ph5T2T4.corr', key_Ph5T2T4.corr)
if key_Ph5T2T4.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T4.rt', key_Ph5T2T4.rt)
thisExp.addData('key_Ph5T2T4.started', key_Ph5T2T4.tStartRefresh)
thisExp.addData('key_Ph5T2T4.stopped', key_Ph5T2T4.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T4.started', text_Ph5T2T4.tStartRefresh)
thisExp.addData('text_Ph5T2T4.stopped', text_Ph5T2T4.tStopRefresh)
thisExp.addData('phases_Ph5T2T4.started', phases_Ph5T2T4.tStartRefresh)
thisExp.addData('phases_Ph5T2T4.stopped', phases_Ph5T2T4.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T5"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_thra_ththra2.setSound('Sounds/thra-ththra.wav', hamming=True)
sound_thra_ththra2.setVolume(1, log=False)
key_Ph5T2T5.keys = []
key_Ph5T2T5.rt = []
_key_Ph5T2T5_allKeys = []
# keep track of which components have finished
Phase5T2T5Components = [sound_thra_ththra2, key_Ph5T2T5, text_Ph5T2T5, phases_Ph5T2T5]
for thisComponent in Phase5T2T5Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T5"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T5Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T5Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thra_ththra2
    if sound_thra_ththra2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thra_ththra2.frameNStart = frameN  # exact frame index
        sound_thra_ththra2.tStart = t  # local t and not account for scr refresh
        sound_thra_ththra2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thra_ththra2.play(when=win)  # sync with win flip
    if sound_thra_ththra2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thra_ththra2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thra_ththra2.tStop = t  # not accounting for scr refresh
            sound_thra_ththra2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thra_ththra2, 'tStopRefresh')  # time at next scr refresh
            sound_thra_ththra2.stop()
    
    # *key_Ph5T2T5* updates
    waitOnFlip = False
    if key_Ph5T2T5.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T5.frameNStart = frameN  # exact frame index
        key_Ph5T2T5.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T5, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T5.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T5.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T5.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T5.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T5.tStop = t  # not accounting for scr refresh
            key_Ph5T2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T5, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T5.status = FINISHED
    if key_Ph5T2T5.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T5.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T5_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T5_allKeys):
            key_Ph5T2T5.keys = _key_Ph5T2T5_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T5.rt = _key_Ph5T2T5_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T5.keys == str('0')) or (key_Ph5T2T5.keys == '0'):
                key_Ph5T2T5.corr = 1
            else:
                key_Ph5T2T5.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T5* updates
    if text_Ph5T2T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T5.frameNStart = frameN  # exact frame index
        text_Ph5T2T5.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T5, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T5.setAutoDraw(True)
    if text_Ph5T2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T5.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T5.tStop = t  # not accounting for scr refresh
            text_Ph5T2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T5, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T5.setAutoDraw(False)
    
    # *phases_Ph5T2T5* updates
    if phases_Ph5T2T5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T5.frameNStart = frameN  # exact frame index
        phases_Ph5T2T5.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T5, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T5.setAutoDraw(True)
    if phases_Ph5T2T5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T5.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T5.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T5.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T5, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T5.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T5Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T5"-------
for thisComponent in Phase5T2T5Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thra_ththra2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thra_ththra2.started', sound_thra_ththra2.tStartRefresh)
thisExp.addData('sound_thra_ththra2.stopped', sound_thra_ththra2.tStopRefresh)
# check responses
if key_Ph5T2T5.keys in ['', [], None]:  # No response was made
    key_Ph5T2T5.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T2T5.corr = 1;  # correct non-response
    else:
       key_Ph5T2T5.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T5.keys',key_Ph5T2T5.keys)
thisExp.addData('key_Ph5T2T5.corr', key_Ph5T2T5.corr)
if key_Ph5T2T5.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T5.rt', key_Ph5T2T5.rt)
thisExp.addData('key_Ph5T2T5.started', key_Ph5T2T5.tStartRefresh)
thisExp.addData('key_Ph5T2T5.stopped', key_Ph5T2T5.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T5.started', text_Ph5T2T5.tStartRefresh)
thisExp.addData('text_Ph5T2T5.stopped', text_Ph5T2T5.tStopRefresh)
thisExp.addData('phases_Ph5T2T5.started', phases_Ph5T2T5.tStartRefresh)
thisExp.addData('phases_Ph5T2T5.stopped', phases_Ph5T2T5.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T6"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_thb7_shb72.setSound('Sounds/thb7-shb7.wav', hamming=True)
sound_thb7_shb72.setVolume(1, log=False)
key_Ph5T2T6.keys = []
key_Ph5T2T6.rt = []
_key_Ph5T2T6_allKeys = []
# keep track of which components have finished
Phase5T2T6Components = [sound_thb7_shb72, key_Ph5T2T6, text_Ph5T2T6, phases_Ph5T2T6]
for thisComponent in Phase5T2T6Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T6"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T6Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T6Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thb7_shb72
    if sound_thb7_shb72.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thb7_shb72.frameNStart = frameN  # exact frame index
        sound_thb7_shb72.tStart = t  # local t and not account for scr refresh
        sound_thb7_shb72.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thb7_shb72.play(when=win)  # sync with win flip
    if sound_thb7_shb72.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thb7_shb72.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thb7_shb72.tStop = t  # not accounting for scr refresh
            sound_thb7_shb72.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thb7_shb72, 'tStopRefresh')  # time at next scr refresh
            sound_thb7_shb72.stop()
    
    # *key_Ph5T2T6* updates
    waitOnFlip = False
    if key_Ph5T2T6.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T6.frameNStart = frameN  # exact frame index
        key_Ph5T2T6.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T6, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T6.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T6.tStop = t  # not accounting for scr refresh
            key_Ph5T2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T6, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T6.status = FINISHED
    if key_Ph5T2T6.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T6.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T6_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T6_allKeys):
            key_Ph5T2T6.keys = _key_Ph5T2T6_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T6.rt = _key_Ph5T2T6_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T6.keys == str('0')) or (key_Ph5T2T6.keys == '0'):
                key_Ph5T2T6.corr = 1
            else:
                key_Ph5T2T6.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T6* updates
    if text_Ph5T2T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T6.frameNStart = frameN  # exact frame index
        text_Ph5T2T6.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T6, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T6.setAutoDraw(True)
    if text_Ph5T2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T6.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T6.tStop = t  # not accounting for scr refresh
            text_Ph5T2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T6, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T6.setAutoDraw(False)
    
    # *phases_Ph5T2T6* updates
    if phases_Ph5T2T6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T6.frameNStart = frameN  # exact frame index
        phases_Ph5T2T6.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T6, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T6.setAutoDraw(True)
    if phases_Ph5T2T6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T6.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T6.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T6.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T6, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T6.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T6Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T6"-------
for thisComponent in Phase5T2T6Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thb7_shb72.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thb7_shb72.started', sound_thb7_shb72.tStartRefresh)
thisExp.addData('sound_thb7_shb72.stopped', sound_thb7_shb72.tStopRefresh)
# check responses
if key_Ph5T2T6.keys in ['', [], None]:  # No response was made
    key_Ph5T2T6.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T2T6.corr = 1;  # correct non-response
    else:
       key_Ph5T2T6.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T6.keys',key_Ph5T2T6.keys)
thisExp.addData('key_Ph5T2T6.corr', key_Ph5T2T6.corr)
if key_Ph5T2T6.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T6.rt', key_Ph5T2T6.rt)
thisExp.addData('key_Ph5T2T6.started', key_Ph5T2T6.tStartRefresh)
thisExp.addData('key_Ph5T2T6.stopped', key_Ph5T2T6.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T6.started', text_Ph5T2T6.tStartRefresh)
thisExp.addData('text_Ph5T2T6.stopped', text_Ph5T2T6.tStopRefresh)
thisExp.addData('phases_Ph5T2T6.started', phases_Ph5T2T6.tStartRefresh)
thisExp.addData('phases_Ph5T2T6.stopped', phases_Ph5T2T6.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T7"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_thwq_thwq2.setSound('Sounds/thwq-thwq.wav', hamming=True)
sound_thwq_thwq2.setVolume(1, log=False)
key_Ph5T2T7.keys = []
key_Ph5T2T7.rt = []
_key_Ph5T2T7_allKeys = []
# keep track of which components have finished
Phase5T2T7Components = [sound_thwq_thwq2, key_Ph5T2T7, text_Ph5T2T7, phases_Ph5T2T7]
for thisComponent in Phase5T2T7Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T7"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T7Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T7Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thwq_thwq2
    if sound_thwq_thwq2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thwq_thwq2.frameNStart = frameN  # exact frame index
        sound_thwq_thwq2.tStart = t  # local t and not account for scr refresh
        sound_thwq_thwq2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thwq_thwq2.play(when=win)  # sync with win flip
    if sound_thwq_thwq2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thwq_thwq2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thwq_thwq2.tStop = t  # not accounting for scr refresh
            sound_thwq_thwq2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thwq_thwq2, 'tStopRefresh')  # time at next scr refresh
            sound_thwq_thwq2.stop()
    
    # *key_Ph5T2T7* updates
    waitOnFlip = False
    if key_Ph5T2T7.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T7.frameNStart = frameN  # exact frame index
        key_Ph5T2T7.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T7, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T7.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T7.tStop = t  # not accounting for scr refresh
            key_Ph5T2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T7, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T7.status = FINISHED
    if key_Ph5T2T7.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T7.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T7_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T7_allKeys):
            key_Ph5T2T7.keys = _key_Ph5T2T7_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T7.rt = _key_Ph5T2T7_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T7.keys == str('1')) or (key_Ph5T2T7.keys == '1'):
                key_Ph5T2T7.corr = 1
            else:
                key_Ph5T2T7.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T7* updates
    if text_Ph5T2T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T7.frameNStart = frameN  # exact frame index
        text_Ph5T2T7.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T7, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T7.setAutoDraw(True)
    if text_Ph5T2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T7.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T7.tStop = t  # not accounting for scr refresh
            text_Ph5T2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T7, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T7.setAutoDraw(False)
    
    # *phases_Ph5T2T7* updates
    if phases_Ph5T2T7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T7.frameNStart = frameN  # exact frame index
        phases_Ph5T2T7.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T7, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T7.setAutoDraw(True)
    if phases_Ph5T2T7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T7.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T7.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T7.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T7, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T7.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T7Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T7"-------
for thisComponent in Phase5T2T7Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thwq_thwq2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thwq_thwq2.started', sound_thwq_thwq2.tStartRefresh)
thisExp.addData('sound_thwq_thwq2.stopped', sound_thwq_thwq2.tStopRefresh)
# check responses
if key_Ph5T2T7.keys in ['', [], None]:  # No response was made
    key_Ph5T2T7.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T2T7.corr = 1;  # correct non-response
    else:
       key_Ph5T2T7.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T7.keys',key_Ph5T2T7.keys)
thisExp.addData('key_Ph5T2T7.corr', key_Ph5T2T7.corr)
if key_Ph5T2T7.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T7.rt', key_Ph5T2T7.rt)
thisExp.addData('key_Ph5T2T7.started', key_Ph5T2T7.tStartRefresh)
thisExp.addData('key_Ph5T2T7.stopped', key_Ph5T2T7.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T7.started', text_Ph5T2T7.tStartRefresh)
thisExp.addData('text_Ph5T2T7.stopped', text_Ph5T2T7.tStopRefresh)
thisExp.addData('phases_Ph5T2T7.started', phases_Ph5T2T7.tStartRefresh)
thisExp.addData('phases_Ph5T2T7.stopped', phases_Ph5T2T7.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T8"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_thail_thail2.setSound('Sounds/thail-thail.wav', hamming=True)
sound_thail_thail2.setVolume(1, log=False)
key_Ph5T2T8.keys = []
key_Ph5T2T8.rt = []
_key_Ph5T2T8_allKeys = []
# keep track of which components have finished
Phase5T2T8Components = [sound_thail_thail2, key_Ph5T2T8, text_Ph5T2T8, phases_Ph5T2T8]
for thisComponent in Phase5T2T8Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T8"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T8Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T8Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_thail_thail2
    if sound_thail_thail2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_thail_thail2.frameNStart = frameN  # exact frame index
        sound_thail_thail2.tStart = t  # local t and not account for scr refresh
        sound_thail_thail2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_thail_thail2.play(when=win)  # sync with win flip
    if sound_thail_thail2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_thail_thail2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_thail_thail2.tStop = t  # not accounting for scr refresh
            sound_thail_thail2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_thail_thail2, 'tStopRefresh')  # time at next scr refresh
            sound_thail_thail2.stop()
    
    # *key_Ph5T2T8* updates
    waitOnFlip = False
    if key_Ph5T2T8.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T8.frameNStart = frameN  # exact frame index
        key_Ph5T2T8.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T8, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T8.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T8.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T8.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T8.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T8.tStop = t  # not accounting for scr refresh
            key_Ph5T2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T8, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T8.status = FINISHED
    if key_Ph5T2T8.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T8.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T8_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T8_allKeys):
            key_Ph5T2T8.keys = _key_Ph5T2T8_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T8.rt = _key_Ph5T2T8_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T8.keys == str('1')) or (key_Ph5T2T8.keys == '1'):
                key_Ph5T2T8.corr = 1
            else:
                key_Ph5T2T8.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T8* updates
    if text_Ph5T2T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T8.frameNStart = frameN  # exact frame index
        text_Ph5T2T8.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T8, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T8.setAutoDraw(True)
    if text_Ph5T2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T8.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T8.tStop = t  # not accounting for scr refresh
            text_Ph5T2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T8, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T8.setAutoDraw(False)
    
    # *phases_Ph5T2T8* updates
    if phases_Ph5T2T8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T8.frameNStart = frameN  # exact frame index
        phases_Ph5T2T8.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T8, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T8.setAutoDraw(True)
    if phases_Ph5T2T8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T8.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T8.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T8.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T8, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T8.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T8Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T8"-------
for thisComponent in Phase5T2T8Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_thail_thail2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_thail_thail2.started', sound_thail_thail2.tStartRefresh)
thisExp.addData('sound_thail_thail2.stopped', sound_thail_thail2.tStopRefresh)
# check responses
if key_Ph5T2T8.keys in ['', [], None]:  # No response was made
    key_Ph5T2T8.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T2T8.corr = 1;  # correct non-response
    else:
       key_Ph5T2T8.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T8.keys',key_Ph5T2T8.keys)
thisExp.addData('key_Ph5T2T8.corr', key_Ph5T2T8.corr)
if key_Ph5T2T8.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T8.rt', key_Ph5T2T8.rt)
thisExp.addData('key_Ph5T2T8.started', key_Ph5T2T8.tStartRefresh)
thisExp.addData('key_Ph5T2T8.stopped', key_Ph5T2T8.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T8.started', text_Ph5T2T8.tStartRefresh)
thisExp.addData('text_Ph5T2T8.stopped', text_Ph5T2T8.tStopRefresh)
thisExp.addData('phases_Ph5T2T8.started', phases_Ph5T2T8.tStartRefresh)
thisExp.addData('phases_Ph5T2T8.stopped', phases_Ph5T2T8.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T9"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_shrf_thrf2.setSound('Sounds/shrf-thrf.wav', hamming=True)
sound_shrf_thrf2.setVolume(1, log=False)
key_Ph5T2T9.keys = []
key_Ph5T2T9.rt = []
_key_Ph5T2T9_allKeys = []
# keep track of which components have finished
Phase5T2T9Components = [sound_shrf_thrf2, key_Ph5T2T9, text_Ph5T2T9, phases_Ph5T2T9]
for thisComponent in Phase5T2T9Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T9"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T9Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T9Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_shrf_thrf2
    if sound_shrf_thrf2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_shrf_thrf2.frameNStart = frameN  # exact frame index
        sound_shrf_thrf2.tStart = t  # local t and not account for scr refresh
        sound_shrf_thrf2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_shrf_thrf2.play(when=win)  # sync with win flip
    if sound_shrf_thrf2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_shrf_thrf2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_shrf_thrf2.tStop = t  # not accounting for scr refresh
            sound_shrf_thrf2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_shrf_thrf2, 'tStopRefresh')  # time at next scr refresh
            sound_shrf_thrf2.stop()
    
    # *key_Ph5T2T9* updates
    waitOnFlip = False
    if key_Ph5T2T9.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T9.frameNStart = frameN  # exact frame index
        key_Ph5T2T9.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T9, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T9.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T9.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T9.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T9.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T9.tStop = t  # not accounting for scr refresh
            key_Ph5T2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T9, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T9.status = FINISHED
    if key_Ph5T2T9.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T9.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T9_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T9_allKeys):
            key_Ph5T2T9.keys = _key_Ph5T2T9_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T9.rt = _key_Ph5T2T9_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T9.keys == str('0')) or (key_Ph5T2T9.keys == '0'):
                key_Ph5T2T9.corr = 1
            else:
                key_Ph5T2T9.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T9* updates
    if text_Ph5T2T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T9.frameNStart = frameN  # exact frame index
        text_Ph5T2T9.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T9, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T9.setAutoDraw(True)
    if text_Ph5T2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T9.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T9.tStop = t  # not accounting for scr refresh
            text_Ph5T2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T9, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T9.setAutoDraw(False)
    
    # *phases_Ph5T2T9* updates
    if phases_Ph5T2T9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T9.frameNStart = frameN  # exact frame index
        phases_Ph5T2T9.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T9, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T9.setAutoDraw(True)
    if phases_Ph5T2T9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T9.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T9.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T9.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T9, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T9.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T9Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T9"-------
for thisComponent in Phase5T2T9Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_shrf_thrf2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_shrf_thrf2.started', sound_shrf_thrf2.tStartRefresh)
thisExp.addData('sound_shrf_thrf2.stopped', sound_shrf_thrf2.tStopRefresh)
# check responses
if key_Ph5T2T9.keys in ['', [], None]:  # No response was made
    key_Ph5T2T9.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T2T9.corr = 1;  # correct non-response
    else:
       key_Ph5T2T9.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T9.keys',key_Ph5T2T9.keys)
thisExp.addData('key_Ph5T2T9.corr', key_Ph5T2T9.corr)
if key_Ph5T2T9.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T9.rt', key_Ph5T2T9.rt)
thisExp.addData('key_Ph5T2T9.started', key_Ph5T2T9.tStartRefresh)
thisExp.addData('key_Ph5T2T9.stopped', key_Ph5T2T9.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T9.started', text_Ph5T2T9.tStartRefresh)
thisExp.addData('text_Ph5T2T9.stopped', text_Ph5T2T9.tStopRefresh)
thisExp.addData('phases_Ph5T2T9.started', phases_Ph5T2T9.tStartRefresh)
thisExp.addData('phases_Ph5T2T9.stopped', phases_Ph5T2T9.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T10"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_sh7m_sh7m2.setSound('Sounds/sh7m-sh7m.wav', hamming=True)
sound_sh7m_sh7m2.setVolume(1, log=False)
key_Ph5T2T10.keys = []
key_Ph5T2T10.rt = []
_key_Ph5T2T10_allKeys = []
# keep track of which components have finished
Phase5T2T10Components = [sound_sh7m_sh7m2, key_Ph5T2T10, text_Ph5T2T10, phases_Ph5T2T10]
for thisComponent in Phase5T2T10Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T10"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T10Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T10Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_sh7m_sh7m2
    if sound_sh7m_sh7m2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_sh7m_sh7m2.frameNStart = frameN  # exact frame index
        sound_sh7m_sh7m2.tStart = t  # local t and not account for scr refresh
        sound_sh7m_sh7m2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_sh7m_sh7m2.play(when=win)  # sync with win flip
    if sound_sh7m_sh7m2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_sh7m_sh7m2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_sh7m_sh7m2.tStop = t  # not accounting for scr refresh
            sound_sh7m_sh7m2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_sh7m_sh7m2, 'tStopRefresh')  # time at next scr refresh
            sound_sh7m_sh7m2.stop()
    
    # *key_Ph5T2T10* updates
    waitOnFlip = False
    if key_Ph5T2T10.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T10.frameNStart = frameN  # exact frame index
        key_Ph5T2T10.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T10, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T10.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T10.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T10.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T10.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T10.tStop = t  # not accounting for scr refresh
            key_Ph5T2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T10, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T10.status = FINISHED
    if key_Ph5T2T10.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T10.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T10_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T10_allKeys):
            key_Ph5T2T10.keys = _key_Ph5T2T10_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T10.rt = _key_Ph5T2T10_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T10.keys == str('1')) or (key_Ph5T2T10.keys == '1'):
                key_Ph5T2T10.corr = 1
            else:
                key_Ph5T2T10.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T10* updates
    if text_Ph5T2T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T10.frameNStart = frameN  # exact frame index
        text_Ph5T2T10.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T10, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T10.setAutoDraw(True)
    if text_Ph5T2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T10.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T10.tStop = t  # not accounting for scr refresh
            text_Ph5T2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T10, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T10.setAutoDraw(False)
    
    # *phases_Ph5T2T10* updates
    if phases_Ph5T2T10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T10.frameNStart = frameN  # exact frame index
        phases_Ph5T2T10.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T10, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T10.setAutoDraw(True)
    if phases_Ph5T2T10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T10.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T10.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T10.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T10, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T10.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T10Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T10"-------
for thisComponent in Phase5T2T10Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_sh7m_sh7m2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_sh7m_sh7m2.started', sound_sh7m_sh7m2.tStartRefresh)
thisExp.addData('sound_sh7m_sh7m2.stopped', sound_sh7m_sh7m2.tStopRefresh)
# check responses
if key_Ph5T2T10.keys in ['', [], None]:  # No response was made
    key_Ph5T2T10.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T2T10.corr = 1;  # correct non-response
    else:
       key_Ph5T2T10.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T10.keys',key_Ph5T2T10.keys)
thisExp.addData('key_Ph5T2T10.corr', key_Ph5T2T10.corr)
if key_Ph5T2T10.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T10.rt', key_Ph5T2T10.rt)
thisExp.addData('key_Ph5T2T10.started', key_Ph5T2T10.tStartRefresh)
thisExp.addData('key_Ph5T2T10.stopped', key_Ph5T2T10.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T10.started', text_Ph5T2T10.tStartRefresh)
thisExp.addData('text_Ph5T2T10.stopped', text_Ph5T2T10.tStopRefresh)
thisExp.addData('phases_Ph5T2T10.started', phases_Ph5T2T10.tStartRefresh)
thisExp.addData('phases_Ph5T2T10.stopped', phases_Ph5T2T10.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T11"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_shra_ththra2.setSound('Sounds/shra-ththra.wav', hamming=True)
sound_shra_ththra2.setVolume(1, log=False)
key_Ph5T2T11.keys = []
key_Ph5T2T11.rt = []
_key_Ph5T2T11_allKeys = []
# keep track of which components have finished
Phase5T2T11Components = [sound_shra_ththra2, key_Ph5T2T11, text_Ph5T2T11, phases_Ph5T2T11]
for thisComponent in Phase5T2T11Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T11"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T11Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T11Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_shra_ththra2
    if sound_shra_ththra2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_shra_ththra2.frameNStart = frameN  # exact frame index
        sound_shra_ththra2.tStart = t  # local t and not account for scr refresh
        sound_shra_ththra2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_shra_ththra2.play(when=win)  # sync with win flip
    if sound_shra_ththra2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_shra_ththra2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_shra_ththra2.tStop = t  # not accounting for scr refresh
            sound_shra_ththra2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_shra_ththra2, 'tStopRefresh')  # time at next scr refresh
            sound_shra_ththra2.stop()
    
    # *key_Ph5T2T11* updates
    waitOnFlip = False
    if key_Ph5T2T11.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T11.frameNStart = frameN  # exact frame index
        key_Ph5T2T11.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T11, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T11.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T11.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T11.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T11.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T11.tStop = t  # not accounting for scr refresh
            key_Ph5T2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T11, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T11.status = FINISHED
    if key_Ph5T2T11.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T11.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T11_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T11_allKeys):
            key_Ph5T2T11.keys = _key_Ph5T2T11_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T11.rt = _key_Ph5T2T11_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T11.keys == str('0')) or (key_Ph5T2T11.keys == '0'):
                key_Ph5T2T11.corr = 1
            else:
                key_Ph5T2T11.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T11* updates
    if text_Ph5T2T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T11.frameNStart = frameN  # exact frame index
        text_Ph5T2T11.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T11, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T11.setAutoDraw(True)
    if text_Ph5T2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T11.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T11.tStop = t  # not accounting for scr refresh
            text_Ph5T2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T11, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T11.setAutoDraw(False)
    
    # *phases_Ph5T2T11* updates
    if phases_Ph5T2T11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T11.frameNStart = frameN  # exact frame index
        phases_Ph5T2T11.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T11, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T11.setAutoDraw(True)
    if phases_Ph5T2T11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T11.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T11.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T11.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T11, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T11.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T11Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T11"-------
for thisComponent in Phase5T2T11Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_shra_ththra2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_shra_ththra2.started', sound_shra_ththra2.tStartRefresh)
thisExp.addData('sound_shra_ththra2.stopped', sound_shra_ththra2.tStopRefresh)
# check responses
if key_Ph5T2T11.keys in ['', [], None]:  # No response was made
    key_Ph5T2T11.keys = None
    # was no response the correct answer?!
    if str('0').lower() == 'none':
       key_Ph5T2T11.corr = 1;  # correct non-response
    else:
       key_Ph5T2T11.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T11.keys',key_Ph5T2T11.keys)
thisExp.addData('key_Ph5T2T11.corr', key_Ph5T2T11.corr)
if key_Ph5T2T11.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T11.rt', key_Ph5T2T11.rt)
thisExp.addData('key_Ph5T2T11.started', key_Ph5T2T11.tStartRefresh)
thisExp.addData('key_Ph5T2T11.stopped', key_Ph5T2T11.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T11.started', text_Ph5T2T11.tStartRefresh)
thisExp.addData('text_Ph5T2T11.stopped', text_Ph5T2T11.tStopRefresh)
thisExp.addData('phases_Ph5T2T11.started', phases_Ph5T2T11.tStartRefresh)
thisExp.addData('phases_Ph5T2T11.stopped', phases_Ph5T2T11.tStopRefresh)

# ------Prepare to start Routine "Blank"-------
continueRoutine = True
routineTimer.add(0.500000)
# update component parameters for each repeat
# keep track of which components have finished
BlankComponents = [text_blank]
for thisComponent in BlankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
BlankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = BlankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=BlankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_blank* updates
    if text_blank.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_blank.frameNStart = frameN  # exact frame index
        text_blank.tStart = t  # local t and not account for scr refresh
        text_blank.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_blank, 'tStartRefresh')  # time at next scr refresh
        text_blank.setAutoDraw(True)
    if text_blank.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_blank.tStartRefresh + 0.5-frameTolerance:
            # keep track of stop time/frame for later
            text_blank.tStop = t  # not accounting for scr refresh
            text_blank.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_blank, 'tStopRefresh')  # time at next scr refresh
            text_blank.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in BlankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Blank"-------
for thisComponent in BlankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_blank.started', text_blank.tStartRefresh)
thisExp.addData('text_blank.stopped', text_blank.tStopRefresh)

# ------Prepare to start Routine "Phase5T2T12"-------
continueRoutine = True
routineTimer.add(10.200000)
# update component parameters for each repeat
sound_shfa_shfa2.setSound('Sounds/shfa-shfa.wav', hamming=True)
sound_shfa_shfa2.setVolume(1, log=False)
key_Ph5T2T12.keys = []
key_Ph5T2T12.rt = []
_key_Ph5T2T12_allKeys = []
# keep track of which components have finished
Phase5T2T12Components = [sound_shfa_shfa2, key_Ph5T2T12, text_Ph5T2T12, phases_Ph5T2T12]
for thisComponent in Phase5T2T12Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Phase5T2T12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Phase5T2T12"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = Phase5T2T12Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Phase5T2T12Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_shfa_shfa2
    if sound_shfa_shfa2.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
        # keep track of start time/frame for later
        sound_shfa_shfa2.frameNStart = frameN  # exact frame index
        sound_shfa_shfa2.tStart = t  # local t and not account for scr refresh
        sound_shfa_shfa2.tStartRefresh = tThisFlipGlobal  # on global time
        sound_shfa_shfa2.play(when=win)  # sync with win flip
    if sound_shfa_shfa2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_shfa_shfa2.tStartRefresh + 5-frameTolerance:
            # keep track of stop time/frame for later
            sound_shfa_shfa2.tStop = t  # not accounting for scr refresh
            sound_shfa_shfa2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(sound_shfa_shfa2, 'tStopRefresh')  # time at next scr refresh
            sound_shfa_shfa2.stop()
    
    # *key_Ph5T2T12* updates
    waitOnFlip = False
    if key_Ph5T2T12.status == NOT_STARTED and tThisFlip >= 4.2-frameTolerance:
        # keep track of start time/frame for later
        key_Ph5T2T12.frameNStart = frameN  # exact frame index
        key_Ph5T2T12.tStart = t  # local t and not account for scr refresh
        key_Ph5T2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_Ph5T2T12, 'tStartRefresh')  # time at next scr refresh
        key_Ph5T2T12.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_Ph5T2T12.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_Ph5T2T12.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_Ph5T2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_Ph5T2T12.tStartRefresh + 6-frameTolerance:
            # keep track of stop time/frame for later
            key_Ph5T2T12.tStop = t  # not accounting for scr refresh
            key_Ph5T2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(key_Ph5T2T12, 'tStopRefresh')  # time at next scr refresh
            key_Ph5T2T12.status = FINISHED
    if key_Ph5T2T12.status == STARTED and not waitOnFlip:
        theseKeys = key_Ph5T2T12.getKeys(keyList=['1', '0'], waitRelease=False)
        _key_Ph5T2T12_allKeys.extend(theseKeys)
        if len(_key_Ph5T2T12_allKeys):
            key_Ph5T2T12.keys = _key_Ph5T2T12_allKeys[-1].name  # just the last key pressed
            key_Ph5T2T12.rt = _key_Ph5T2T12_allKeys[-1].rt
            # was this correct?
            if (key_Ph5T2T12.keys == str('1')) or (key_Ph5T2T12.keys == '1'):
                key_Ph5T2T12.corr = 1
            else:
                key_Ph5T2T12.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *text_Ph5T2T12* updates
    if text_Ph5T2T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Ph5T2T12.frameNStart = frameN  # exact frame index
        text_Ph5T2T12.tStart = t  # local t and not account for scr refresh
        text_Ph5T2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Ph5T2T12, 'tStartRefresh')  # time at next scr refresh
        text_Ph5T2T12.setAutoDraw(True)
    if text_Ph5T2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_Ph5T2T12.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            text_Ph5T2T12.tStop = t  # not accounting for scr refresh
            text_Ph5T2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_Ph5T2T12, 'tStopRefresh')  # time at next scr refresh
            text_Ph5T2T12.setAutoDraw(False)
    
    # *phases_Ph5T2T12* updates
    if phases_Ph5T2T12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_Ph5T2T12.frameNStart = frameN  # exact frame index
        phases_Ph5T2T12.tStart = t  # local t and not account for scr refresh
        phases_Ph5T2T12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_Ph5T2T12, 'tStartRefresh')  # time at next scr refresh
        phases_Ph5T2T12.setAutoDraw(True)
    if phases_Ph5T2T12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > phases_Ph5T2T12.tStartRefresh + 10.2-frameTolerance:
            # keep track of stop time/frame for later
            phases_Ph5T2T12.tStop = t  # not accounting for scr refresh
            phases_Ph5T2T12.frameNStop = frameN  # exact frame index
            win.timeOnFlip(phases_Ph5T2T12, 'tStopRefresh')  # time at next scr refresh
            phases_Ph5T2T12.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Phase5T2T12Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Phase5T2T12"-------
for thisComponent in Phase5T2T12Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_shfa_shfa2.stop()  # ensure sound has stopped at end of routine
thisExp.addData('sound_shfa_shfa2.started', sound_shfa_shfa2.tStartRefresh)
thisExp.addData('sound_shfa_shfa2.stopped', sound_shfa_shfa2.tStopRefresh)
# check responses
if key_Ph5T2T12.keys in ['', [], None]:  # No response was made
    key_Ph5T2T12.keys = None
    # was no response the correct answer?!
    if str('1').lower() == 'none':
       key_Ph5T2T12.corr = 1;  # correct non-response
    else:
       key_Ph5T2T12.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_Ph5T2T12.keys',key_Ph5T2T12.keys)
thisExp.addData('key_Ph5T2T12.corr', key_Ph5T2T12.corr)
if key_Ph5T2T12.keys != None:  # we had a response
    thisExp.addData('key_Ph5T2T12.rt', key_Ph5T2T12.rt)
thisExp.addData('key_Ph5T2T12.started', key_Ph5T2T12.tStartRefresh)
thisExp.addData('key_Ph5T2T12.stopped', key_Ph5T2T12.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_Ph5T2T12.started', text_Ph5T2T12.tStartRefresh)
thisExp.addData('text_Ph5T2T12.stopped', text_Ph5T2T12.tStopRefresh)
thisExp.addData('phases_Ph5T2T12.started', phases_Ph5T2T12.tStartRefresh)
thisExp.addData('phases_Ph5T2T12.stopped', phases_Ph5T2T12.tStopRefresh)

# ------Prepare to start Routine "EndExperiment"-------
continueRoutine = True
# update component parameters for each repeat
key_EndExperiment.keys = []
key_EndExperiment.rt = []
_key_EndExperiment_allKeys = []
# keep track of which components have finished
EndExperimentComponents = [text_EndExperiment, key_EndExperiment, phases_end]
for thisComponent in EndExperimentComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
EndExperimentClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "EndExperiment"-------
while continueRoutine:
    # get current time
    t = EndExperimentClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=EndExperimentClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_EndExperiment* updates
    if text_EndExperiment.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_EndExperiment.frameNStart = frameN  # exact frame index
        text_EndExperiment.tStart = t  # local t and not account for scr refresh
        text_EndExperiment.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_EndExperiment, 'tStartRefresh')  # time at next scr refresh
        text_EndExperiment.setAutoDraw(True)
    
    # *key_EndExperiment* updates
    waitOnFlip = False
    if key_EndExperiment.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_EndExperiment.frameNStart = frameN  # exact frame index
        key_EndExperiment.tStart = t  # local t and not account for scr refresh
        key_EndExperiment.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_EndExperiment, 'tStartRefresh')  # time at next scr refresh
        key_EndExperiment.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_EndExperiment.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_EndExperiment.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_EndExperiment.status == STARTED and not waitOnFlip:
        theseKeys = key_EndExperiment.getKeys(keyList=['space'], waitRelease=False)
        _key_EndExperiment_allKeys.extend(theseKeys)
        if len(_key_EndExperiment_allKeys):
            key_EndExperiment.keys = _key_EndExperiment_allKeys[-1].name  # just the last key pressed
            key_EndExperiment.rt = _key_EndExperiment_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # *phases_end* updates
    if phases_end.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        phases_end.frameNStart = frameN  # exact frame index
        phases_end.tStart = t  # local t and not account for scr refresh
        phases_end.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(phases_end, 'tStartRefresh')  # time at next scr refresh
        phases_end.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in EndExperimentComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "EndExperiment"-------
for thisComponent in EndExperimentComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_EndExperiment.started', text_EndExperiment.tStartRefresh)
thisExp.addData('text_EndExperiment.stopped', text_EndExperiment.tStopRefresh)
# check responses
if key_EndExperiment.keys in ['', [], None]:  # No response was made
    key_EndExperiment.keys = None
thisExp.addData('key_EndExperiment.keys',key_EndExperiment.keys)
if key_EndExperiment.keys != None:  # we had a response
    thisExp.addData('key_EndExperiment.rt', key_EndExperiment.rt)
thisExp.addData('key_EndExperiment.started', key_EndExperiment.tStartRefresh)
thisExp.addData('key_EndExperiment.stopped', key_EndExperiment.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('phases_end.started', phases_end.tStartRefresh)
thisExp.addData('phases_end.stopped', phases_end.tStopRefresh)
# the Routine "EndExperiment" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# Flip one final time so any remaining win.callOnFlip() 
# and win.timeOnFlip() tasks get executed before quitting
win.flip()

# these shouldn't be strictly necessary (should auto-save)
thisExp.saveAsWideText(filename+'.csv')
thisExp.saveAsPickle(filename)
logging.flush()
# make sure everything is closed down
thisExp.abort()  # or data files will save again on exit
win.close()
core.quit()
